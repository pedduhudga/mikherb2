<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Herbicide Trial Manager</title>

    <!-- External Libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.23/jspdf.plugin.autotable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pptxgenjs@3.12.0/dist/pptxgen.bundle.js"></script>
    <!-- QR Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>

    <style>
        :root {
            --primary-color: #0d9488;
            /* teal-600 */
            --primary-hover-color: #0f766e;
            /* teal-700 */
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #f1f5f9;
            /* slate-100 */
        }

        .btn-primary {
            background-color: var(--primary-color);
            transition: background-color 0.2s;
        }

        .btn-primary:hover {
            background-color: var(--primary-hover-color);
        }

        .form-input:focus {
            --tw-ring-color: var(--primary-color);
            border-color: var(--primary-color);
            outline: 2px solid transparent;
            outline-offset: 2px;
            --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
            --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);
            box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
        }

        .sidebar {
            transition: transform 0.3s ease-in-out;
        }

        @media (max-width: 768px) {
            .sidebar {
                transform: translateX(-100%);
            }

            .sidebar.open {
                transform: translateX(0);
            }
        }

        /* Animations */
        @keyframes contentFadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .dashboard-card {
            animation: contentFadeIn 0.5s ease-out forwards;
            opacity: 0;
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            border-radius: 8px;
            color: white;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s, bottom 0.3s;
            z-index: 10000;
        }

        .toast.show {
            opacity: 1;
            visibility: visible;
            bottom: 30px;
        }

        .toast.success {
            background-color: #10b981;
        }

        /* green-500 */
        .toast.error {
            background-color: #ef4444;
        }

        /* red-500 */
        .toast.info {
            background-color: #3b82f6;
        }

        /* blue-500 */

        /* Loading Overlay */
        #loading-overlay {
            z-index: 9999;
        }

        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: var(--primary-color);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Cropper Modal */
        #cropper-modal {
            display: none;
        }

        #image-to-crop {
            max-height: 60vh;
            max-width: 100%;
            display: block;
        }

        /* Camera Modal */
        #camera-modal-fixed {
            display: none;
        }

        /* Result Colors */
        .result-excellent {
            color: #059669;
            background-color: #d1fae5;
        }

        .result-good {
            color: #0284c7;
            background-color: #dbeafe;
        }

        .result-fair {
            color: #d97706;
            background-color: #fef3c7;
        }

        .result-poor {
            color: #dc2626;
            background-color: #fee2e2;
        }

        .result-none {
            color: #4b5563;
            background-color: #e5e7eb;
        }

        /* Utility */
        .hidden {
            display: none !important;
        }

        /* QR Scanner Overlay */
        .scanner-frame {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 250px;
            height: 250px;
            border: 4px solid var(--primary-color);
            border-radius: 12px;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.5);
            pointer-events: none;
        }

        .scanner-line {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: var(--primary-color);
            box-shadow: 0 0 8px var(--primary-color);
            animation: scan 2s linear infinite;
        }

        @keyframes scan {
            0% {
                top: 0;
            }

            100% {
                top: 100%;
            }
        }

        /* Selection Bar */
        #selection-bar {
            transition: transform 0.3s ease-in-out;
        }

        #selection-bar.hidden {
            transform: translate(-50%, 150%);
            display: flex !important;
        }
    </style>

    <!-- Import Map for Gemini SDK -->
    <script type="importmap">
    {
      "imports": {
        "@google/genai": "https://aistudiocdn.com/@google/genai@^1.29.0"
      }
    }
    </script>
</head>

<body class="bg-slate-100">
    <!-- Selection Bar -->
    <div id="selection-bar"
        class="fixed bottom-10 left-1/2 -translate-x-1/2 bg-slate-800 text-white py-3 px-6 rounded-full shadow-lg flex items-center gap-4 z-50 text-sm font-semibold hidden transition-transform duration-300">
        <span id="selected-items-count">0 selected</span>
        <div class="h-4 w-px bg-slate-600 mx-2"></div>
        <button data-action="open-organise-modal" class="hover:text-teal-300 transition flex items-center gap-2"><i
                data-lucide="folder-plus" class="h-4 w-4"></i>Group</button>
        <button data-action="go-to-compare" class="hover:text-teal-300 transition flex items-center gap-2"><i
                data-lucide="bar-chart-3" class="h-4 w-4"></i>Compare</button>
        <button data-action="print-pdf" class="hover:text-teal-300 transition flex items-center gap-2"><i
                data-lucide="file-down" class="h-4 w-4"></i>PDF Cards</button>
        <button data-action="print-cards" class="hover:text-teal-300 transition flex items-center gap-2"><i
                data-lucide="printer" class="h-4 w-4"></i>Print</button>
        <button data-action="clear-selection" class="ml-2 text-slate-400 hover:text-white">&times;</button>
    </div>
    <div class="flex h-screen">
        <!-- Sidebar -->
        <aside id="sidebar"
            class="sidebar bg-white w-64 flex-shrink-0 border-r border-slate-200 flex flex-col fixed inset-y-0 left-0 z-30 md:relative md:translate-x-0">
            <div class="px-6 py-4 border-b">
                <h2 class="font-bold text-xl text-teal-700 flex items-center gap-2"><i data-lucide="flask-conical"></i>
                    Trial Manager</h2>
            </div>
            <nav id="sidebar-nav" class="flex-grow p-4 space-y-2">
                <a href="#" data-page="dashboard"
                    class="flex items-center gap-3 px-4 py-2 rounded-lg text-slate-600 hover:bg-teal-50 hover:text-teal-700">
                    <i data-lucide="layout-dashboard"></i><span>Dashboard</span>
                </a>
                <a href="#" data-action="open-plot-scanner"
                    class="flex items-center gap-3 px-4 py-2 rounded-lg text-slate-600 hover:bg-teal-50 hover:text-teal-700">
                    <i data-lucide="scan-qr-code"></i><span>Plot Scanner</span>
                </a>
                <a href="#" data-page="formulations"
                    class="flex items-center gap-3 px-4 py-2 rounded-lg text-slate-600 hover:bg-teal-50 hover:text-teal-700">
                    <i data-lucide="flask-conical"></i><span>Formulations</span>
                </a>
                <a href="#" data-page="trials"
                    class="flex items-center gap-3 px-4 py-2 rounded-lg text-slate-600 hover:bg-teal-50 hover:text-teal-700">
                    <i data-lucide="list-checks"></i><span>Trials</span>
                </a>
                <a href="#" data-page="compareTrials"
                    class="flex items-center gap-3 px-4 py-2 rounded-lg text-slate-600 hover:bg-teal-50 hover:text-teal-700">
                    <i data-lucide="file-box"></i><span>Reports & Cards</span>
                </a>
                <a href="#" data-page="organisations"
                    class="flex items-center gap-3 px-4 py-2 rounded-lg text-slate-600 hover:bg-teal-50 hover:text-teal-700">
                    <i data-lucide="folder-kanban"></i><span>Organisations</span>
                </a>
                <a href="#" data-page="ingredients"
                    class="flex items-center gap-3 px-4 py-2 rounded-lg text-slate-600 hover:bg-teal-50 hover:text-teal-700">
                    <i data-lucide="shopping-bag"></i><span>Ingredient Costs</span>
                </a>
                <a href="#" data-page="aiAssistant"
                    class="flex items-center gap-3 px-4 py-2 rounded-lg text-slate-600 hover:bg-teal-50 hover:text-teal-700">
                    <i data-lucide="sparkles"></i><span>AI Assistant</span>
                </a>
                <div class="pt-4 mt-auto border-t">
                    <a href="#" data-page="dataMgmt"
                        class="flex items-center gap-3 px-4 py-2 rounded-lg text-slate-600 hover:bg-teal-50 hover:text-teal-700">
                        <i data-lucide="database"></i><span>Data Management</span>
                    </a>
                    <a href="#" data-page="settings"
                        class="flex items-center gap-3 px-4 py-2 rounded-lg text-slate-600 hover:bg-teal-50 hover:text-teal-700">
                        <i data-lucide="settings"></i><span>Settings</span>
                    </a>
                </div>
            </nav>
        </aside>

        <!-- Main Content -->
        <main class="flex-1 flex flex-col overflow-hidden">
            <!-- Header -->
            <header class="bg-white border-b border-slate-200 p-4 flex justify-between items-center flex-shrink-0">
                <button id="menu-toggle" class="md:hidden p-2 rounded-md text-slate-600 hover:bg-slate-100">
                    <i data-lucide="menu"></i>
                </button>
                <h1 id="page-title" class="text-xl font-semibold text-slate-800">Dashboard</h1>
                <div id="sync-status" class="flex items-center gap-2 text-xs font-semibold"></div>
                <div><!-- Placeholder for any header actions --></div>
            </header>

            <!-- Content Area -->
            <div id="main-content-wrapper" class="flex-1 overflow-y-auto p-6">
                <div id="main-content">
                    <!-- Dynamic content will be injected here -->
                </div>
                <!-- Selection Bar -->
                <div id="selection-bar"
                    class="fixed bottom-10 left-1/2 -translate-x-1/2 bg-slate-800 text-white py-3 px-6 rounded-full shadow-lg flex items-center gap-4 z-40 text-sm font-semibold hidden transition-transform duration-300">
                    <span id="selected-items-count">0 selected</span>
                    <div class="h-4 w-px bg-slate-600 mx-2"></div>
                    <button data-action="compare-trials"
                        class="hover:text-teal-300 transition flex items-center gap-2"><i data-lucide="bar-chart-3"
                            class="h-4 w-4"></i>Compare</button>
                    <button data-action="print-pdf" class="hover:text-teal-300 transition flex items-center gap-2"><i
                            data-lucide="file-down" class="h-4 w-4"></i>Download PDF</button>
                    <button data-action="print-cards" class="hover:text-teal-300 transition flex items-center gap-2"><i
                            data-lucide="printer" class="h-4 w-4"></i>Print Cards</button>
                    <button data-action="clear-selection" class="ml-2 text-slate-400 hover:text-white">&times;</button>
                </div>
            </div>
        </main>
    </div>

    <!-- Overlays and Modals -->
    <div id="modal-container" class="fixed inset-0 bg-black bg-opacity-50 z-40 overflow-y-auto hidden"></div>

    <div id="loading-overlay" class="fixed inset-0 bg-white bg-opacity-75 flex items-center justify-center hidden">
        <div class="spinner"></div>
    </div>

    <div id="toast" class="toast"></div>

    <!-- Cropper Modal -->
    <div id="cropper-modal"
        class="fixed inset-0 bg-black bg-opacity-70 flex flex-col items-center justify-center z-50 p-4">
        <div class="bg-white rounded-lg p-4 w-full max-w-2xl">
            <h3 class="text-lg font-bold mb-4">Crop & Rotate Image</h3>
            <div class="img-container">
                <img id="image-to-crop" src="" alt="Image to crop">
            </div>
            <div class="flex justify-center gap-4 mt-4">
                <button data-action="rotate-left" class="p-2 bg-slate-200 rounded-lg"><i
                        data-lucide="rotate-ccw"></i></button>
                <button data-action="rotate-right" class="p-2 bg-slate-200 rounded-lg"><i
                        data-lucide="rotate-cw"></i></button>
            </div>
            <div class="flex justify-end space-x-3 mt-4">
                <button data-action="cancel-crop"
                    class="bg-slate-200 text-slate-800 px-4 py-2 rounded-lg">Cancel</button>
                <button data-action="crop-image" class="btn-primary text-white px-4 py-2 rounded-lg">Apply Crop</button>
            </div>
        </div>
    </div>

    <!-- Camera Modal -->
    <div id="camera-modal-fixed"
        class="fixed inset-0 bg-black bg-opacity-80 z-[9999] flex items-center justify-center p-4 hidden">
        <div class="bg-white rounded-xl shadow-2xl w-full max-w-lg overflow-hidden flex flex-col">
            <div class="px-5 py-4 border-b">
                <h3 class="font-bold text-lg text-slate-800">Live Camera</h3>
            </div>
            <div
                class="relative bg-black w-full h-[60vh] md:h-[500px] flex items-center justify-center overflow-hidden">
                <video id="camera-stream" autoplay playsinline class="w-full h-full object-cover"></video>
                <canvas id="camera-canvas" class="hidden"></canvas>
            </div>
            <div class="px-5 py-4 border-t bg-slate-50 flex justify-end gap-3">
                <button data-action="close-camera"
                    class="px-4 py-2 rounded-lg text-slate-600 font-medium hover:bg-slate-200 transition">Cancel</button>
                <button data-action="capture-photo"
                    class="px-4 py-2 rounded-lg bg-teal-600 text-white font-medium hover:bg-teal-700 shadow-md transition">Capture</button>
            </div>
        </div>
    </div>

    <!-- QR Scanner Modal -->
    <div id="qr-scanner-modal-fixed"
        class="fixed inset-0 bg-black bg-opacity-80 z-[9999] flex items-center justify-center p-4 hidden">
        <div class="bg-white rounded-xl shadow-2xl w-full max-w-lg overflow-hidden flex flex-col">
            <div class="px-5 py-4 border-b flex justify-between items-center">
                <h3 class="font-bold text-lg text-slate-800">Plot Scanner</h3>
            </div>
            <div class="relative bg-black w-full aspect-square flex items-center justify-center overflow-hidden">
                <video id="qr-video" autoplay playsinline class="w-full h-full object-cover"></video>
                <!-- Scanner Lines Overlay -->
                <div class="scanner-frame z-10 pointer-events-none">
                    <div class="scanner-line"></div>
                </div>
                <div class="absolute top-4 w-full text-center text-white px-6 z-10 drop-shadow-md pointer-events-none">
                    <p class="text-sm bg-black/50 px-3 py-1 rounded-full inline-block backdrop-blur-sm">Point at plot QR
                        code</p>
                </div>
            </div>
            <div class="px-5 py-4 border-t bg-slate-50 flex justify-end gap-3">
                <button data-action="close-qr-scanner"
                    class="px-4 py-2 rounded-lg text-slate-600 font-medium hover:bg-slate-200 transition">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Sidebar toggle script for mobile -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const menuToggle = document.getElementById('menu-toggle');
            const sidebar = document.getElementById('sidebar');

            if (menuToggle && sidebar) {
                // Toggle sidebar on mobile
                menuToggle.addEventListener('click', () => {
                    sidebar.classList.toggle('open');
                });

                // Close sidebar when a navigation link is clicked on mobile
                sidebar.addEventListener('click', (e) => {
                    if (window.innerWidth < 768 && e.target.closest('a[data-page]')) {
                        sidebar.classList.remove('open');
                    }
                });

                // Close sidebar when clicking on the main content area on mobile
                document.querySelector('main').addEventListener('click', () => {
                    if (window.innerWidth < 768 && sidebar.classList.contains('open')) {
                        sidebar.classList.remove('open');
                    }
                });
            }
        });
    </script>

    <!-- MAIN APPLICATION LOGIC -->
    <script type="module">
        import { GoogleGenAI, Type } from "@google/genai";

        document.addEventListener('DOMContentLoaded', () => {
            // --- STATE MANAGEMENT ---
            let state = {
                currentPage: 'dashboard',
                ingredients: [],
                formulations: [],
                trials: [],
                organisations: [],
                selectedTrials: [],
                photoQueue: [],
                croppedPhotosData: [],
                currentTrialIdForCamera: null,
                cameraMode: 'general',
                aiChatHistory: [],
                aiAttachedImage: { fileData: null, mimeType: null },
                settings: {
                    apiKeys: [],
                    currentApiKeyIndex: 0,
                    scriptUrl: '',
                    sheetId: '',
                    folderId: '',
                    autoAnalyzePhotos: false,
                    qrCodeFields: { FormulationName: true, InvestigatorName: true, Date: true, Dosage: true, Location: false, Result: false, WeedSpecies: false, Weather: false },
                    qrOnlineFields: { showInvestigator: true, showDate: true, showLocation: true, showDosage: true, showWeedSpecies: true, showResult: true, showWeather: true, showIngredients: false, showConclusion: true, showPhotos: true }
                },
                charts: {},
                efficacyDataForModal: [],
                bulkAnalysisState: {
                    isRunning: false,
                    isPaused: false,
                    lastProcessedIndex: -1,
                    trialsToProcess: [],
                    totalToProcess: 0
                },
                backgroundQueue: new Map(),
                syncQueue: [], // New robust background sync queue
                aiQueue: [],
                isAiQueueRunning: false,
                // New state for persistent filters
                filterState: {
                    search: '',
                    formulationText: '', // New specific text filter
                    formulation: '',
                    startDate: '',
                    endDate: '',
                    sortBy: 'date'
                }
            };

            // --- DOM ELEMENTS ---
            const mainContent = document.getElementById('main-content');
            const modalContainer = document.getElementById('modal-container');
            const loadingOverlay = document.getElementById('loading-overlay');
            const toast = document.getElementById('toast');
            const cropperModal = document.getElementById('cropper-modal');
            const imageToCrop = document.getElementById('image-to-crop');
            const cameraModal = document.getElementById('camera-modal-fixed');
            const videoElement = document.getElementById('camera-stream');
            const canvasElement = document.getElementById('camera-canvas');
            const qrScannerModal = document.getElementById('qr-scanner-modal-fixed');
            const qrVideo = document.getElementById('qr-video');
            let cropper = null;
            let cameraStream = null;
            let qrStream = null;
            let qrAnimationFrame = null;

            // --- CONFIGURATION ---
            // ⚠️ IMPORTANT: These values must be configured in Settings before first use!
            // Your credentials will be saved in browser localStorage (stored locally on your device only)
            const DEFAULT_SCRIPT_URL = '';
            const DEFAULT_SHEET_ID = '';
            const DEFAULT_FOLDER_ID = '';
            const CURRENCY_SYMBOL = '₹';

            // --- GEMINI AI SETUP ---
            function getActiveApiKey() {
                if (!state.settings.apiKeys || state.settings.apiKeys.length === 0) {
                    return null;
                }
                const key = state.settings.apiKeys[state.settings.currentApiKeyIndex];
                return key || null;
            }

            function getGenAIClient() {
                const activeKey = getActiveApiKey();
                if (!activeKey) {
                    showToast('Gemini API key is not set. Please configure it in Settings.', 'error');
                    switchPage('settings');
                    return null;
                }
                return new GoogleGenAI({ apiKey: activeKey });
            }

            async function testApiKey() {
                showToast('Testing API key...', 'info');

                // First, get the key from the input field (in case it hasn't been saved yet)
                const keyInputs = document.querySelectorAll('.api-key-input');
                let testKey = null;

                for (const input of keyInputs) {
                    if (input.value.trim()) {
                        testKey = input.value.trim();
                        break;
                    }
                }

                if (!testKey) {
                    testKey = getActiveApiKey();
                }

                if (!testKey) {
                    showToast('No API key to test. Please enter an API key first.', 'error');
                    return;
                }

                try {
                    // Check for input in DOM first (for testing before save)
                    const modelInput = document.getElementById('settings-api-model');
                    const modelId = modelInput ? modelInput.value : (state.settings.apiModel || 'gemini-2.5-flash-lite');

                    showToast(`Testing ${modelId}...`, 'info');
                    const genAI = new GoogleGenAI({ apiKey: testKey });

                    // Make a simple test call
                    const response = await genAI.models.generateContent({
                        model: modelId,
                        contents: [{ parts: [{ text: 'Say "API key is working!" in exactly those words.' }] }]
                    });

                    if (response && response.text) {
                        showToast('✅ API key is valid and working!', 'success');
                        console.log('API Test Response:', response.text);
                    } else {
                        showToast('⚠️ API responded but with unexpected format.', 'error');
                    }
                } catch (error) {
                    console.error('API Key Test Error:', error);
                    const errorMsg = (error.message || '').toLowerCase();

                    if (errorMsg.includes('api key not valid') || errorMsg.includes('invalid')) {
                        showToast('❌ API key is INVALID. Please check your key.', 'error');
                    } else if (errorMsg.includes('quota') || errorMsg.includes('429') || errorMsg.includes('resource exhausted')) {
                        showToast('⚠️ API key is valid but QUOTA EXHAUSTED. Wait or use different account.', 'error');
                    } else if (errorMsg.includes('permission') || errorMsg.includes('403')) {
                        showToast('❌ API key lacks permissions. Enable Generative Language API in Google Cloud.', 'error');
                    } else {
                        showToast(`❌ API Error: ${error.message}`, 'error');
                    }
                }
            }

            function rotateApiKey() {
                const keyCount = state.settings.apiKeys.length;
                if (keyCount <= 1) return false; // Cannot rotate if 0 or 1 keys

                const newIndex = (state.settings.currentApiKeyIndex + 1) % keyCount;
                state.settings.currentApiKeyIndex = newIndex;
                localStorage.setItem('appSettings', JSON.stringify(state.settings));
                showToast(`API quota likely exceeded. Trying next key (${newIndex + 1}/${keyCount})...`, 'info');

                return true;
            }

            async function _callGeminiApiWithRetries(apiCallFunction, retries = 0) {
                const maxRetries = state.settings.apiKeys.length || 1;
                if (retries >= maxRetries) {
                    throw new Error('ALL_KEYS_EXHAUSTED');
                }

                try {
                    const genAI = getGenAIClient();
                    if (!genAI) {
                        throw new Error("No valid API key found. Please add one in Settings.");
                    }
                    return await apiCallFunction(genAI);
                } catch (error) {
                    const errorMessage = (error.message || '').toLowerCase();
                    console.error('Gemini API Error:', error.message, 'Full error:', error);

                    // Check for specific error types
                    if (errorMessage.includes('api key not valid') || errorMessage.includes('invalid api key')) {
                        showToast('API key is invalid. Please check your key in Settings.', 'error');
                        throw new Error('INVALID_API_KEY: Your Gemini API key is not valid. Generate a new one at ai.google.dev');
                    }

                    if (errorMessage.includes('quota') || errorMessage.includes('resource exhausted') || errorMessage.includes('429')) {
                        console.warn(`Quota error with key index ${state.settings.currentApiKeyIndex}. Attempting rotation.`);
                        if (rotateApiKey()) {
                            await new Promise(resolve => setTimeout(resolve, 500));
                            return _callGeminiApiWithRetries(apiCallFunction, retries + 1);
                        } else {
                            // Only 1 key and it's exhausted
                            throw new Error('QUOTA_EXCEEDED: API quota exhausted. Wait a few minutes or add another API key from a different Google account.');
                        }
                    }

                    if (errorMessage.includes('permission denied') || errorMessage.includes('403')) {
                        throw new Error('API_PERMISSION_DENIED: The API key does not have permission for this operation. Enable the Generative Language API in Google Cloud Console.');
                    }

                    if (errorMessage.includes('network') || errorMessage.includes('fetch')) {
                        throw new Error('NETWORK_ERROR: Cannot connect to Gemini API. Check your internet connection.');
                    }

                    // Handle 503 - Model overloaded (temporary error, retry after delay)
                    if (errorMessage.includes('503') || errorMessage.includes('overloaded') || errorMessage.includes('unavailable')) {
                        const retryDelay = 10000 + (retries * 5000); // 10s, 15s, 20s...
                        console.warn(`Model overloaded (503). Retrying in ${retryDelay / 1000}s... (attempt ${retries + 1})`);
                        showToast(`Server busy. Retrying in ${retryDelay / 1000} seconds...`, 'info');
                        await new Promise(resolve => setTimeout(resolve, retryDelay));
                        return _callGeminiApiWithRetries(apiCallFunction, retries + 1);
                    }

                    // For any other error, just throw it with more context
                    throw new Error(`API_ERROR: ${error.message}`);
                }
            }

            // Rate limiter: Track API call timestamps to enforce 15 RPM limit
            const apiCallTimestamps = [];
            const MAX_REQUESTS_PER_MINUTE = 15;
            const MIN_DELAY_MS = 4000; // 4 seconds = max 15 requests/minute

            function getRateLimitDelay() {
                const now = Date.now();
                // Remove timestamps older than 1 minute
                while (apiCallTimestamps.length > 0 && now - apiCallTimestamps[0] > 60000) {
                    apiCallTimestamps.shift();
                }

                // If we've made fewer than MAX requests in the last minute, calculate delay
                if (apiCallTimestamps.length >= MAX_REQUESTS_PER_MINUTE) {
                    // Wait until the oldest request expires from the window
                    const oldestTimestamp = apiCallTimestamps[0];
                    const waitTime = 60000 - (now - oldestTimestamp) + 100; // +100ms buffer
                    return Math.max(waitTime, MIN_DELAY_MS);
                }

                // Ensure minimum delay between requests
                if (apiCallTimestamps.length > 0) {
                    const lastCall = apiCallTimestamps[apiCallTimestamps.length - 1];
                    const timeSinceLastCall = now - lastCall;
                    if (timeSinceLastCall < MIN_DELAY_MS) {
                        return MIN_DELAY_MS - timeSinceLastCall;
                    }
                }

                return 0; // No delay needed
            }

            async function processAiQueue() {
                if (state.isAiQueueRunning) return;
                state.isAiQueueRunning = true;

                while (state.aiQueue.length > 0) {
                    // Check rate limit before making request
                    const delay = getRateLimitDelay();
                    if (delay > 0) {
                        console.log(`Rate limiter: waiting ${(delay / 1000).toFixed(1)}s before next API call (${apiCallTimestamps.length}/${MAX_REQUESTS_PER_MINUTE} RPM)`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }

                    const task = state.aiQueue[0];
                    try {
                        // Record this API call timestamp BEFORE the call
                        apiCallTimestamps.push(Date.now());

                        const result = await _callGeminiApiWithRetries(task.apiCallFunction);
                        task.resolve(result);
                    } catch (error) {
                        showToast(`Error in '${task.description}': ${error.message}`, 'error');
                        task.reject(error);
                    }
                    state.aiQueue.shift();
                }
                state.isAiQueueRunning = false;
            }

            function callGeminiApi(description, apiCallFunction) {
                return new Promise((resolve, reject) => {
                    state.aiQueue.push({ description, apiCallFunction, resolve, reject });
                    processAiQueue();
                });
            }

            // --- UTILITY FUNCTIONS ---
            function safeJsonParse(jsonString, defaultValue = []) {
                if (!jsonString || typeof jsonString !== 'string') return defaultValue;
                try {
                    const parsed = JSON.parse(jsonString);
                    return (typeof parsed === 'string') ? JSON.parse(parsed) : parsed;
                } catch (e) {
                    console.warn('JSON Parse Error:', e, 'Input:', jsonString);
                    return defaultValue;
                }
            }

            /**
             * Safely stringify objects, avoiding circular references and non-serializable values.
             * Automatically excludes Chart.js instances, Functions, DOM elements, and other problematic objects.
             * @param {*} obj - The object to stringify
             * @param {number} space - JSON formatting spaces (default: 0)
             * @returns {string} - Safe JSON string
             */
            function safeStringify(obj, space = 0) {
                const seen = new WeakSet();
                return JSON.stringify(obj, (key, value) => {
                    // Exclude known problematic keys
                    if (key === 'charts' || key === 'backgroundQueue') {
                        return undefined; // Don't serialize Chart.js instances or Map objects
                    }

                    // Skip functions
                    if (typeof value === 'function') {
                        return undefined;
                    }

                    // Skip DOM elements
                    if (value instanceof Element || value instanceof HTMLElement) {
                        return undefined;
                    }

                    // Handle circular references
                    if (typeof value === 'object' && value !== null) {
                        if (seen.has(value)) {
                            return undefined; // Skip circular reference
                        }
                        seen.add(value);
                    }

                    return value;
                }, space);
            }


            function sanitizeHTML(str) {
                if (typeof str !== 'string') return str;
                const temp = document.createElement('div');
                temp.textContent = str;
                return temp.innerHTML;
            }

            // --- TEMPLATES ---
            const templates = {
                page: (pageId) => ({
                    dashboard: `
                        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-6">
                            <div class="dashboard-card bg-white p-6 rounded-xl shadow-lg flex items-center gap-4"><div class="bg-teal-100 p-3 rounded-full"><i data-lucide="list-checks" class="text-teal-600"></i></div><div><p class="text-sm text-slate-500">Total Trials</p><p id="total-trials" class="text-2xl font-bold text-slate-800">0</p></div></div>
                            <div class="dashboard-card bg-white p-6 rounded-xl shadow-lg flex items-center gap-4" style="animation-delay: 0.1s;"><div class="bg-amber-100 p-3 rounded-full"><i data-lucide="loader-2" class="text-amber-600"></i></div><div><p class="text-sm text-slate-500">Active Trials</p><p id="active-trials" class="text-2xl font-bold text-slate-800">0</p></div></div>
                            <div class="dashboard-card bg-white p-6 rounded-xl shadow-lg flex items-center gap-4" style="animation-delay: 0.2s;"><div class="bg-green-100 p-3 rounded-full"><i data-lucide="check-circle-2" class="text-green-600"></i></div><div><p class="text-sm text-slate-500">Completed Trials</p><p id="completed-trials" class="text-2xl font-bold text-slate-800">0</p></div></div>
                        </div>
                        <div class="grid grid-cols-1 lg:grid-cols-5 gap-6">
                            <div class="lg:col-span-3 dashboard-card bg-white p-6 rounded-xl shadow-lg" style="animation-delay: 0.3s;"><h3 class="font-semibold text-slate-800 mb-4">Trials Over Time</h3><div class="h-80"><canvas id="trials-over-time-chart"></canvas></div></div>
                            <div class="lg:col-span-2 dashboard-card bg-white p-6 rounded-xl shadow-lg flex flex-col" style="animation-delay: 0.4s;"><h3 class="font-semibold text-slate-800 mb-4">Results Breakdown</h3><div class="h-80 flex items-center justify-center"><canvas id="results-breakdown-chart"></canvas></div></div>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mt-6">
                            <div class="dashboard-card bg-white p-6 rounded-xl shadow-lg" style="animation-delay: 0.5s;"><h3 class="font-semibold text-slate-800 mb-4 flex items-center gap-2"><i data-lucide="award" class="text-teal-600"></i> Top 10 Highest Control Days</h3><ul id="top-control-days-list" class="space-y-3 text-sm"></ul></div>
                            <div class="dashboard-card bg-white p-6 rounded-xl shadow-lg" style="animation-delay: 0.6s;"><h3 class="font-semibold text-slate-800 mb-4">Average Weather Conditions</h3><div id="avg-weather-conditions" class="grid grid-cols-2 gap-y-4 gap-x-2 text-left mt-4"></div></div>
                        </div>
                    `,
                    formulations: `<div class="flex flex-col md:flex-row justify-between items-center mb-6 gap-4"><div class="flex-grow"><input type="search" data-action="filter" data-type="formulation" placeholder="Search formulations by name..." class="w-full form-input px-4 py-2 border rounded-lg"></div><div><button data-action="openModal" data-type="formulation" class="btn-primary text-white px-4 py-2 rounded-lg shadow w-full md:w-auto flex items-center gap-2"><i data-lucide="plus"></i> New Formulation</button></div></div><div id="formulations-list" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6"></div>`,
                    trials: `<div class="bg-white p-4 rounded-lg shadow-md mb-6"><div class="flex justify-between items-center"><h3 class="font-semibold text-gray-800 mb-2">Filters & Sorting</h3><div class="flex gap-2"><button data-action="reset-filters" class="text-sm bg-red-100 text-red-700 px-3 py-1 rounded-md hover:bg-red-200">Reset Filters</button><button data-action="sort-trials" data-sort="date" class="text-sm bg-gray-200 px-3 py-1 rounded-md">Sort by Date</button><button data-action="sort-trials" data-sort="result" class="text-sm bg-gray-200 px-3 py-1 rounded-md">Sort by Result</button></div></div><div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mt-4"><input type="search" data-action="filter" data-type="trial-search" placeholder="General search (Investigator, Species)..." class="w-full px-4 py-2 border rounded-lg form-input"><input type="text" data-action="filter" data-type="trial-formulation-text" placeholder="Search by Formulation Name..." class="w-full px-4 py-2 border rounded-lg form-input bg-teal-50/50 border-teal-200"><select data-action="filter" data-type="trial-formulation" class="p-2 border rounded-lg bg-white form-input"><option value="">Filter by Formulation (List)</option></select><div class="grid grid-cols-2 gap-2"><input type="date" data-action="filter" data-type="trial-start-date" class="p-2 border rounded-lg form-input" title="Start Date"><input type="date" data-action="filter" data-type="trial-end-date" class="p-2 border rounded-lg form-input" title="End Date"></div></div></div><div class="flex justify-between items-center mb-6"><button data-action="openModal" data-type="trial" class="btn-primary text-white px-4 py-2 rounded-lg shadow w-full sm:w-auto flex items-center gap-2"><i data-lucide="plus"></i> Log New Trial</button></div><div id="trials-list" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 items-stretch"></div>`,
                    compareTrials: `
                        <div class="flex flex-col h-full gap-6 pb-10">
                            <div class="bg-white p-4 rounded-lg shadow-md flex-shrink-0 flex justify-between items-center">
                                <h2 class="text-xl font-semibold text-gray-700">Comparative Analysis</h2>
                                <button data-action="export-professional-report" class="bg-teal-600 text-white px-4 py-2 rounded-lg text-sm flex items-center gap-2"><i data-lucide="file-text"></i> Export Report</button>
                            </div>
                            
                            <div id="compare-selection-warning" class="hidden flex-col items-center justify-center bg-white p-10 rounded-lg shadow-md text-center">
                                <div class="bg-amber-100 p-4 rounded-full mb-4"><i data-lucide="alert-circle" class="h-10 w-10 text-amber-600"></i></div>
                                <h3 class="text-lg font-bold text-gray-800">No Trials Selected</h3>
                                <p class="text-gray-600 max-w-md mt-2">Please go to the <strong>Trials</strong> page and select (checkbox) at least two trials to compare.</p>
                                <button onclick="switchPage('trials')" class="mt-6 btn-primary text-white px-6 py-2 rounded-lg">Go to Trials</button>
                            </div>

                            <div id="compare-content" class="flex-grow flex flex-col gap-6 overflow-y-auto">
                                <!-- Top Section: Charts & Controls -->
                                <div class="flex flex-col lg:flex-row gap-6">
                                    <!-- Controls Sidebar -->
                                    <div class="w-full lg:w-1/4 bg-white p-4 rounded-lg shadow-md space-y-6">
                                        <div>
                                            <h3 class="font-semibold text-slate-800 mb-3 border-b pb-2">Selected Trials</h3>
                                            <ul id="compare-selected-list" class="space-y-2 text-sm text-gray-600 max-h-48 overflow-y-auto"></ul>
                                        </div>
                                        
                                        <div>
                                            <h3 class="font-semibold text-slate-800 mb-3 border-b pb-2">Chart Settings</h3>
                                            <div class="space-y-4">
                                                <div>
                                                    <label class="block text-xs font-medium text-gray-600 mb-1">Weed Species</label>
                                                    <select id="compare-weed-filter" class="form-input w-full p-2 border rounded-md"></select>
                                                </div>
                                                <div>
                                                    <label class="block text-xs font-medium text-gray-600 mb-1">Metric</label>
                                                    <select id="compare-metric-filter" class="form-input w-full p-2 border rounded-md">
                                                        <option value="cover">% Cover</option>
                                                        <option value="phyto">% Phytotoxicity</option>
                                                    </select>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    <!-- Chart Area -->
                                    <div class="w-full lg:w-3/4 bg-white rounded-lg shadow-md p-4 flex flex-col min-h-[400px]">
                                        <h3 id="compare-chart-title" class="text-lg font-bold text-slate-800 mb-4 text-center">Comparison Chart</h3>
                                        <div class="flex-grow w-full relative">
                                            <canvas id="compare-chart"></canvas>
                                        </div>
                                    </div>
                                </div>

                                <!-- Bottom Section: Detailed Table -->
                                <div class="bg-white rounded-lg shadow-md p-6 overflow-x-auto">
                                    <h3 class="text-lg font-bold text-slate-800 mb-4">Detailed Side-by-Side Comparison</h3>
                                    <div id="compare-table-container"></div>
                                </div>
                            </div>
                        </div>
                    `,
                    organisations: `<div class="flex justify-between items-center mb-6"><div><p class="text-sm text-gray-500">Group trials together for easier analysis.</p></div></div><div id="organisations-list" class="space-y-8"></div>`,
                    ingredients: `<div class="bg-white p-6 rounded-lg shadow mb-8"><h3 class="text-lg font-medium text-gray-800">Bulk Add Ingredients</h3><p class="text-sm text-gray-500 mb-2">Enter multiple ingredients in the format: Name Cost Unit, ... (e.g., Glyphosate 15000 L, Paraquat 8000 kg)</p><div class="flex gap-2"><textarea id="bulk-ingredients-cost-input" placeholder="IngredientA 100 kg, IngredientB 50 L" class="w-full p-2 border border-gray-300 rounded-md form-input" rows="4"></textarea><button type="button" data-action="apply-bulk-add-cost" class="bg-indigo-600 text-white px-4 py-2 rounded-lg self-start">Add Bulk</button></div></div><div class="flex justify-end items-center mb-6"><button data-action="openModal" data-type="ingredient" class="btn-primary text-white px-4 py-2 rounded-lg shadow flex items-center gap-2"><i data-lucide="plus"></i> Add New Cost</button></div><div id="ingredients-list" class="bg-white p-6 rounded-lg shadow"></div>`,
                    aiAssistant: `<div class="bg-white p-6 rounded-lg shadow">
                                        <div class="flex justify-between items-center mb-4"><h2 class="text-xl font-semibold text-gray-700">AI Assistant</h2><button data-action="clear-chat" class="text-sm bg-gray-200 px-3 py-1 rounded-md hover:bg-gray-300">Clear History</button></div>
                                        <div id="ai-chat-box" class="border rounded-lg p-4 overflow-y-auto mb-4 bg-gray-50 flex flex-col gap-2 h-96"></div>
                                        <div id="ai-image-preview-container" class="relative hidden w-20 mb-2"><img id="ai-image-preview" class="h-20 w-20 object-cover rounded-md border"><button data-action="remove-ai-image" class="absolute -top-2 -right-2 bg-red-500 text-white rounded-full h-5 w-5 flex items-center justify-center text-xs font-bold">&times;</button></div>
                                        <form id="ai-form" class="flex gap-4"><input type="file" id="ai-image-input" class="hidden" accept="image/*"><button type="button" data-action="attach-ai-image" class="p-2 border rounded-lg bg-gray-100 hover:bg-gray-200"><i data-lucide="paperclip" class="h-5 w-5 text-gray-600"></i></button><input type="text" id="ai-input" placeholder="Ask about your data, or attach an image..." class="flex-grow p-2 border rounded-lg form-input" required><button type="submit" class="btn-primary text-white px-5 py-2 rounded-lg flex items-center gap-2">Send <i data-lucide="send" class="h-4 w-4"></i></button></form>
                                </div>`,
                    dataMgmt: `<div class="space-y-8">
                                    <div><h2 class="text-xl font-semibold text-gray-700 mb-4">Export Data</h2><div class="bg-white p-6 rounded-lg shadow"><p class="text-gray-600 mb-4">Download your data for backup. ZIP includes photos, while Standalone HTML is a complete, viewable offline archive of the app.</p><div class="flex flex-wrap gap-4"><button data-action="export-json" class="bg-green-600 text-white px-4 py-2 rounded-lg">Export to JSON</button><button data-action="export-zip" class="bg-green-700 text-white px-4 py-2 rounded-lg">Export with Photos (ZIP)</button><button data-action="export-standalone" class="bg-blue-700 text-white px-4 py-2 rounded-lg">Export Standalone HTML</button></div></div></div>
                                    <div>
                                        <h2 class="text-xl font-semibold text-gray-700 mb-4">AI Analysis</h2>
                                        <div class="bg-white p-6 rounded-lg shadow">
                                            <p class="text-gray-600 mb-4">Intelligently generate AI summaries and efficacy data only for trials that need it. This saves time and API credits by skipping trials that are already up-to-date.</p>
                                            <div class="flex items-center gap-4">
                                                <div id="bulk-analysis-controls"></div>
                                                <div id="summary-progress" class="text-sm text-gray-600"></div>
                                            </div>
                                        </div>
                                    </div>
                                    <div><h2 class="text-xl font-semibold text-gray-700 mb-4">Import Data</h2><div class="bg-white p-6 rounded-lg shadow"><p class="text-gray-600 mb-4">Upload a previously exported JSON or ZIP file to restore your data. <strong class="text-red-600">This will overwrite all current data.</strong></p><input type="file" id="import-file-input" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100" accept=".json,.zip"><button data-action="import-data" class="mt-4 bg-blue-600 text-white px-4 py-2 rounded-lg" disabled>Import Data</button></div></div>
                                    <div><h2 class="text-xl font-semibold text-gray-700 mb-4">Clear All Data</h2><div class="bg-white p-6 rounded-lg shadow border-red-300"><p class="text-gray-600 mb-4">Permanently delete all your data. <strong class="text-red-600">This action cannot be undone.</strong></p><button data-action="clear-data" class="bg-red-600 text-white px-4 py-2 rounded-lg">Clear All Data</button></div></div>
                            </div>`,
                    settings: `
                        <div class="bg-white p-6 rounded-lg shadow space-y-8">
                            <form id="settings-form" class="space-y-8">
                                <div>
                                    <h2 class="text-xl font-semibold text-gray-700 mb-4">AI Integration (Gemini)</h2>
                                    <p class="mt-1 text-sm text-gray-600">Add one or more Google Gemini API keys. The app will automatically rotate to the next key if one exceeds its free quota.</p>
                                    
                                    <!-- API Model Selection -->
                                    <div class="mb-4 mt-4">
                                        <label class="block text-gray-700 text-sm font-bold mb-2" for="settings-api-model">
                                            Gemini API Model
                                        </label>
                                        <select id="settings-api-model" class="w-full border rounded-md shadow-sm p-2 bg-white text-sm">
                                            <!-- Recommended -->
                                            <optgroup label="Recommended (High Free Quota)">
                                                <option value="gemini-2.5-flash-lite">Gemini 2.5 Flash-Lite (1k RPD - Best)</option>
                                                <option value="gemini-2.0-flash-lite">Gemini 2.0 Flash-Lite (1k RPD - Legacy)</option>
                                            </optgroup>

                                            <!-- 3.0 Series (Newest) -->
                                            <optgroup label="Gemini 3.0 (Preview)">
                                                <option value="gemini-3-flash-preview">Gemini 3.0 Flash Preview</option>
                                                <option value="gemini-3-pro-preview">Gemini 3.0 Pro Preview</option>
                                            </optgroup>

                                            <!-- 2.5 Series -->
                                            <optgroup label="Gemini 2.5">
                                                <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
                                                <option value="gemini-2.5-pro">Gemini 2.5 Pro</option>
                                            </optgroup>

                                            <!-- 2.0 Series -->
                                            <optgroup label="Gemini 2.0">
                                                <option value="gemini-2.0-flash">Gemini 2.0 Flash</option>
                                                <option value="gemini-2.0-pro-exp-02-05">Gemini 2.0 Pro Experimental</option>
                                            </optgroup>

                                            <!-- Legacy / Fallback -->
                                            <optgroup label="Legacy / Standard">
                                                <option value="gemini-1.5-flash">Gemini 1.5 Flash</option>
                                                <option value="gemini-1.5-pro">Gemini 1.5 Pro</option>
                                                <option value="gemini-pro">Gemini 1.0 Pro</option>
                                            </optgroup>
                                        </select>
                                        <p class="text-xs text-gray-500 mt-1">Select <b>2.5 Flash-Lite</b> for best free limits. Change if needed.</p>
                                    </div>
                                    <div id="api-keys-container" class="mt-4 space-y-3">
                                        <!-- API key inputs will be rendered here -->
                                    </div>
                                    <div class="flex items-center gap-3 mt-3">
                                        <button type="button" data-action="add-api-key" class="text-sm text-teal-600 hover:text-teal-800 font-semibold flex items-center gap-1"><i data-lucide="plus-circle" class="h-4 w-4"></i> Add Another API Key</button>
                                        <button type="button" data-action="test-api-key" class="text-sm bg-blue-100 text-blue-700 border border-blue-200 px-3 py-1 rounded-md hover:bg-blue-200 font-semibold flex items-center gap-1"><i data-lucide="zap" class="h-4 w-4"></i> Test API Key</button>
                                    </div>
                                    
                                    <div class="mt-6 p-4 bg-amber-50 border border-amber-200 rounded-lg">
                                        <h4 class="text-sm font-semibold text-amber-800 mb-2">API Quota Saver</h4>
                                        <div class="flex items-center gap-3">
                                            <input type="checkbox" id="auto-analyze-photos" name="autoAnalyzePhotos" class="h-5 w-5 rounded border-gray-300 text-teal-600 focus:ring-teal-500">
                                            <div>
                                                <label for="auto-analyze-photos" class="text-sm font-medium text-gray-800">Auto-Analyze Photos for Efficacy</label>
                                                <p class="text-xs text-gray-500">When enabled, each photo upload uses 1 API call. Disable to save quota (weed identification still works).</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <div class="border-t pt-8">
                                    <h3 class="text-lg font-medium text-gray-900">Report Customization</h3>
                                    <p class="mt-1 text-sm text-gray-600">Configure how your trial cards and reports look.</p>
                                    <div class="mt-4 grid grid-cols-1 md:grid-cols-2 gap-6">
                                        <div>
                                            <label class="block text-sm font-medium text-gray-700">Logo</label>
                                            <div class="mt-2 flex items-center gap-4">
                                                <img id="settings-logo-preview" class="h-12 w-auto object-contain border p-1 rounded" src="" alt="Logo">
                                                <input type="file" id="settings-logo-input" accept="image/*" class="text-sm">
                                                <input type="hidden" name="logoBase64" id="settings-logo-hidden">
                                                <button type="button" onclick="document.getElementById('settings-logo-hidden').value = ''; document.getElementById('settings-logo-preview').src = '';" class="text-red-500 text-sm">Clear</button>
                                            </div>
                                        </div>
                                        <div>
                                            <label class="block text-sm font-medium text-gray-700">Card Print Size</label>
                                            <select name="cardSize" id="settings-card-size" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 form-input bg-white">
                                                <option value="ID">ID Card (Compact)</option>
                                                <option value="A6">A6 (4 per page)</option>
                                                <option value="A4">A4 (2 per page)</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>

                                <div class="border-t pt-8">
                                    <h3 class="text-lg font-medium text-gray-900">Data Source Settings</h3>
                                    <p class="mt-1 text-sm text-gray-600">Ensure these URLs match your deployed Google Apps Script, Google Sheet, and Drive Photo Folder.</p>
                                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mt-4">
                                        <div>
                                            <label class="block text-sm font-medium text-gray-700">Script URL</label>
                                            <input type="url" id="script-url" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 form-input" placeholder="https://script.google.com/macros/s/...">
                                        </div>
                                        <div>
                                            <label class="block text-sm font-medium text-gray-700">Google Sheet URL</label>
                                            <input type="url" id="sheet-url" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 form-input" placeholder="https://docs.google.com/spreadsheets/d/...">
                                        </div>
                                        <div class="md:col-span-2">
                                            <label class="block text-sm font-medium text-gray-700">Drive Photo Folder URL</label>
                                            <input type="url" id="folder-url" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 form-input" placeholder="https://drive.google.com/drive/folders/...">
                                        </div>
                                    </div>
                                </div>

                                <div class="border-t pt-8">
                                    <h3 class="text-lg font-medium text-gray-900">QR Code Content (Offline Mode)</h3>
                                    <p class="mt-1 text-sm text-amber-700 bg-amber-50 p-2 rounded-md"><strong>Warning:</strong> For stability, please select only essential fields (4-5) for offline QR codes.</p>
                                    <div id="qr-settings-grid" class="mt-4 grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
                                        <!-- Will be populated by JS -->
                                    </div>
                                </div>

                                <div class="border-t pt-8">
                                    <h3 class="text-lg font-medium text-gray-900">Global QR Content (Online Mode)</h3>
                                    <p class="mt-1 text-sm text-gray-600">Default settings for what shows up when a QR code is scanned in online mode.</p>
                                    <div id="qr-online-settings-grid" class="mt-4 grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
                                        <!-- Will be populated by JS -->
                                    </div>
                                </div>

                                <div class="border-t pt-8 flex items-center justify-between">
                                    <button type="submit" class="btn-primary text-white px-4 py-2 rounded-lg">Save All Settings</button>
                                    <button type="button" data-action="reset-data-sources" class="text-sm text-gray-500 hover:text-gray-700">Reset to Default</button>
                                </div>
                            </form>
                            
                            <div class="border-t pt-8">
                                <h3 class="text-lg font-medium text-gray-900">Troubleshooting</h3>
                                <p class="mt-1 text-sm text-gray-600">If you are experiencing issues, clear the application cache and perform a hard reload.</p>
                                <div class="mt-4"><button data-action="force-reload" class="bg-red-600 text-white px-4 py-2 rounded-lg">Clear Cache & Reload App</button></div>
                            </div>
                        </div>
                    `,
                })[pageId] || '',
                modal: (modalId, isEdit = false, data = {}) => {
                    const modalTemplates = {
                        ingredient: `<div id="ingredient-modal" class="modal"><div class="modal-content bg-white p-8 rounded-lg shadow-xl w-full max-w-md mx-auto mt-20"><h3 class="text-lg font-bold mb-4 text-slate-800">${isEdit ? 'Edit' : 'Add'} Ingredient</h3><form id="ingredient-form"><input type="hidden" name="id"><div class="mb-4"><label class="block text-sm font-medium text-gray-700">Ingredient Name</label><input type="text" name="name" required class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm form-input"></div><div class="grid grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-700">Cost</label><input type="number" name="cost" step="0.01" required class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm form-input"></div><div><label class="block text-sm font-medium text-gray-700">Base Unit</label><select name="unit" required class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm bg-white form-input"><option value="L">L</option><option value="kg">kg</option><option value="ml">ml</option><option value="gm">gm</option></select></div></div><div class="mt-6 flex justify-end space-x-3"><button type="button" data-action="close-modal" class="bg-slate-200 text-slate-800 px-4 py-2 rounded-lg transition hover:bg-slate-300">Cancel</button><button type="submit" class="btn-primary text-white px-4 py-2 rounded-lg">Save</button></div></form></div></div>`,
                        formulation: `<div id="formulation-modal" class="modal"><div class="modal-content bg-white p-8 rounded-lg shadow-xl w-full max-w-2xl mx-auto mt-10"><h3 class="text-lg font-bold mb-4 text-slate-800">${isEdit ? 'Edit' : 'Add'} Formulation</h3><form id="formulation-form"><input type="hidden" name="id"><div class="grid grid-cols-1 md:grid-cols-2 gap-6"><input type="text" name="name" required placeholder="Formulation Name" class="p-2 border rounded-md form-input"><input type="text" name="notes" placeholder="Notes" class="p-2 border rounded-md form-input"></div><div class="mt-6"><h4 class="text-md font-medium text-gray-800">Bulk Add Ingredients</h4><p class="text-sm text-gray-500 mb-2">Enter ingredients in the format: Name QuantityUnit, ...</p><div class="flex gap-2"><textarea id="bulk-ingredients-input" placeholder="Pelargonic Acid 50ML, Capric Acid 20ML" class="w-full p-2 border rounded-md form-input" rows="3"></textarea><button type="button" data-action="apply-bulk-add" class="bg-indigo-600 text-white px-4 py-2 rounded-lg self-start">Add</button></div></div><div class="mt-6"><h4 class="text-md font-medium text-gray-800">Ingredients</h4><div id="formulation-ingredients-container" class="mt-2 space-y-3"></div><button type="button" data-action="add-ingredient-row" class="mt-3 text-sm text-teal-600 hover:text-teal-800 font-semibold flex items-center gap-1"><i data-lucide="plus-circle" class="h-4 w-4"></i> Add Ingredient</button></div><div class="mt-6 border-t pt-4"><p class="font-semibold text-slate-700">Total Cost: <span id="formulation-total-cost" class="text-teal-700">${CURRENCY_SYMBOL}0.00</span></p></div><div class="mt-6 flex justify-end space-x-3"><button type="button" data-action="close-modal" class="bg-slate-200 text-slate-800 px-4 py-2 rounded-lg transition hover:bg-slate-300">Cancel</button><button type="submit" class="btn-primary text-white px-4 py-2 rounded-lg">Save</button></div></form></div></div>`,
                        trial: `<div id="trial-modal" class="modal"><div class="modal-content bg-white p-8 rounded-lg shadow-xl w-full max-w-4xl mx-auto mt-10 h-[90vh] flex flex-col"><h3 class="text-lg font-bold mb-4 text-slate-800 flex-shrink-0">${isEdit ? 'Edit' : 'Log'} Trial</h3><form id="trial-form" class="flex-grow overflow-y-auto pr-4 -mr-4"><input type="hidden" name="id"><div class="grid grid-cols-1 md:grid-cols-2 gap-6"><input type="text" name="investigatorName" required placeholder="Investigator Name" class="p-2 border rounded-md form-input" list="investigator-list"><datalist id="investigator-list"></datalist><select name="formulationId" id="trial-formulation" required class="p-2 border rounded-md bg-white form-input"></select><div class="grid grid-cols-2 gap-2"><input type="text" name="dosage" placeholder="Dosage (mL/ha)" class="p-2 border rounded-md form-input"><input type="number" name="replication" placeholder="Replication #" class="p-2 border rounded-md form-input"></div><input type="text" name="weedSpecies" placeholder="Weed Species (comma-separated)" class="p-2 border rounded-md form-input"><input type="date" name="date" id="trial-date" required class="p-2 border rounded-md form-input"><select name="result" class="p-2 border rounded-md bg-white form-input"><option value="">Select Result</option><option value="Excellent">Excellent</option><option value="Good">Good</option><option value="Fair">Fair</option><option value="Poor">Poor</option></select></div>
                            <div class="md:col-span-2 mt-6 p-4 bg-slate-50 rounded-lg">
                                <h4 class="text-md font-medium text-gray-800 mb-2">Location & Weather on Trial Date</h4>
                                <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                                    <div class="md:col-span-2 flex items-center gap-2">
                                        <input type="text" name="location" placeholder="Location Name or Lat,Lon" class="p-2 border rounded-md w-full form-input">
                                        <button type="button" data-action="get-location" class="bg-slate-200 p-2 rounded-lg text-sm flex-shrink-0" title="Get Current Location"><i data-lucide="map-pin"></i></button>
                                    </div>
                                    <button type="button" data-action="fetch-trial-weather" class="btn-primary text-white px-4 py-2 rounded-lg text-sm w-full">Fetch Weather</button>
                                </div>
                                <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mt-4">
                                    <input type="text" name="temperature" placeholder="Temp (°C)" class="p-2 border rounded-md text-sm form-input">
                                    <input type="text" name="humidity" placeholder="Humidity (%)" class="p-2 border rounded-md text-sm form-input">
                                    <input type="text" name="windspeed" placeholder="Wind (km/h)" class="p-2 border rounded-md text-sm form-input">
                                    <input type="text" name="rain" placeholder="Rain (mm)" class="p-2 border rounded-md text-sm form-input">
                                </div>
                            </div>
                            <div class="md:col-span-2 p-4 bg-slate-50 rounded-lg space-y-3 mt-6">
                                <div class="flex items-center gap-2"><input type="checkbox" id="is-completed" name="isCompleted" class="h-4 w-4 rounded border-gray-300 text-teal-600 focus:ring-teal-500"><label for="is-completed" class="text-sm font-medium text-gray-800">Mark trial as Completed</label></div>
                                <div class="flex items-center gap-2"><input type="checkbox" id="control-finalized" name="controlFinalized" class="h-4 w-4 rounded border-gray-300 text-teal-600 focus:ring-teal-500"><label for="control-finalized" class="text-sm font-medium text-gray-800">Stop counting control days</label></div>
                                <div id="finalization-details" class="grid grid-cols-2 gap-4 hidden"><div><label for="finalization-date" class="block text-xs font-medium text-gray-600">Finalization Date</label><input type="date" name="finalizationDate" id="finalization-date" class="p-2 border rounded-md text-sm form-input w-full bg-slate-100"></div><div><label for="final-control-duration" class="block text-xs font-medium text-gray-600">Final Control Days</label><input type="number" name="finalControlDuration" id="final-control-duration" placeholder="Days" class="p-2 border rounded-md text-sm form-input w-full"></div></div>
                            </div>
                            <div class="mt-6 p-4 bg-slate-50 rounded-lg"><h4 class="text-md font-medium text-gray-800">Efficacy & Phyto Observations</h4><div id="efficacy-observations-container" class="mt-2 space-y-4"></div><button type="button" data-action="add-observation" class="mt-3 text-sm text-teal-600 hover:text-teal-800 font-semibold flex items-center gap-1"><i data-lucide="plus-circle" class="h-4 w-4"></i> Add Observation</button></div>
                            <div class="mt-6 grid grid-cols-1 gap-6"><textarea name="conclusion" rows="3" placeholder="Conclusion" class="p-2 border rounded-md form-input"></textarea><textarea name="notes" rows="2" placeholder="Trial Notes" class="p-2 border rounded-md form-input"></textarea></div>
                            <div class="mt-6"><h4 class="text-md font-medium text-gray-800">Add Photos with Dated Weather</h4><div class="flex items-end gap-4 mt-2"><div class="flex-grow"><label for="photo-date" class="block text-sm font-medium text-gray-700">Photo Date</label><input type="date" id="photo-date" class="mt-1 p-2 border rounded-md w-full form-input"></div><input type="file" id="trial-photos" multiple accept="image/*" class="hidden"><label for="trial-photos" class="cursor-pointer bg-white text-teal-700 px-4 py-2 rounded-lg border border-teal-700 hover:bg-teal-50 text-sm font-semibold">Choose Files</label><button type="button" data-action="open-camera" class="btn-primary text-white px-4 py-2 rounded-lg text-sm font-semibold">Camera</button></div><div id="photo-preview" class="mt-2 flex flex-wrap gap-4"></div></div>
                        </form><div class="mt-6 flex justify-end space-x-3 flex-shrink-0 border-t pt-4"><button type="button" data-action="close-modal" class="bg-slate-200 text-slate-800 px-4 py-2 rounded-lg transition hover:bg-slate-300">Cancel</button><button type="submit" form="trial-form" class="btn-primary text-white px-4 py-2 rounded-lg">Save</button></div></div></div>`,
                        confirm: `<div id="confirm-modal" class="modal"><div class="modal-content bg-white p-6 rounded-lg shadow-xl w-full max-w-sm mx-auto mt-20"><h3 id="confirm-title" class="text-lg font-bold mb-4">Are you sure?</h3><p id="confirm-message" class="text-gray-600 mb-6">This action cannot be undone.</p><div class="flex justify-end space-x-3"><button data-action="confirm-cancel" class="bg-slate-200 text-slate-800 px-4 py-2 rounded-lg transition hover:bg-slate-300">Cancel</button><button data-action="confirm-ok" class="bg-red-600 text-white px-4 py-2 rounded-lg">Confirm</button></div></div></div>`,
                        photoEdit: `<div id="photo-edit-modal" class="modal"><div class="modal-content bg-white p-8 rounded-lg shadow-xl w-full max-w-lg mx-auto mt-20"><h3 class="text-lg font-bold mb-4 text-slate-800">Edit Photo Details</h3><form id="photo-edit-form"><input type="hidden" name="trialId"><input type="hidden" name="photoIndex"><div class="mb-4"><label class="block text-sm font-medium text-gray-700">Label</label><input type="text" name="label" class="mt-1 block w-full px-3 py-2 border rounded-md shadow-sm form-input"></div><div class="mb-4"><label class="block text-sm font-medium text-gray-700">Photo Date</label><input type="date" name="date" class="mt-1 block w-full px-3 py-2 border rounded-md shadow-sm form-input"></div><div class="mt-6 p-4 bg-gray-50 rounded-lg"><h4 class="text-md font-medium text-gray-800 mb-2">Weather Conditions</h4><div class="grid grid-cols-2 md:grid-cols-4 gap-4"><input type="text" name="temp" placeholder="Temp (°C)" class="p-2 border rounded-md text-sm form-input"><input type="text" name="humidity" placeholder="Humidity (%)" class="p-2 border rounded-md text-sm form-input"><input type="text" name="wind" placeholder="Wind (km/h)" class="p-2 border rounded-md text-sm form-input"><input type="text" name="rain" placeholder="Rain (mm)" class="p-2 border rounded-md text-sm form-input"></div></div><div class="mt-6 flex justify-end space-x-3"><button type="button" data-action="close-modal" class="bg-slate-200 text-slate-800 px-4 py-2 rounded-lg transition hover:bg-slate-300">Cancel</button><button type="submit" class="btn-primary text-white px-4 py-2 rounded-lg">Save Changes</button></div></form></div></div>`,
                        weedId: () => {
                            const { trial } = data;
                            if (!trial) return `<div id="weed-modal" class="modal"><div class="modal-content bg-white p-8 rounded-lg shadow-xl w-full max-w-4xl mx-auto mt-10"><p class="text-red-500">Error: Trial data could not be loaded.</p></div></div>`;
                            return `<div id="weed-modal" class="modal"><div class="modal-content bg-white p-8 rounded-lg shadow-xl w-full max-w-4xl mx-auto mt-10"><h3 class="text-xl font-bold mb-4 text-slate-800">Weed Identification for: ${sanitizeHTML(trial.FormulationName)}</h3><div class="flex items-center gap-4 mb-6"><input type="file" id="weed-photos-input" multiple accept="image/*" class="hidden" data-trial-id="${trial.ID}"><label for="weed-photos-input" class="cursor-pointer btn-primary text-white px-4 py-2 rounded-lg font-semibold">Choose Files</label><button type="button" data-action="open-weed-camera" data-trial-id="${trial.ID}" class="bg-gray-600 text-white px-4 py-2 rounded-lg hover:bg-gray-700 font-semibold">Camera</button></div><div id="weed-photo-grid" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4 h-96 overflow-y-auto bg-gray-50 p-4 rounded-lg">${safeJsonParse(trial.WeedPhotosJSON).map((p, index) => render.weedPhotoCard(p, trial.ID, index)).join('')}</div><div class="mt-6 flex justify-end"><button type="button" data-action="close-modal" class="bg-slate-200 text-slate-800 px-4 py-2 rounded-lg transition hover:bg-slate-300">Done</button></div></div></div>`;
                        },
                        reportPreview: `<div id="report-preview-modal" class="modal"><div class="modal-content bg-white p-8 rounded-lg shadow-xl w-full max-w-3xl mx-auto mt-10 h-[90vh] flex flex-col"><h3 class="text-xl font-bold mb-4 text-slate-800">Prepare Efficacy Report</h3><div id="report-content" class="space-y-6 flex-grow overflow-y-auto pr-4">
                            <div class="bg-teal-50 p-4 rounded-lg border border-teal-100 mb-4 flex gap-6 flex-wrap">
                                <div class="flex items-center gap-3">
                                    <input type="checkbox" id="show-photo-dates" data-action="toggle-photo-dates" class="h-4 w-4 text-teal-600 rounded" ${state.settings.showPhotoDates ? 'checked' : ''}>
                                    <label for="show-photo-dates" class="text-sm font-medium text-teal-900">Show photo dates</label>
                                </div>
                                <div class="flex items-center gap-3">
                                    <input type="checkbox" id="include-timeline" data-action="toggle-include-timeline" class="h-4 w-4 text-teal-600 rounded" ${state.settings.includeTimeline ? 'checked' : ''}>
                                    <label for="include-timeline" class="text-sm font-medium text-teal-900">Include Weed Status Timeline</label>
                                </div>
                            </div>
                            <div id="cover-report-section" class="hidden"><h4 class="text-md font-semibold text-slate-700">% Cover by Species</h4><div id="cover-chart-preview" class="relative h-[300px] w-full my-2 bg-slate-100 rounded-lg p-2"><canvas id="preview-cover-canvas"></canvas></div><div class="flex justify-between items-end mt-2"><label for="cover-summary-textarea" class="block text-sm font-medium text-gray-700">AI Generated Summary (Editable)</label><button id="regenerate-cover-summary" class="text-xs text-teal-600 hover:text-teal-800 font-semibold flex items-center gap-1"><i data-lucide="refresh-cw" class="h-3 w-3"></i> Regenerate</button></div><textarea id="cover-summary-textarea" class="w-full p-2 border rounded-md form-input mt-1" rows="4" placeholder="Generating summary..."></textarea></div><div id="phyto-report-section" class="hidden"><h4 class="text-md font-semibold text-slate-700">% Phytotoxicity</h4><div id="phyto-chart-preview" class="relative h-[300px] w-full my-2 bg-slate-100 rounded-lg p-2"><canvas id="preview-phyto-canvas"></canvas></div><div class="flex justify-between items-end mt-2"><label for="phyto-summary-textarea" class="block text-sm font-medium text-gray-700">AI Generated Summary (Editable)</label><button id="regenerate-phyto-summary" class="text-xs text-teal-600 hover:text-teal-800 font-semibold flex items-center gap-1"><i data-lucide="refresh-cw" class="h-3 w-3"></i> Regenerate</button></div><textarea id="phyto-summary-textarea" class="w-full p-2 border rounded-md form-input mt-1" rows="4" placeholder="Generating summary..."></textarea></div></div><div class="mt-6 flex justify-end gap-3 border-t pt-4"><button type="button" data-action="close-modal" class="bg-slate-200 text-slate-800 px-4 py-2 rounded-lg">Cancel</button><button id="generate-pdf-from-preview" class="btn-primary text-white px-4 py-2 rounded-lg flex items-center gap-2"><i data-lucide="download" class="h-4 w-4"></i> Generate & Download PDF</button></div></div></div>`,
                        qrLabel: () => {
                            const { trial, qrContent, mode } = data;
                            return `<div id="qr-label-modal" class="modal"><div class="modal-content bg-white p-6 rounded-lg shadow-xl w-full max-w-sm mx-auto mt-20 text-center"><h3 class="text-xl font-bold mb-1 text-slate-800">${sanitizeHTML(trial.FormulationName)}</h3><p class="text-xs text-slate-400 mb-4">${mode.toUpperCase()} MODE</p><div id="qr-code-canvas" class="flex justify-center mb-4 border p-2 bg-white rounded-lg shadow-inner"></div><div class="text-left bg-slate-50 p-3 rounded text-[10px] font-mono mb-4 break-all overflow-auto max-h-24 border border-slate-200">${sanitizeHTML(qrContent).replace(/\n/g, '<br>')}</div><p class="text-xs text-slate-500 mb-6 px-4">Scan this code with a phone camera to ${mode === 'online' ? 'open the live report' : 'view the plot data'}.</p><div class="flex gap-2 justify-center"><button onclick="window.print()" class="bg-slate-800 text-white px-4 py-2 rounded-lg text-sm flex items-center gap-2 font-medium"><i data-lucide="printer" class="h-3 w-3"></i> Print Label</button><button data-action="close-modal" class="bg-slate-100 text-slate-600 px-4 py-2 rounded-lg text-sm font-medium">Close</button></div></div></div>`;
                        },
                        trialDetail: () => {
                            const { trial } = data;
                            if (!trial) return '';
                            const photos = safeJsonParse(trial.PhotoURLs);
                            const photoTable = photos.length > 0 ? `<div class="mt-4"><h4 class="text-lg font-semibold mb-2 text-slate-700">Photo Log & Weather</h4><div class="overflow-x-auto rounded-lg border"><table class="min-w-full divide-y divide-gray-200 text-sm"><thead class="bg-slate-50"><tr><th class="px-4 py-2 text-left font-medium text-slate-500">Photo</th><th class="px-4 py-2 text-left font-medium text-slate-500">Label</th><th class="px-4 py-2 text-left font-medium text-slate-500">Date</th><th class="px-4 py-2 text-left font-medium text-slate-500">Weather</th><th class="px-4 py-2 text-left font-medium text-slate-500">Actions</th></tr></thead><tbody class="bg-white divide-y divide-gray-200">${photos.map((p, index) => { const photoUrl = p.url || p.fileData; if (!photoUrl) return ''; const proxiedUrl = photoUrl.startsWith('data:image') ? photoUrl : `https://images.weserv.nl/?url=${encodeURIComponent(photoUrl)}&w=100`; const fullSizeUrl = photoUrl.startsWith('data:image') ? '#' : photoUrl; const weather = p.weather || {}; return `<tr><td class="p-2"><a href="${fullSizeUrl}" target="_blank"><img src="${proxiedUrl}" class="h-16 w-16 object-cover rounded-md border"></a></td><td class="p-2">${sanitizeHTML(p.label) || '-'}</td><td class="p-2">${p.date ? new Date(p.date).toLocaleDateString() : 'N/A'}</td><td class="p-2">${weather.temp ? `${weather.temp}°C, ${weather.humidity}% H, ${weather.wind} km/h` : 'N/A'}</td><td class="p-2"><button data-action="open-photo-edit-modal" data-trial-id="${trial.ID}" data-photo-index="${index}" class="text-teal-600 hover:text-teal-800 font-semibold text-xs">Edit</button></td></tr>` }).join('')}</tbody></table></div></div>` : '<p class="mt-4 text-gray-500">No photos available.</p>';
                            const weedPhotos = safeJsonParse(trial.WeedPhotosJSON);
                            const weedTable = weedPhotos.length > 0 ? `<div class="mt-6"><h4 class="text-lg font-semibold mb-2 text-slate-700">Weed Identification</h4><div class="grid grid-cols-1 md:grid-cols-2 gap-4">${weedPhotos.map(p => { const bestMatch = p.identifications?.[0]; return `<div class="border rounded-lg p-3 bg-slate-50"><img src="https://images.weserv.nl/?url=${encodeURIComponent(p.url)}&w=300" class="rounded-md w-full h-48 object-cover mb-2"><p class="font-semibold text-sm">${sanitizeHTML(bestMatch?.name) || 'Unknown'} <em class="text-gray-500 font-normal">${sanitizeHTML(bestMatch?.commonNames?.[0]) || ''}</em></p><p class="text-xs text-gray-500">Confidence: ${bestMatch?.confidence ? (bestMatch.confidence * 100).toFixed(1) + '%' : 'N/A'}</p></div>` }).join('')}</div></div>` : '';
                            const efficacyData = safeJsonParse(trial.EfficacyDataJSON);
                            const hasEfficacyData = efficacyData.length > 0;
                            const efficacyCharts = hasEfficacyData ? `<div class="mt-6 col-span-1 md:col-span-2"><h4 class="text-lg font-semibold mb-2 text-slate-700">Efficacy Over Time</h4><p class="text-xs text-gray-500 -mt-2 mb-4">Each line in the '% Cover' chart represents a unique weed species identified across all trial observations.</p><div class="grid grid-cols-1 lg:grid-cols-2 gap-8"><div class="bg-slate-50 p-4 rounded-lg"><h5 class="text-md font-semibold mb-2 text-slate-700">% Cover by Species</h5><div class="h-64"><canvas id="single-cover-chart"></canvas></div></div><div class="bg-slate-50 p-4 rounded-lg"><h5 class="text-md font-semibold mb-2 text-slate-700">% Phytotoxicity</h5><div class="h-64"><canvas id="single-phyto-chart"></canvas></div></div></div></div>` : '<div class="mt-6 col-span-1 md:col-span-2"><p class="text-gray-500">No quantitative efficacy data logged for this trial.</p></div>';
                            const weedStatusTable = hasEfficacyData ? `<div class="mt-6 col-span-1 md:col-span-2"><h4 class="text-lg font-semibold mb-2 text-slate-700">Weed Status Timeline</h4><div class="overflow-x-auto rounded-lg border"><table class="min-w-full divide-y divide-gray-200 text-sm"><thead class="bg-slate-50"><tr><th class="px-4 py-2 text-left font-medium text-slate-500">DA-A</th><th class="px-4 py-2 text-left font-medium text-slate-500">Species</th><th class="px-4 py-2 text-left font-medium text-slate-500">Status</th><th class="px-4 py-2 text-left font-medium text-slate-500">Notes</th></tr></thead><tbody class="bg-white divide-y divide-gray-200">${efficacyData.flatMap(obs => (obs.weedDetails || []).map(wd => `<tr><td class="p-2 font-semibold">${obs.daa}</td><td class="p-2">${sanitizeHTML(wd.species)}</td><td class="p-2">${sanitizeHTML(wd.status)}</td><td class="p-2">${sanitizeHTML(wd.notes)}</td></tr>`)).join('')}</tbody></table></div></div>` : '';
                            return `<div id="trial-detail-modal" class="modal"><div class="modal-content bg-white p-8 rounded-lg shadow-xl w-full max-w-6xl mx-auto mt-10 h-[90vh] flex flex-col"><div class="flex-grow overflow-y-auto pr-4"><h3 class="text-2xl font-bold mb-6 text-slate-800">Herbicide Trial Report: ${sanitizeHTML(trial.FormulationName)}</h3><div class="grid grid-cols-1 md:grid-cols-2 gap-8"><div class="space-y-2 text-gray-800"><p><strong>Investigator:</strong> ${sanitizeHTML(trial.InvestigatorName) || 'N/A'}</p><p><strong>Location:</strong> ${sanitizeHTML(trial.Location) || 'N/A'}</p><p><strong>Dosage:</strong> ${sanitizeHTML(trial.Dosage) || 'N/A'}</p><p><strong>Weed Species:</strong> ${sanitizeHTML(trial.WeedSpecies) || 'N/A'}</p><p><strong>Date:</strong> ${new Date(trial.Date).toLocaleDateString()}</p><p><strong>Result:</strong> ${sanitizeHTML(trial.Result) || 'N/A'}</p>${trial.Temperature ? `<div class="mt-4 pt-4 border-t"><p class="font-semibold text-gray-500 text-sm">Weather on Trial Date</p><p><strong>Temperature:</strong> ${trial.Temperature}°C</p><p><strong>Humidity:</strong> ${trial.Humidity}%</p><p><strong>Wind:</strong> ${trial.Windspeed} km/h</p><p><strong>Rain:</strong> ${trial.Rain} mm</p></div>` : ''}<div class="mt-4 pt-4 border-t"><p><strong>Conclusion:</strong> ${sanitizeHTML(trial.Conclusion) || 'N/A'}</p><p><strong>Notes:</strong> ${sanitizeHTML(trial.Notes) || 'N/A'}</p></div></div><div>${photoTable} ${weedTable}</div>${efficacyCharts} ${weedStatusTable}</div></div><div class="mt-8 border-t pt-6">
                                <div class="bg-teal-50 p-4 rounded-lg mb-6 flex flex-wrap gap-6 items-center border border-teal-100">
                                    <div class="flex items-center gap-2">
                                        <input type="checkbox" id="show-photo-dates-detail" data-action="toggle-photo-dates" class="h-4 w-4 text-teal-600 rounded" ${state.settings.showPhotoDates ? 'checked' : ''}>
                                        <label for="show-photo-dates-detail" class="text-sm font-medium text-teal-900">Show photo dates</label>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <input type="checkbox" id="include-timeline-detail" data-action="toggle-include-timeline" class="h-4 w-4 text-teal-600 rounded" ${state.settings.includeTimeline ? 'checked' : ''}>
                                        <label for="include-timeline-detail" class="text-sm font-medium text-teal-900">Include Weed Status Timeline</label>
                                    </div>
                                </div>
                                <div class="flex flex-wrap justify-center gap-3 flex-shrink-0">
                                    <button data-action="export-pdf-ingredients" data-id="${trial.ID}" class="bg-gray-200 text-gray-800 px-4 py-2 rounded-lg text-sm transition hover:bg-gray-300">PDF (Ingredients)</button>
                                    <button data-action="export-pdf-no-ingredients" data-id="${trial.ID}" class="bg-gray-200 text-gray-800 px-4 py-2 rounded-lg text-sm transition hover:bg-gray-300">PDF (No Ing.)</button>
                                    <button data-action="export-pdf-weeds-ingredients" data-id="${trial.ID}" class="bg-blue-100 text-blue-800 px-4 py-2 rounded-lg text-sm font-semibold transition hover:bg-blue-200">PDF (Weeds + Ing.)</button>
                                    <button data-action="export-pdf-weeds" data-id="${trial.ID}" class="bg-blue-100 text-blue-800 px-4 py-2 rounded-lg text-sm font-semibold transition hover:bg-blue-200">PDF (Weeds)</button>
                                    ${hasEfficacyData ? `<button data-action="export-pdf-efficacy-no-ingredients" data-id="${trial.ID}" class="bg-teal-100 text-teal-800 px-4 py-2 rounded-lg text-sm font-semibold transition hover:bg-teal-200">Full Report (No Ing.)</button>` : ''}
                                    ${hasEfficacyData ? `<button data-action="export-pdf-with-report" data-id="${trial.ID}" class="bg-teal-100 text-teal-800 px-4 py-2 rounded-lg text-sm font-semibold transition hover:bg-teal-200">Full Report (w/ Ing.)</button>` : ''}
                                    <button data-action="export-ppt" data-id="${trial.ID}" class="bg-orange-100 text-orange-800 px-4 py-2 rounded-lg text-sm font-semibold transition hover:bg-orange-200">Export PPT</button>
                                    <button data-action="close-modal" class="btn-primary text-white px-4 py-2 rounded-lg text-sm">Go Back</button>
                            </div></div></div>`;
                        },
                        organise: `<div id="organise-modal" class="modal"><div class="modal-content bg-white p-8 rounded-lg shadow-xl w-full max-w-md mx-auto mt-20"><h3 class="text-lg font-bold mb-4 text-slate-800">Add to Organisation</h3><form id="organise-form"><div class="mb-4"><label class="block text-sm font-medium text-gray-700">Select Existing Organisation</label><select name="organisationId" id="existing-organisations" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm form-input"><option value="">-- Choose existing --</option>${state.organisations.map(o => `<option value="${o.ID}">${sanitizeHTML(o.Name)}</option>`).join('')}</select></div><div class="text-center my-2 text-gray-500">OR</div><div class="mb-4"><label class="block text-sm font-medium text-gray-700">Create New Organisation</label><input type="text" name="newOrganisationName" placeholder="e.g., Summer 2025 Variants" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm form-input"></div><div class="mt-6 flex justify-end space-x-3"><button type="button" data-action="close-modal" class="bg-slate-200 text-slate-800 px-4 py-2 rounded-lg transition hover:bg-slate-300">Cancel</button><button type="submit" class="btn-primary text-white px-4 py-2 rounded-lg">Save</button></div></form></div></div>`,
                        qrModeChoice: () => {
                            const { trial } = data;
                            return `<div id="qr-mode-modal" class="modal"><div class="modal-content bg-white p-8 rounded-lg shadow-xl w-full max-w-md mx-auto mt-20"><h3 class="text-lg font-bold mb-4 text-slate-800">Choose QR Code Type</h3><p class="text-sm text-gray-600 mb-6">Select how you want to generate the QR code for: <strong>${sanitizeHTML(trial.FormulationName)}</strong></p><div class="flex flex-col space-y-4"><button data-action="generate-qr-final" data-id="${trial.ID}" data-mode="offline" class="w-full text-left p-4 rounded-lg bg-slate-50 border border-slate-200 hover:bg-teal-50 hover:border-teal-200 transition"><p class="font-bold text-slate-800">Offline Mode</p><p class="text-xs text-slate-500 mt-1">Encodes data directly in the QR. No internet needed to scan, but content is limited.</p></button><button data-action="generate-qr-final" data-id="${trial.ID}" data-mode="online" class="w-full text-left p-4 rounded-lg bg-slate-50 border border-slate-200 hover:bg-teal-50 hover:border-teal-200 transition"><p class="font-bold text-slate-800">Online Mode (Live)</p><p class="text-xs text-slate-500 mt-1">Links to a live web page. Allows photos, ingredients, and updates without re-printing.</p></button></div><div class="mt-6 flex justify-end"><button type="button" data-action="close-modal" class="bg-slate-200 text-slate-800 px-4 py-2 rounded-lg transition hover:bg-slate-300">Cancel</button></div></div></div>`;
                        },
                        liveQrSettings: () => {
                            const { trial } = data;
                            let currentSettings = {};
                            try {
                                currentSettings = safeJsonParse(trial.LiveQRSettings, state.settings.qrOnlineFields);
                            } catch (e) {
                                currentSettings = state.settings.qrOnlineFields;
                            }
                            const fieldsHtml = Object.keys(state.settings.qrOnlineFields).map(key => {
                                const label = key.replace('show', '').replace(/([A-Z])/g, ' $1');
                                return `<label class="flex items-center gap-2"><input type="checkbox" name="${key}" ${currentSettings[key] ? 'checked' : ''} class="h-4 w-4 rounded border-gray-300 text-teal-600 focus:ring-teal-500"> ${label}</label>`;
                            }).join('');

                            return `<div id="live-qr-modal" class="modal"><div class="modal-content bg-white p-8 rounded-lg shadow-xl w-full max-w-lg mx-auto mt-10"><h3 class="text-xl font-bold mb-2 text-slate-800">Live QR Settings</h3><p class="text-sm text-gray-500 mb-6 border-b pb-2">Individual content control for: <strong>${sanitizeHTML(trial.FormulationName)}</strong></p><form id="live-qr-settings-form" data-id="${trial.ID}" class="grid grid-cols-2 md:grid-cols-3 gap-4 text-sm">${fieldsHtml}</form><div class="mt-8 flex justify-end gap-3 border-t pt-4"><button type="button" data-action="close-modal" class="bg-slate-200 text-slate-800 px-4 py-2 rounded-lg">Cancel</button><button type="button" data-action="save-live-qr-settings-final" class="btn-primary text-white px-5 py-2 rounded-lg">Save Settings</button></div></div></div>`;
                        }
                    };
                    const template = modalTemplates[modalId];
                    return typeof template === 'function' ? template() : (template || '');
                }
            };

            const render = {
                apiKeyInput: (key = '', index) => {
                    return `
                        <div class="flex items-center gap-2 api-key-row">
                            <input type="password" value="${sanitizeHTML(key)}" class="api-key-input mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 form-input" placeholder="Enter Gemini API Key">
                            <button type="button" data-action="remove-api-key" data-index="${index}" class="text-red-500 hover:text-red-700 font-bold p-1">&times;</button>
                        </div>
                    `;
                },
                dashboard: () => {
                    Object.values(state.charts).forEach(chart => { if (chart) chart.destroy() });
                    state.charts = {};
                    const trials = state.trials || [];
                    const formulations = state.formulations || [];
                    document.getElementById('total-trials').textContent = String(trials.length);
                    document.getElementById('completed-trials').textContent = String(trials.filter(t => String(t.IsCompleted).toLowerCase() === 'true').length);
                    document.getElementById('active-trials').textContent = String(trials.length - trials.filter(t => String(t.IsCompleted).toLowerCase() === 'true').length);
                    const weatherTrials = trials.filter(t => t.Temperature && t.Humidity && t.Windspeed);
                    let avgTemp = 0, avgHumidity = 0, avgWind = 0, avgRain = 0;
                    if (weatherTrials.length > 0) {
                        avgTemp = weatherTrials.reduce((sum, t) => sum + parseFloat(t.Temperature), 0) / weatherTrials.length;
                        avgHumidity = weatherTrials.reduce((sum, t) => sum + parseFloat(t.Humidity), 0) / weatherTrials.length;
                        avgWind = weatherTrials.reduce((sum, t) => sum + parseFloat(t.Windspeed), 0) / weatherTrials.length;
                        avgRain = weatherTrials.reduce((sum, t) => sum + parseFloat(t.Rain || 0), 0) / weatherTrials.length;
                    }
                    const weatherEl = document.getElementById('avg-weather-conditions');
                    if (weatherEl) {
                        weatherEl.innerHTML = `<div class="flex items-center gap-3"><div class="bg-blue-100 p-2 rounded-full"><i data-lucide="thermometer" class="h-5 w-5 text-blue-600"></i></div><div><p class="font-bold text-slate-700">${avgTemp.toFixed(1)}°C</p><p class="text-xs text-slate-500">Avg. Temp</p></div></div><div class="flex items-center gap-3"><div class="bg-sky-100 p-2 rounded-full"><i data-lucide="droplets" class="h-5 w-5 text-sky-600"></i></div><div><p class="font-bold text-slate-700">${avgHumidity.toFixed(1)}%</p><p class="text-xs text-slate-500">Avg. Humidity</p></div></div><div class="flex items-center gap-3"><div class="bg-slate-100 p-2 rounded-full"><i data-lucide="wind" class="h-5 w-5 text-slate-600"></i></div><div><p class="font-bold text-slate-700">${avgWind.toFixed(1)} km/h</p><p class="text-xs text-slate-500">Avg. Wind</p></div></div><div class="flex items-center gap-3"><div class="bg-indigo-100 p-2 rounded-full"><i data-lucide="cloud-rain" class="h-5 w-5 text-indigo-600"></i></div><div><p class="font-bold text-slate-700">${avgRain.toFixed(1)} mm</p><p class="text-xs text-slate-500">Avg. Rain</p></div></div>`;
                        lucide.createIcons();
                    }

                    // Top Control Days Calculation
                    const trialsWithDuration = trials.map(t => {
                        let duration = 0;
                        if (String(t.ControlFinalized).toLowerCase() === 'true' && t.FinalControlDuration != null) {
                            duration = parseInt(t.FinalControlDuration, 10);
                        } else if (t.Date) {
                            duration = Math.floor((new Date() - new Date(t.Date)) / (1000 * 60 * 60 * 24));
                            if (duration < 0) duration = 0;
                        }
                        return { ...t, computedDuration: duration };
                    });
                    trialsWithDuration.sort((a, b) => b.computedDuration - a.computedDuration);
                    const topControlList = document.getElementById('top-control-days-list');
                    if (topControlList) {
                        topControlList.innerHTML = trialsWithDuration.slice(0, 10).map(t =>
                            `<li class="flex justify-between items-center"><span class="text-slate-600 truncate w-2/3">${sanitizeHTML(t.FormulationName)}</span><span class="font-bold text-teal-700">${t.computedDuration} Days</span></li>`
                        ).join('') || '<p class="text-slate-500">No trials active.</p>';
                    }

                    // Trials over time chart
                    const trialsByDate = trials.reduce((acc, trial) => {
                        const date = new Date(trial.Date);
                        date.setHours(0, 0, 0, 0);
                        const dateStr = date.toISOString().split('T')[0];
                        acc[dateStr] = (acc[dateStr] || 0) + 1;
                        return acc;
                    }, {});
                    const sortedDates = Object.keys(trialsByDate).sort((a, b) => new Date(a).getTime() - new Date(b).getTime());
                    const recentSortedDates = sortedDates.slice(-30);
                    const trialsCtx = document.getElementById('trials-over-time-chart')?.getContext('2d');
                    if (trialsCtx) {
                        const gradient = trialsCtx.createLinearGradient(0, 0, 0, trialsCtx.canvas.height);
                        gradient.addColorStop(0, 'rgba(13, 148, 136, 0.4)');
                        gradient.addColorStop(1, 'rgba(13, 148, 136, 0)');
                        const chartDefaults = getChartDefaults();
                        state.charts.trialsOverTime = new Chart(trialsCtx, {
                            type: 'line',
                            data: {
                                labels: recentSortedDates.map(d => new Date(d + 'T00:00:00').toLocaleDateString('en-US', { month: 'short', day: 'numeric' })),
                                datasets: [{
                                    label: 'Trials Conducted',
                                    data: recentSortedDates.map(d => trialsByDate[d]),
                                    borderColor: '#0d9488',
                                    backgroundColor: gradient,
                                    fill: true,
                                }]
                            },
                            options: {
                                ...chartDefaults,
                                plugins: { ...chartDefaults.plugins, legend: { position: 'top', align: 'end' } },
                            }
                        });
                    }

                    // Results breakdown chart
                    const resultsCount = trials.reduce((acc, trial) => {
                        const result = trial.Result || 'None';
                        acc[result] = (acc[result] || 0) + 1;
                        return acc;
                    }, {});
                    const resultLabels = ['Excellent', 'Poor', 'Fair', 'Good', 'None'];
                    const resultData = resultLabels.map(label => resultsCount[label] || 0);
                    const resultColors = { 'Excellent': '#22c55e', 'Poor': '#ef4444', 'Fair': '#f59e0b', 'Good': '#3b82f6', 'None': '#a1a1aa' };
                    const resultsCtx = document.getElementById('results-breakdown-chart');
                    if (resultsCtx) {
                        const chartDefaults = getChartDefaults();
                        state.charts.resultsBreakdown = new Chart(resultsCtx, {
                            type: 'doughnut',
                            data: {
                                labels: resultLabels,
                                datasets: [{ data: resultData, backgroundColor: resultLabels.map(l => resultColors[l]), borderColor: '#fff', borderWidth: 4 }]
                            },
                            options: {
                                ...chartDefaults,
                                cutout: '70%',
                                plugins: { ...chartDefaults.plugins, legend: { ...chartDefaults.plugins.legend, position: 'bottom' } }
                            }
                        });
                    }
                },
                trialCard: (trial, showCheckbox = true) => {
                    const formulation = state.formulations.find(f => f.ID === trial.FormulationID);
                    const cost = formulation ? parseFloat(formulation.EstimatedCost || 0).toFixed(2) : '0.00';
                    const isFinal = String(trial.ControlFinalized).toLowerCase() === 'true';
                    let controlDuration;
                    if (isFinal) {
                        if (trial.FinalControlDuration != null && trial.FinalControlDuration !== '') {
                            controlDuration = `${trial.FinalControlDuration} Days (Final)`;
                        } else if (trial.FinalizationDate && trial.Date) {
                            const days = Math.floor((new Date(trial.FinalizationDate) - new Date(trial.Date)) / (1000 * 60 * 60 * 24));
                            controlDuration = `${days < 0 ? 0 : days} Days (Final)`;
                        } else {
                            controlDuration = 'Finalized';
                        }
                    } else if (trial.Date) {
                        const days = Math.floor((new Date() - new Date(trial.Date)) / (1000 * 60 * 60 * 24));
                        controlDuration = `${days < 0 ? 0 : days} Days`;
                    } else {
                        controlDuration = 'N/A';
                    }
                    const formulationName = trial.FormulationName || formulation?.Name || 'Unknown Formulation';
                    const photoURLs = safeJsonParse(trial.PhotoURLs);
                    const allPhotos = [...photoURLs]; // Only show general photos on home screen card
                    const photos = allPhotos.slice(0, 4).map(p => {
                        const photoUrl = p.url || p.fileData;
                        if (typeof photoUrl !== 'string' || !photoUrl) return '';
                        const proxiedUrl = photoUrl.startsWith('data:image') ? photoUrl : `https://images.weserv.nl/?url=${encodeURIComponent(photoUrl)}&w=100&h=100&fit=cover`;
                        return `<img src="${proxiedUrl}" class="h-16 w-16 object-cover rounded-md border ${p.isWeed ? 'border-teal-400' : ''}" alt="${sanitizeHTML(p.label) || 'Trial photo'}">`;
                    }).join('');
                    const resultValue = trial.Result || '';
                    const resultClasses = `py-1 px-2 rounded-full text-xs font-semibold result-${resultValue.toLowerCase() || 'none'}`;
                    const resultSelect = `<select data-action="update-result" data-id="${trial.ID}" class="text-xs font-semibold bg-transparent border-none focus:ring-0 focus:outline-none result-${resultValue.toLowerCase() || 'none'}" onchange="this.className = 'text-xs font-semibold bg-transparent border-none focus:ring-0 focus:outline-none result-' + (this.value.toLowerCase() || 'none')"><option value="" ${resultValue === '' ? 'selected' : ''}>Set Result</option><option value="Excellent" ${resultValue === 'Excellent' ? 'selected' : ''}>Excellent</option><option value="Good" ${resultValue === 'Good' ? 'selected' : ''}>Good</option><option value="Fair" ${resultValue === 'Fair' ? 'selected' : ''}>Fair</option><option value="Poor" ${resultValue === 'Poor' ? 'selected' : ''}>Poor</option></select>`;
                    const isChecked = state.selectedTrials.includes(trial.ID);
                    const hasAiData = trial.EfficacyDataJSON && trial.EfficacyDataJSON !== '[]' && trial.AISummariesJSON && trial.AISummariesJSON !== '{}';

                    return `<div class="bg-white rounded-xl shadow-lg flex flex-col h-full transition-all duration-300 hover:shadow-xl hover:-translate-y-1 border border-transparent hover:border-teal-500/50">
                                <div class="p-5 flex-grow">
                                    <div class="flex items-start justify-between">
                                        <div class="flex items-start gap-3">
                                            ${showCheckbox ? `<input type="checkbox" data-action="select-trial" data-id="${trial.ID}" class="mt-1 h-4 w-4 rounded border-gray-300 text-teal-600 focus:ring-teal-500" ${isChecked ? 'checked' : ''}>` : ''}
                                            <div class="cursor-pointer" data-action="view-trial" data-id="${trial.ID}">
                                                <h3 class="font-bold text-lg text-slate-800">${sanitizeHTML(formulationName)}</h3>
                                                <p class="text-xs text-slate-500">${new Date(trial.Date).toLocaleDateString()}</p>
                                                <p class="text-sm text-slate-600 truncate mt-1">Investigator: ${sanitizeHTML(trial.InvestigatorName) || 'N/A'}</p>
                                            </div>
                                        </div>
                                        <div class="flex items-center gap-2">
                                            <button data-action="generate-qr-label" data-id="${trial.ID}" class="p-1 rounded-full hover:bg-teal-50 text-teal-600" title="Plot Label QR"><i data-lucide="qr-code" class="h-4 w-4"></i></button>
                                            <div class="${resultClasses} p-0">${resultSelect}</div>
                                            <div class="relative">
                                                <button class="p-1 rounded-full hover:bg-slate-100" data-action="toggle-card-menu" data-id="${trial.ID}"><i data-lucide="more-vertical" class="h-4 w-4"></i></button>
                                                <div id="card-menu-${trial.ID}" class="card-menu absolute top-full right-0 mt-1 bg-white rounded-md shadow-lg p-1 w-40 hidden z-20 text-sm border">
                                                    ${!hasAiData ? `<button data-action="generate-single-ai" data-id="${trial.ID}" class="w-full text-left px-3 py-1 rounded hover:bg-indigo-50 text-indigo-600">Generate AI Report</button>` : ''}
                                                    <button data-action="edit" data-type="trial" data-id="${trial.ID}" class="w-full text-left px-3 py-1 rounded hover:bg-slate-100">Edit</button>
                                                    <button data-action="duplicate" data-type="trial" data-id="${trial.ID}" class="w-full text-left px-3 py-1 rounded hover:bg-slate-100">Duplicate</button>
                                                    <button data-action="delete" data-type="trial" data-id="${trial.ID}" class="w-full text-left px-3 py-1 rounded text-red-600 hover:bg-red-50">Delete</button>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="flex items-center gap-2 mt-2">
                                        <input type="checkbox" data-action="toggle-completed" data-id="${trial.ID}" id="completed-${trial.ID}" class="h-4 w-4 rounded border-gray-300 text-teal-600 focus:ring-teal-500" ${String(trial.IsCompleted).toLowerCase() === 'true' ? 'checked' : ''}>
                                        <label for="completed-${trial.ID}" class="text-xs font-medium text-gray-700">Mark as Completed</label>
                                    </div>
                                    <div class="mt-4 grid grid-cols-2 gap-x-4 text-sm text-gray-600">
                                        <p><strong>Dosage:</strong> ${sanitizeHTML(trial.Dosage) || 'N/A'}</p>
                                        <button type="button" class="bg-slate-100 border border-slate-300 rounded px-2 py-1 text-slate-700 hover:bg-slate-200 transition text-xs flex items-center gap-1 w-fit relative z-10 cursor-pointer" data-action="edit-control-days" data-id="${trial.ID}" title="Click to edit control days"><strong>Control:</strong> ${controlDuration} <i data-lucide="edit-2" class="h-3 w-3"></i></button>
                                        <p class="font-semibold text-slate-700 mt-2"><strong>Cost:</strong> ${CURRENCY_SYMBOL}${cost}</p>
                                    </div>
                                    <div class="mt-4 flex items-center justify-between">
                                        <div class="flex items-center gap-2">
                                            <div class="w-2 h-2 rounded-full ${String(trial.IsLive).toLowerCase() !== 'false' ? 'bg-green-500' : 'bg-slate-400'}"></div>
                                            <span class="text-[10px] font-bold ${String(trial.IsLive).toLowerCase() !== 'false' ? 'text-green-700' : 'text-slate-500'}">${String(trial.IsLive).toLowerCase() !== 'false' ? 'LIVE' : 'INACTIVE'}</span>
                                            <button data-action="manage-live-qr" data-id="${trial.ID}" class="text-teal-600 hover:text-teal-800" title="Manage Live QR Content"><i data-lucide="settings-2" class="h-3 w-3"></i></button>
                                        </div>
                                        <button data-action="toggle-live-status" data-id="${trial.ID}" class="text-[10px] ${String(trial.IsLive).toLowerCase() !== 'false' ? 'bg-amber-50 text-amber-700 border-amber-200' : 'bg-green-50 text-green-700 border-green-200'} px-2 py-0.5 border rounded font-bold hover:opacity-80 transition">${String(trial.IsLive).toLowerCase() !== 'false' ? 'Deactivate' : 'Activate'}</button>
                                    </div>
                                    ${photos ? `<div class="mt-4 cursor-pointer" data-action="view-trial" data-id="${trial.ID}"><div class="flex flex-wrap gap-2">${photos}</div></div>` : ''}
                                </div>
                                <div class="mt-auto p-3 border-t bg-slate-50/50 rounded-b-xl flex items-center justify-between gap-2">
                                    <div class="flex items-center gap-2">
                                        <button class="text-xs bg-white border rounded-md px-2 py-1 hover:bg-slate-100 transition" data-action="open-weed-modal" data-id="${trial.ID}">Identify Weeds</button>
                                        <input type="file" id="quick-photo-input-${trial.ID}" class="hidden" data-action="quick-add-photo" data-id="${trial.ID}" accept="image/*" multiple>
                                        <label for="quick-photo-input-${trial.ID}" class="text-xs bg-white border rounded-md px-2 py-1 hover:bg-slate-100 transition cursor-pointer">Add Photo</label>
                                        <button class="text-xs bg-white border rounded-md px-2 py-1 hover:bg-slate-100 transition" data-action="quick-open-camera" data-id="${trial.ID}">Camera</button>
                                        <button class="text-xs bg-purple-100 text-purple-800 border border-purple-200 rounded-md px-2 py-1 hover:bg-purple-200 transition font-semibold" data-action="analyze-trial-efficacy" data-id="${trial.ID}" title="Run AI analysis on this trial's photos">Analyze</button>
                                    </div>
                                    <div>
                                        ${!isFinal ? `<button class="text-xs bg-green-100 text-green-800 border border-green-200 rounded-md px-2 py-1 hover:bg-green-200 transition font-semibold" data-action="finalize-trial" data-id="${trial.ID}">Stop Counting</button>` : `<button class="text-xs bg-amber-100 text-amber-800 border border-amber-200 rounded-md px-2 py-1 hover:bg-amber-200 transition font-semibold" data-action="restart-trial" data-id="${trial.ID}">Restart Count</button>`}
                                    </div>
                                </div>
                            </div>`;
                },
                weedPhotoCard: (p, trialId, index) => {
                    const proxiedUrl = (p.url || p.fileData) ? ((p.url || p.fileData).startsWith('data:image') ? (p.url || p.fileData) : `https://images.weserv.nl/?url=${encodeURIComponent(p.url)}&w=300`) : '';
                    let identificationHTML = '<div class="flex flex-col items-center justify-center gap-2"><div class="spinner h-6 w-6 border-2"></div><p class="text-xs text-slate-500 animate-pulse">Syncing & Analyzing...</p></div>';

                    const syncItem = state.syncQueue.find(s => s.photo.tempId === p.tempId);
                    if (syncItem && syncItem.status === 'error') {
                        identificationHTML = `<div class="text-red-500 text-xs font-semibold flex flex-col items-center gap-1">
                            <i data-lucide="alert-circle" class="h-4 w-4"></i>
                            Sync Failed (Offline?)
                            <button data-action="retry-sync" data-id="${syncItem.id}" class="mt-1 text-teal-600 underline">Retry</button>
                        </div>`;
                    }

                    if (p.identifications) {
                        if (p.identifications.length > 0) {
                            // Show ALL identified weeds, not just the first one
                            identificationHTML = p.identifications.map((weed, i) => `
                                <div class="text-left border-b border-gray-100 pb-1 mb-1 ${i > 0 ? 'mt-2' : ''}">
                                    <p class="font-semibold text-sm text-gray-800">${sanitizeHTML(weed.name)} 
                                        <em class="text-gray-500 font-normal text-xs">${sanitizeHTML(weed?.commonNames?.[0]) || ''}</em>
                                    </p>
                                    <p class="text-xs text-gray-500">Confidence: ${((weed.confidence || 0) * 100).toFixed(1)}%${weed.growthStage ? ` • ${sanitizeHTML(weed.growthStage)}` : ''}</p>
                                </div>
                            `).join('');
                        } else {
                            identificationHTML = '<p class="text-sm text-red-500">No weeds identified.</p>';
                        }
                    }
                    return `<div class="border rounded-lg p-2 bg-white flex flex-col text-center relative"><img src="${proxiedUrl}" class="rounded-md w-full h-40 object-cover mb-2"><div class="mt-auto max-h-32 overflow-y-auto">${identificationHTML}</div><button data-action="delete-weed-photo" data-trial-id="${trialId}" data-index="${index}" class="absolute top-1 right-1 bg-red-500 text-white rounded-full h-5 w-5 flex items-center justify-center text-xs font-bold">&times;</button></div>`;
                },
                ingredients: (data = state.ingredients) => { const el = document.getElementById('ingredients-list'); if (el) el.innerHTML = `<ul class="divide-y divide-gray-200">${[...(data || [])].filter(ing => ing && ing.Name).sort((a, b) => String(b.ID).localeCompare(String(a.ID), undefined, { numeric: true })).map(ing => `<li class="py-3 flex justify-between items-center"><div><p class="font-medium">${sanitizeHTML(ing.Name)}</p><p class="text-sm text-gray-500">${CURRENCY_SYMBOL}${(parseFloat(ing.Cost) || 0).toFixed(2)} / ${sanitizeHTML(ing.Unit)}</p></div><div class="flex gap-4"><button data-action="edit" data-type="ingredient" data-id="${ing.ID}" class="text-teal-600 hover:text-teal-800 font-bold">Edit</button><button data-action="delete" data-type="ingredient" data-id="${ing.ID}" class="text-red-500 hover:text-red-700 font-bold">&times;</button></div></li>`).join('') || '<p class="text-gray-500">No ingredients.</p>'}</ul>`; },
                formulations: (data = state.formulations) => { const el = document.getElementById('formulations-list'); if (el) el.innerHTML = [...(data || [])].sort((a, b) => String(b.ID).localeCompare(String(a.ID), undefined, { numeric: true })).map(form => `<div class="bg-white p-6 rounded-xl shadow-lg relative transition-all duration-300 hover:shadow-xl hover:-translate-y-1 border border-transparent hover:border-teal-500/50"><div class="absolute top-4 right-4 flex gap-2"><button data-action="duplicate" data-type="formulation" data-id="${form.ID}" class="bg-slate-200 text-slate-700 px-3 py-1 rounded-md text-sm hover:bg-slate-300">Duplicate</button><button data-action="edit" data-type="formulation" data-id="${form.ID}" class="bg-teal-100 text-teal-700 px-3 py-1 rounded-md text-sm hover:bg-teal-200">Edit</button><button data-action="delete" data-type="formulation" data-id="${form.ID}" class="text-red-500 hover:text-red-700 font-bold text-xl">&times;</button></div><h3 class="font-bold text-lg text-slate-800">${sanitizeHTML(form.Name)}</h3><div class="mt-2 text-sm text-gray-600"><ul class="list-disc list-inside">${safeJsonParse(form.IngredientsJSON).map(ing => `<li>${sanitizeHTML(ing.name)} (${ing.quantity} ${ing.unit})</li>`).join('')}</ul>${form.Notes ? `<p class="mt-2"><strong>Notes:</strong> ${sanitizeHTML(form.Notes)}</p>` : ''}</div><p class="mt-4 font-semibold text-teal-700">Cost: ${CURRENCY_SYMBOL}${parseFloat(form.EstimatedCost || 0).toFixed(2)}</p></div>`).join('') || '<p class="text-gray-500 col-span-full">No formulations found.</p>'; },
                trials: (data = state.trials) => {
                    const el = document.getElementById('trials-list');
                    if (!el) return;
                    el.innerHTML = (data || []).map(trial => render.trialCard(trial, true)).join('') || '<p class="text-gray-500">No trials found matching criteria.</p>';
                    // Reinitialize Lucide icons after rendering trial cards (for 3-dot menu icons)
                    lucide.createIcons();
                },
                organisations: (data = state.organisations) => {
                    const el = document.getElementById('organisations-list'); if (!el) return;
                    el.innerHTML = [...(data || [])].sort((a, b) => String(b.ID).localeCompare(String(a.ID), undefined, { numeric: true })).map(org => { const trialDetails = safeJsonParse(org.TrialIDs).map(trialId => state.trials.find(t => t.ID === trialId)).filter(Boolean).sort((a, b) => new Date(b.Date) - new Date(a.Date)); return `<div class="bg-white p-6 rounded-lg shadow-md"><div class="flex justify-between items-start mb-4"><h3 class="font-bold text-xl text-gray-800">${sanitizeHTML(org.Name)}</h3><button data-action="delete" data-type="organisation" data-id="${org.ID}" class="text-red-500 hover:text-red-700 font-semibold text-sm">Delete</button></div><div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 items-stretch">${trialDetails.length > 0 ? trialDetails.map(t => render.trialCard(t, false)).join('') : '<p class="text-gray-500 col-span-full">No trials in this organisation.</p>'}</div></div>`; }).join('') || '<p class="text-gray-500">No organisations created yet. Go to the Trials page to group some together.</p>';
                },
                compareTrials: () => {
                    const warningEl = document.getElementById('compare-selection-warning');
                    const contentEl = document.getElementById('compare-content');

                    if (state.selectedTrials.length < 1) {
                        if (warningEl) warningEl.classList.remove('hidden');
                        if (warningEl) warningEl.classList.add('flex');
                        if (contentEl) contentEl.classList.add('hidden');
                        return;
                    }

                    if (warningEl) warningEl.classList.add('hidden');
                    if (warningEl) warningEl.classList.remove('flex');
                    if (contentEl) contentEl.classList.remove('hidden');

                    // Populate selected list
                    const listEl = document.getElementById('compare-selected-list');
                    if (listEl) {
                        listEl.innerHTML = state.selectedTrials.map(id => {
                            const t = state.trials.find(tr => tr.ID === id);
                            if (!t) return '';
                            return `<li class="flex justify-between items-center bg-gray-50 p-2 rounded border"><span>${sanitizeHTML(t.FormulationName)}</span><button data-action="remove-compare-trial" data-id="${id}" class="text-red-500 hover:text-red-700">&times;</button></li>`;
                        }).join('');
                    }

                    const trialsToCompare = state.selectedTrials.map(id => state.trials.find(t => t.ID === id)).filter(Boolean);
                    const allWeeds = [...new Set(trialsToCompare.flatMap(t => (t.WeedSpecies || '').split(',').map(w => w.trim()).filter(Boolean)))].sort();

                    const weedFilterEl = document.getElementById('compare-weed-filter');
                    if (weedFilterEl && weedFilterEl.options.length === 0) { // Only populate if empty to preserve selection
                        weedFilterEl.innerHTML = allWeeds.map(w => `<option value="${sanitizeHTML(w)}">${sanitizeHTML(w)}</option>`).join('');
                    }

                    // Run initial comparison if weed selected or select first available
                    if (weedFilterEl && !weedFilterEl.value && allWeeds.length > 0) {
                        weedFilterEl.value = allWeeds[0];
                    }

                    // --- DETAILED TABLE GENERATION ---
                    const tableContainer = document.getElementById('compare-table-container');
                    if (tableContainer) {
                        let tableHTML = `
                            <table class="min-w-full divide-y divide-gray-200 border text-sm">
                                <thead class="bg-gray-50">
                                    <tr>
                                        <th class="px-4 py-3 text-left font-medium text-gray-500 uppercase tracking-wider w-32 sticky left-0 bg-gray-50 border-r">Parameter</th>
                                        ${trialsToCompare.map(t => `<th class="px-4 py-3 text-left font-medium text-gray-700 tracking-wider border-r bg-white min-w-[200px]">${sanitizeHTML(t.FormulationName)}</th>`).join('')}
                                    </tr>
                                </thead>
                                <tbody class="bg-white divide-y divide-gray-200">
                                    <tr><td class="px-4 py-2 font-semibold text-gray-600 sticky left-0 bg-gray-50 border-r">Investigator</td>${trialsToCompare.map(t => `<td class="px-4 py-2 border-r">${sanitizeHTML(t.InvestigatorName) || '-'}</td>`).join('')}</tr>
                                    <tr><td class="px-4 py-2 font-semibold text-gray-600 sticky left-0 bg-gray-50 border-r">Trial Date</td>${trialsToCompare.map(t => `<td class="px-4 py-2 border-r">${new Date(t.Date).toLocaleDateString()}</td>`).join('')}</tr>
                                    <tr><td class="px-4 py-2 font-semibold text-gray-600 sticky left-0 bg-gray-50 border-r">Location</td>${trialsToCompare.map(t => `<td class="px-4 py-2 border-r">${sanitizeHTML(t.Location) || '-'}</td>`).join('')}</tr>
                                    <tr><td class="px-4 py-2 font-semibold text-gray-600 sticky left-0 bg-gray-50 border-r">Dosage</td>${trialsToCompare.map(t => `<td class="px-4 py-2 border-r">${sanitizeHTML(t.Dosage) || '-'}</td>`).join('')}</tr>
                                    <tr><td class="px-4 py-2 font-semibold text-gray-600 sticky left-0 bg-gray-50 border-r">Control Days</td>
                                        ${trialsToCompare.map(t => {
                            let duration = 'Active';
                            if (String(t.ControlFinalized).toLowerCase() === 'true') {
                                duration = (t.FinalControlDuration || '0') + ' (Final)';
                            } else if (t.Date) {
                                const days = Math.floor((new Date() - new Date(t.Date)) / (1000 * 60 * 60 * 24));
                                duration = (days < 0 ? 0 : days) + ' (Ongoing)';
                            }
                            return `<td class="px-4 py-2 border-r font-medium text-teal-600">${duration}</td>`;
                        }).join('')}
                                    </tr>
                                    <tr><td class="px-4 py-2 font-semibold text-gray-600 sticky left-0 bg-gray-50 border-r">Cost</td>
                                        ${trialsToCompare.map(t => {
                            const form = state.formulations.find(f => f.ID === t.FormulationID);
                            const cost = form ? parseFloat(form.EstimatedCost || 0).toFixed(2) : '0.00';
                            return `<td class="px-4 py-2 border-r">${CURRENCY_SYMBOL}${cost}</td>`;
                        }).join('')}
                                    </tr>
                                    <tr><td class="px-4 py-2 font-semibold text-gray-600 sticky left-0 bg-gray-50 border-r">Weather</td>
                                        ${trialsToCompare.map(t => {
                            if (!t.Temperature) return `<td class="px-4 py-2 border-r">-</td>`;
                            return `<td class="px-4 py-2 border-r text-xs">Temp: ${t.Temperature}°C<br>Hum: ${t.Humidity}%<br>Rain: ${t.Rain}mm</td>`;
                        }).join('')}
                                    </tr>
                                    <tr><td class="px-4 py-2 font-semibold text-gray-600 sticky left-0 bg-gray-50 border-r">Result</td>
                                        ${trialsToCompare.map(t => {
                            const resultValue = t.Result || 'None';
                            const colorClass = `result-${resultValue.toLowerCase()}`;
                            return `<td class="px-4 py-2 border-r"><span class="px-2 py-1 rounded-full text-xs font-bold ${colorClass}">${resultValue}</span></td>`;
                        }).join('')}
                                    </tr>
                                    <tr><td class="px-4 py-2 font-semibold text-gray-600 sticky left-0 bg-gray-50 border-r">Conclusion</td>${trialsToCompare.map(t => `<td class="px-4 py-2 border-r text-xs text-gray-500 max-w-[200px]">${sanitizeHTML(t.Conclusion) || '-'}</td>`).join('')}</tr>
                                </tbody>
                            </table>
                        `;
                        tableContainer.innerHTML = tableHTML;
                    }

                    runComparison();
                },
                efficacyData: (efficacyData) => {
                    const listEl = document.getElementById('efficacy-data-list');
                    if (!listEl) return;
                    listEl.innerHTML = efficacyData.map((obs, index) => {
                        const obsDate = obs.date ? new Date(obs.date).toLocaleDateString() : 'N/A';
                        return `<div class="flex items-center justify-between bg-white p-2 rounded-md border text-gray-700">
                            <div><strong>${obsDate}</strong> - ${sanitizeHTML(obs.label)}</div>
                            <div class="flex items-center gap-4">
                                <span><strong>C:</strong> ${obs.cover}%</span>
                                <span><strong>P:</strong> ${obs.phyto}%</span>
                                <button data-action="delete-efficacy" data-index="${index}" class="text-red-500 font-bold">&times;</button>
                            </div>
                        </div>`;
                    }).join('');
                }
            };

            // --- API & DATA HANDLING ---
            async function apiCall(action, payload = {}, showOverlay = true) {
                if (showOverlay) loadingOverlay.classList.remove('hidden');
                try {
                    const fullPayload = { ...payload, spreadsheetId: state.settings.sheetId, folderId: state.settings.folderId };
                    const res = await fetch(state.settings.scriptUrl, {
                        method: 'POST',
                        headers: { "Content-Type": "text/plain;charset=utf-8" },
                        body: JSON.stringify({ action, payload: fullPayload }),
                    });

                    if (!res.ok) {
                        const errorText = await res.text().catch(() => "Could not retrieve error body.");
                        throw new Error(`Network error: ${res.status} ${res.statusText}. Response: ${errorText}`);
                    }

                    const text = await res.text();
                    let result;
                    try {
                        result = JSON.parse(text);
                    } catch (e) {
                        console.error("Failed to parse JSON response:", text);
                        throw new Error("Received an invalid response from the server. Check Apps Script deployment.");
                    }

                    // Support both {data: {status: 'error', ...}} AND {status: 'error', ...}
                    const errorMsg = result.message || (result.data && result.data.message);
                    if (result.status === 'error' || (result.data && result.data.status === 'error')) {
                        throw new Error(`Server-side error: ${errorMsg || 'Unknown error. Check Apps Script logs.'}`);
                    }

                    // If result.data is missing but we have other properties, use the result itself
                    const finalData = result.data !== undefined ? result.data : result;

                    if (finalData === null || finalData === undefined) {
                        throw new Error("Received an empty response from the server.");
                    }

                    return finalData;
                } catch (error) {
                    console.error('API Call Error:', action, error);
                    showToast(error.message.includes('Network error') || error.message.includes('Failed to fetch') ? 'Connection to backend failed. Check script URL and deployment.' : `Error: ${error.message}`, 'error');
                    return null;
                } finally {
                    if (showOverlay) loadingOverlay.classList.add('hidden');
                }
            }

            function showToast(message, type = 'success') {
                toast.textContent = message;
                toast.className = `toast show ${type}`;
                setTimeout(() => { toast.className = toast.className.replace('show', ''); }, 5000);
            }

            // --- PAGE NAVIGATION & RENDERING ---
            function switchPage(pageId) {
                state.currentPage = pageId;
                const pageTitles = { dashboard: 'Dashboard', formulations: 'My Formulations', trials: 'Trials', compareTrials: 'Compare Trials', organisations: 'Trial Organisations', ingredients: 'Ingredient Costs', aiAssistant: 'AI Assistant', dataMgmt: 'Data Management', settings: 'Settings' };

                document.querySelectorAll('#sidebar-nav a').forEach(link => {
                    link.classList.toggle('bg-teal-50', link.dataset.page === pageId);
                    link.classList.toggle('text-teal-700', link.dataset.page === pageId);
                    link.classList.toggle('font-semibold', link.dataset.page === pageId);
                    link.classList.toggle('text-slate-600', link.dataset.page !== pageId);
                });

                document.getElementById('page-title').textContent = pageTitles[pageId] || 'Dashboard';
                mainContent.style.animation = 'none';
                mainContent.offsetHeight;
                mainContent.style.animation = 'contentFadeIn 0.5s';
                mainContent.innerHTML = templates.page(pageId);

                // Use a short timeout to ensure the DOM is updated before we try to manipulate it.
                setTimeout(() => {
                    switch (pageId) {
                        case 'dashboard':
                            render.dashboard();
                            break;
                        case 'formulations':
                            render.formulations(state.formulations);
                            break;
                        case 'trials':
                            const filterSelect = mainContent.querySelector('[data-type="trial-formulation"]');
                            if (filterSelect) {
                                const formulationNames = [...new Set((state.trials || []).map(t => t.FormulationName).filter(Boolean))].sort();
                                filterSelect.innerHTML = `<option value="">Filter by Formulation (List)</option>${formulationNames.map(name => `<option value="${name}">${sanitizeHTML(name)}</option>`).join('')}`;
                            }
                            // Restore filters from state
                            document.querySelector('[data-type="trial-search"]').value = state.filterState.search;
                            document.querySelector('[data-type="trial-formulation-text"]').value = state.filterState.formulationText;
                            document.querySelector('[data-type="trial-formulation"]').value = state.filterState.formulation;
                            document.querySelector('[data-type="trial-start-date"]').value = state.filterState.startDate;
                            document.querySelector('[data-type="trial-end-date"]').value = state.filterState.endDate;

                            applyFilters(); // Render with filters
                            updateSelectionBar();
                            break;
                        case 'compareTrials':
                            render.compareTrials();
                            break;
                        case 'organisations':
                            render.organisations(state.organisations);
                            break;
                        case 'ingredients':
                            render.ingredients(state.ingredients);
                            break;
                        case 'settings':
                            const apiKeyContainer = document.getElementById('api-keys-container');
                            if (apiKeyContainer) {
                                apiKeyContainer.innerHTML = state.settings.apiKeys.map((key, i) => render.apiKeyInput(key, i)).join('') || render.apiKeyInput('', 0);
                            }

                            // Report Settings
                            document.getElementById('settings-logo-preview').src = state.settings.logoBase64 || '';
                            document.getElementById('settings-logo-hidden').value = state.settings.logoBase64 || '';
                            document.getElementById('settings-card-size').value = state.settings.cardSize || 'ID';

                            // Setup Logo Input Listener
                            document.getElementById('settings-logo-input').addEventListener('change', function (e) {
                                const file = e.target.files[0];
                                if (file) {
                                    const reader = new FileReader();
                                    reader.onload = function (evt) {
                                        document.getElementById('settings-logo-preview').src = evt.target.result;
                                        document.getElementById('settings-logo-hidden').value = evt.target.result;
                                    };
                                    reader.readAsDataURL(file);
                                }
                            });

                            document.getElementById('script-url').value = state.settings.scriptUrl || '';
                            document.getElementById('sheet-url').value = state.settings.sheetId ? `https://docs.google.com/spreadsheets/d/${state.settings.sheetId}/` : '';
                            document.getElementById('folder-url').value = state.settings.folderId ? `https://drive.google.com/drive/folders/${state.settings.folderId}` : '';

                            // API Model Selection
                            const modelSelect = document.getElementById('settings-api-model');
                            if (modelSelect) {
                                modelSelect.value = state.settings.apiModel || 'gemini-2.5-flash-lite';
                            }

                            // API Quota Saver toggle
                            const autoAnalyzeCheckbox = document.getElementById('auto-analyze-photos');
                            if (autoAnalyzeCheckbox) {
                                autoAnalyzeCheckbox.checked = state.settings.autoAnalyzePhotos || false;
                            }

                            // QR Settings
                            const qrGrid = document.getElementById('qr-settings-grid');
                            if (qrGrid) {
                                const fields = state.settings.qrCodeFields || {};
                                qrGrid.innerHTML = Object.keys(fields).map(key => `
                                    <label class="flex items-center gap-2">
                                        <input type="checkbox" name="qr-${key}" ${fields[key] ? 'checked' : ''} class="h-4 w-4 rounded border-gray-300 text-teal-600">
                                        ${key.replace(/([A-Z])/g, ' $1')}
                                    </label>
                                `).join('');
                            }

                            const qrOnlineGrid = document.getElementById('qr-online-settings-grid');
                            if (qrOnlineGrid) {
                                const fields = state.settings.qrOnlineFields || {};
                                qrOnlineGrid.innerHTML = Object.keys(fields).map(key => `
                                    <label class="flex items-center gap-2">
                                        <input type="checkbox" name="qro-${key}" ${fields[key] ? 'checked' : ''} class="h-4 w-4 rounded border-gray-300 text-teal-600">
                                        ${key.replace('show', '').replace(/([A-Z])/g, ' $1')}
                                    </label>
                                `).join('');
                            }
                            break;
                        case 'aiAssistant':
                            const chatBox = document.getElementById('ai-chat-box');
                            if (!chatBox) return;
                            chatBox.innerHTML = '';
                            if (state.aiChatHistory.length === 0) {
                                appendMessageToChat('Hello! Ask me about your trial data.', 'ai', false);
                            } else {
                                state.aiChatHistory.forEach(msg => appendMessageToChat(msg.text, msg.sender, false, msg.image, msg.mimeType));
                            }
                            break;
                        case 'dataMgmt':
                            renderBulkAnalysisControls();
                            break;
                    }
                    lucide.createIcons();
                }, 50);
            }

            // Expose globally for HTML onclick
            window.switchPage = switchPage;

            // --- MODAL HANDLING ---
            function openModal(id, isEdit = false, data = {}) {
                modalContainer.innerHTML = templates.modal(id, isEdit, data);
                modalContainer.classList.remove('hidden');
                if (id === 'trial') setupTrialModalLogic();
                lucide.createIcons();
            }
            function closeModal() {
                modalContainer.innerHTML = '';
                modalContainer.classList.add('hidden');
            }

            function showConfirmation(title, message, onConfirm) {
                openModal('confirm');
                const okBtn = document.querySelector('[data-action="confirm-ok"]');
                const cancelBtn = document.querySelector('[data-action="confirm-cancel"]');
                document.getElementById('confirm-title').textContent = title;
                document.getElementById('confirm-message').textContent = message;
                const cleanup = () => { okBtn.removeEventListener('click', confirmHandler); cancelBtn.removeEventListener('click', cleanup); closeModal(); };
                const confirmHandler = () => { onConfirm(); cleanup(); };
                okBtn.addEventListener('click', confirmHandler, { once: true });
                cancelBtn.addEventListener('click', cleanup, { once: true });
            }

            // --- EVENT HANDLERS & BUSINESS LOGIC ---
            function handleOpenModal(type, id = null) {
                if (type === 'weedId') {
                    const trial = state.trials.find(t => t.ID === id);
                    if (trial) openModal('weedId', false, { trial });
                    return;
                }
                state.croppedPhotosData = [];
                state.currentTrialIdForCamera = null;
                openModal(type);
                setTimeout(() => {
                    if (type === 'trial') {
                        const form = document.getElementById('trial-form');
                        form.querySelector('#trial-formulation').innerHTML = `<option value="">Select formulation</option>${state.formulations.map(f => `<option value="${f.ID}">${sanitizeHTML(f.Name)}</option>`).join('')}`;
                        const today = new Date().toISOString().split('T')[0];
                        form.querySelector('#trial-date').value = today;
                        form.querySelector('#photo-date').value = today;
                        const investigatorList = document.getElementById('investigator-list');
                        const uniqueInvestigators = [...new Set(state.trials.map(t => t.InvestigatorName).filter(Boolean))];
                        investigatorList.innerHTML = uniqueInvestigators.map(name => `<option value="${sanitizeHTML(name)}"></option>`).join('');
                        addObservation(); // Add initial baseline observation
                    } else if (type === 'formulation') {
                        addFormulationIngredientRow();
                    }
                }, 50);
            }

            function handleEdit(type, id) {
                state.currentTrialIdForCamera = null;
                const data = state[type + 's'].find(item => item.ID === id);
                if (data) {
                    openModal(type, true);
                    setTimeout(() => populateForm(document.getElementById(`${type}-form`), data), 50);
                }
            }

            function handleDuplicateItem(type, id) {
                const collection = type + 's';
                const originalItem = state[collection].find(item => item.ID === id);
                if (!originalItem) return;

                let clone = { ...originalItem };
                delete clone.ID;

                if (type === 'formulation') {
                    clone.Name = `${originalItem.Name} (Copy)`;
                } else if (type === 'trial') {
                    // For trials, duplicate setup but clear execution data
                    clone.Date = new Date().toISOString().split('T')[0]; // Reset to today
                    clone.PhotoURLs = '[]';
                    clone.WeedPhotosJSON = '[]';
                    clone.EfficacyDataJSON = '[]';
                    clone.AISummariesJSON = '{}';
                    clone.Result = '';
                    clone.Conclusion = '';
                    clone.Notes = '';
                    clone.IsCompleted = false;
                    clone.ControlFinalized = false;
                    clone.FinalControlDuration = null;
                    clone.FinalizationDate = null;
                    // Keep formulation, dosage, investigator, weed species, location
                }

                openModal(type, false); // Open in "Add" mode (not edit) but populated
                setTimeout(() => { populateForm(document.getElementById(`${type}-form`), clone) }, 50);
            }

            async function handleDelete(type, id) {
                showConfirmation(`Delete this ${type}?`, `This will permanently remove the ${type}.`, async () => {
                    if (type === 'formulation' && state.trials.some(trial => trial.FormulationID === id)) {
                        return showToast('Cannot delete: formulation is in use.', 'error');
                    }
                    const collection = type + 's';
                    const originalState = JSON.parse(JSON.stringify(state[collection]));
                    state[collection] = state[collection].filter(item => item.ID !== id);

                    const result = await apiCall(`delete${type.charAt(0).toUpperCase() + type.slice(1)}`, { id }, false);
                    if (!result || !result.success) {
                        showToast(`Sync failed for delete. Reverting.`, 'error');
                        state[collection] = originalState;
                    } else {
                        showToast(`${type.charAt(0).toUpperCase() + type.slice(1)} deleted.`, 'success');
                    }
                    switchPage(state.currentPage);
                });
            }



            async function handleToggleLiveStatus(trialId) {
                const trial = state.trials.find(t => t.ID === trialId);
                if (!trial) return;

                const newStatus = String(trial.IsLive).toLowerCase() === 'false' || !trial.IsLive;
                trial.IsLive = newStatus;

                showToast(`Plot ${newStatus ? 'activated' : 'deactivated'}.`, 'success');
                applyFilters(); // Instant UI update

                await apiCall('updateTrialRecord', { ID: trialId, IsLive: newStatus }, false);
            }

            async function handleSaveLiveQrSettingsFinal() {
                const form = document.getElementById('live-qr-settings-form');
                if (!form) return;
                const trialId = form.dataset.id;
                const trial = state.trials.find(t => t.ID === trialId);
                if (!trial) return;

                const formData = new FormData(form);
                const settings = {};
                Object.keys(state.settings.qrOnlineFields).forEach(key => {
                    settings[key] = formData.get(key) !== null;
                });

                trial.LiveQRSettings = JSON.stringify(settings);
                showToast('Live QR Content updated.', 'success');
                closeModal();

                await apiCall('updateTrialRecord', { ID: trialId, LiveQRSettings: trial.LiveQRSettings }, false);
            }

            async function generateTrialCardsCombined(trialId, mode) {
                const trial = state.trials.find(t => t.ID === trialId);
                if (!trial) return;

                closeModal();
                showToast(`Generating ${mode} QR Label...`, 'info');

                // If online, check if it's live
                if (mode === 'online' && (String(trial.IsLive).toLowerCase() === 'false' || !trial.IsLive)) {
                    showToast('This plot is INACTIVE. QR will say "Plot Inactive" until activated.', 'warning');
                }

                const qrContent = generateQrContent(trial, mode);

                // Now open the label modal and render
                openModal('qrLabel', false, { trial, qrContent, mode });

                setTimeout(() => {
                    const canvasContainer = document.getElementById("qr-code-canvas");
                    if (canvasContainer) {
                        canvasContainer.innerHTML = '';
                        new QRCode(canvasContainer, {
                            text: qrContent,
                            width: 256,
                            height: 256,
                            colorDark: "#000000",
                            colorLight: "#ffffff",
                            correctLevel: QRCode.CorrectLevel.H
                        });
                    }
                }, 100);
            }

            function generateQrContent(trial, mode) {
                // IMPORTANT: Reload settings from localStorage to ensure latest QR preferences are used
                const savedSettings = localStorage.getItem('appSettings');
                if (savedSettings) {
                    try {
                        const parsed = JSON.parse(savedSettings);
                        if (parsed.qrCodeFields) state.settings.qrCodeFields = parsed.qrCodeFields;
                        if (parsed.qrOnlineFields) state.settings.qrOnlineFields = parsed.qrOnlineFields;
                    } catch (e) {
                        console.warn('Could not reload QR settings:', e);
                    }
                }

                if (mode === 'online') {
                    // Standard online URL: scriptUrl?trialId=...&spreadsheetId=...
                    const params = new URLSearchParams({
                        trialId: trial.ID,
                        spreadsheetId: state.settings.sheetId
                    });
                    return `${state.settings.scriptUrl}?${params.toString()}`;
                } else {
                    // Offline data encoding
                    const fields = state.settings.qrCodeFields;
                    const lines = [];
                    lines.push(`H-APP: ${trial.FormulationName}`);
                    if (fields.InvestigatorName && trial.InvestigatorName) lines.push(`Inv: ${trial.InvestigatorName}`);
                    if (fields.Date && trial.Date) lines.push(`D: ${new Date(trial.Date).toLocaleDateString()}`);
                    if (fields.Dosage && trial.Dosage) lines.push(`Dos: ${trial.Dosage}`);
                    if (fields.Location && trial.Location) lines.push(`Loc: ${trial.Location}`);
                    if (fields.WeedSpecies && trial.WeedSpecies) lines.push(`W: ${trial.WeedSpecies}`);
                    if (fields.Weather) {
                        const weather = `T:${trial.Temperature || '-'}C H:${trial.Humidity || '-'}%`;
                        lines.push(`Wth: ${weather}`);
                    }
                    if (fields.Result && trial.Result) lines.push(`Res: ${trial.Result}`);

                    return lines.join('\n');
                }
            }

            async function handleFormSubmit(form) {
                if (!form) return;
                const formId = form.getAttribute('id');
                const type = formId.replace('-form', '');

                if (formId === 'settings-form') { handleSettingsSave(form); return; }
                if (formId === 'ai-form') { handleAiQuery(document.getElementById('ai-input').value); return; }
                if (formId === 'organise-form') { handleOrganiseSubmit(form); return; }
                if (formId === 'photo-edit-form') { handlePhotoEditSubmit(form); return; }

                const id = form.querySelector('input[name="id"]')?.value || null;
                const isUpdate = !!id;
                const action = isUpdate ? `update${type.charAt(0).toUpperCase() + type.slice(1)}` : `add${type.charAt(0).toUpperCase() + type.slice(1)}`;
                const formData = Object.fromEntries(new FormData(form));

                try {
                    let recordForApi;
                    if (type === 'formulation') {
                        const ingredients = [...document.querySelectorAll('.formulation-ingredient-row')].map(r => ({ id: r.querySelector('.ingredient-selector').value, name: r.querySelector('.ingredient-selector').selectedOptions[0].text, quantity: r.querySelector('.ingredient-quantity').value, unit: r.querySelector('.ingredient-unit-selector').value })).filter(r => r.id);
                        if (ingredients.length === 0) throw new Error('A formulation must have at least one ingredient.');
                        recordForApi = { ID: id, Name: formData.name, Notes: formData.notes, IngredientsJSON: JSON.stringify(ingredients), EstimatedCost: calculateFormulationCost(ingredients) };
                    } else if (type === 'trial') {
                        const formulation = state.formulations.find(f => f.ID === formData.formulationId);
                        if (!formulation) throw new Error('Please select a valid formulation.');
                        showToast('Uploading photos...', 'success');
                        const photosToUpload = isUpdate ? state.croppedPhotosData.filter(p => !p.isExisting) : state.croppedPhotosData;
                        const existingPhotos = isUpdate ? state.croppedPhotosData.filter(p => p.isExisting) : [];
                        const uploadedNewPhotos = await uploadPhotos(photosToUpload);
                        const photoURLsForPayload = [...existingPhotos, ...uploadedNewPhotos];
                        const controlFinalized = form.querySelector('#control-finalized').checked;
                        const isCompleted = form.querySelector('#is-completed').checked;
                        let finalizationDate = formData.finalizationDate || null;
                        let finalControlDuration = formData.finalControlDuration !== '' ? parseInt(formData.finalControlDuration, 10) : null;
                        if (controlFinalized && (finalControlDuration == null || !finalizationDate)) {
                            finalizationDate = finalizationDate || new Date().toISOString().split('T')[0];
                            const trialDate = formData.date;
                            if (finalControlDuration == null && trialDate) {
                                const days = Math.floor((new Date(finalizationDate) - new Date(trialDate)) / (1000 * 60 * 60 * 24));
                                finalControlDuration = days < 0 ? 0 : days;
                            }
                        }
                        const efficacyData = collectEfficacyDataFromModal();
                        const efficacyDataJSON = JSON.stringify(efficacyData);
                        let aiSummariesJSON = isUpdate ? state.trials.find(t => t.ID === id)?.AISummariesJSON || '{}' : '{}';
                        if (isUpdate) {
                            const originalTrial = state.trials.find(t => t.ID === id);
                            if (originalTrial && originalTrial.EfficacyDataJSON !== efficacyDataJSON) {
                                aiSummariesJSON = '{}'; // Invalidate summaries if efficacy data changed
                            }
                        }

                        recordForApi = {
                            ID: id, InvestigatorName: formData.investigatorName, Location: formData.location, FormulationID: formData.formulationId, FormulationName: formulation.Name, Dosage: formData.dosage,
                            Replication: formData.replication,
                            WeedSpecies: formData.weedSpecies || '', Date: formData.date, Result: formData.result, Conclusion: formData.conclusion, Notes: formData.notes,
                            Temperature: formData.temperature, Humidity: formData.humidity, Windspeed: formData.windspeed, Rain: formData.rain,
                            PhotoURLs: JSON.stringify(photoURLsForPayload.map(({ fileData, ...rest }) => rest)),
                            ControlFinalized: controlFinalized,
                            FinalControlDuration: controlFinalized ? finalControlDuration : null,
                            FinalizationDate: controlFinalized ? finalizationDate : null,
                            IsCompleted: isCompleted,
                            EfficacyDataJSON: efficacyDataJSON,
                            AISummariesJSON: aiSummariesJSON
                        };
                    } else if (type === 'ingredient') {
                        // Explicitly get values to ensure correctness and redundant payload
                        const name = form.querySelector('[name="name"]').value.trim();
                        const cost = parseFloat(form.querySelector('[name="cost"]').value);
                        const unit = form.querySelector('[name="unit"]').value;
                        recordForApi = {
                            ID: id,
                            Name: name, name: name, // Send both cases to ensure backend compatibility
                            Cost: cost, cost: cost,
                            Unit: unit, unit: unit
                        };
                    } else {
                        throw new Error(`Unknown form type: ${type}`);
                    }

                    closeModal();
                    showToast(`${type.charAt(0).toUpperCase() + type.slice(1)} saved! Syncing...`);
                    const savedRecordResponse = await apiCall(action, recordForApi, false);
                    const savedRecord = (savedRecordResponse && savedRecordResponse.record) ? savedRecordResponse.record : savedRecordResponse;
                    if (!savedRecord || !savedRecord.ID) {
                        throw new Error('Server sync failed. Response was invalid.');
                    }

                    await initializeApp(false);
                    showToast(`${type.charAt(0).toUpperCase() + type.slice(1)} saved successfully!`, 'success');

                    // Use switchPage to ensure we land on the right page, but for trials we need to maintain filters
                    if (type === 'trial') {
                        applyFilters(); // Refresh filtered list without resetting state
                    } else {
                        switchPage(state.currentPage);
                    }

                } catch (error) {
                    console.error(`Save failed for ${type}:`, error);
                    showToast(`Save failed: ${error.message}. Please try again.`, 'error');
                    await initializeApp(false);
                    switchPage(state.currentPage);
                }
            }

            function populateForm(form, data) {
                if (!form) return;
                const formId = form.getAttribute('id');
                if (form.querySelector('input[name="id"]') && data.ID) {
                    form.querySelector('input[name="id"]').value = data.ID;
                }
                if (formId === 'trial-form') {
                    form.querySelector('[name="investigatorName"]').value = data.InvestigatorName || '';
                    const formulationSelect = form.querySelector('[name="formulationId"]');
                    formulationSelect.innerHTML = state.formulations.map(f => `<option value="${f.ID}">${sanitizeHTML(f.Name)}</option>`).join('');
                    formulationSelect.value = data.FormulationID || '';
                    form.querySelector('[name="location"]').value = data.Location || '';
                    form.querySelector('[name="dosage"]').value = data.Dosage || '';
                    form.querySelector('[name="replication"]').value = data.Replication || '';
                    form.querySelector('[name="weedSpecies"]').value = data.WeedSpecies || '';
                    const trialDate = new Date(data.Date).toISOString().split('T')[0];
                    form.querySelector('[name="date"]').value = trialDate;
                    form.querySelector('#photo-date').value = trialDate;
                    form.querySelector('[name="result"]').value = data.Result || '';
                    form.querySelector('[name="conclusion"]').value = data.Conclusion || '';
                    form.querySelector('[name="notes"]').value = data.Notes || '';
                    form.querySelector('[name="temperature"]').value = data.Temperature || '';
                    form.querySelector('[name="humidity"]').value = data.Humidity || '';
                    form.querySelector('[name="windspeed"]').value = data.Windspeed || '';
                    form.querySelector('[name="rain"]').value = data.Rain || '';
                    form.querySelector('#is-completed').checked = String(data.IsCompleted).toLowerCase() === 'true';
                    const controlCheckbox = form.querySelector('#control-finalized');
                    const isFinalized = String(data.ControlFinalized).toLowerCase() === 'true';
                    controlCheckbox.checked = isFinalized;
                    if (isFinalized) {
                        form.querySelector('#finalization-details').classList.remove('hidden');
                        form.querySelector('#finalization-date').value = data.FinalizationDate ? new Date(data.FinalizationDate).toISOString().split('T')[0] : '';
                        form.querySelector('#final-control-duration').value = data.FinalControlDuration != null ? data.FinalControlDuration : '';
                    } else {
                        form.querySelector('#finalization-details').classList.add('hidden');
                    }

                    let efficacyData = safeJsonParse(data.EfficacyDataJSON);
                    // Backwards compatibility for old data format
                    if (efficacyData.length > 0 && efficacyData.some(d => d.cover !== undefined && d.weedDetails === undefined)) {
                        efficacyData.forEach(obs => {
                            obs.weedDetails = [{ species: data.WeedSpecies || 'Unknown', cover: obs.cover, status: '', notes: '' }];
                            delete obs.cover;
                        });
                    }
                    renderEfficacyObservations(efficacyData);

                    state.croppedPhotosData = safeJsonParse(data.PhotoURLs).map(p => ({ ...p, fileData: p.url, isExisting: true }));
                    updatePhotoPreview();
                } else if (formId === 'formulation-form') {
                    form.querySelector('[name="name"]').value = data.Name;
                    form.querySelector('[name="notes"]').value = data.Notes || '';
                    const ingredients = safeJsonParse(data.IngredientsJSON);
                    document.getElementById('formulation-ingredients-container').innerHTML = '';
                    ingredients.forEach(ing => addFormulationIngredientRow(ing));
                    updateFormulationCost();
                } else if (formId === 'ingredient-form') {
                    form.querySelector('[name="name"]').value = data.Name;
                    form.querySelector('[name="cost"]').value = data.Cost;
                    form.querySelector('[name="unit"]').value = data.Unit;
                }
            }

            // --- EFFICACY & OBSERVATION LOGIC ---
            function addWeedCoverRow(observationCard, data = {}) {
                const container = observationCard.querySelector('.weed-details-container');
                if (!container) return;
                const row = document.createElement('div');
                row.className = 'weed-details-row grid grid-cols-1 md:grid-cols-4 gap-2 items-center';
                row.innerHTML = `
                    <input type="text" class="p-1 border rounded-md text-xs form-input weed-species" placeholder="Weed Species" value="${sanitizeHTML(data.species || '')}">
                    <input type="number" step="any" min="0" max="100" class="p-1 border rounded-md text-xs form-input weed-cover" placeholder="% Cover" value="${sanitizeHTML(data.cover || '')}">
                    <select class="p-1 border rounded-md text-xs form-input bg-white weed-status">
                        <option value="">Status...</option>
                        <option ${data.status === 'Controlled' ? 'selected' : ''}>Controlled</option>
                        <option ${data.status === 'Burndown' ? 'selected' : ''}>Burndown</option>
                        <option ${data.status === 'Re-emerged' ? 'selected' : ''}>Re-emerged</option>
                        <option ${data.status === 'Resistant' ? 'selected' : ''}>Resistant</option>
                        <option ${data.status === 'Unaffected' ? 'selected' : ''}>Unaffected</option>
                    </select>
                    <div class="flex items-center gap-1">
                        <input type="text" class="p-1 border rounded-md text-xs form-input weed-notes flex-grow" placeholder="Notes" value="${sanitizeHTML(data.notes || '')}">
                        <button type="button" data-action="remove-weed-cover" class="text-red-500 font-semibold p-1">&times;</button>
                    </div>
                `;
                container.appendChild(row);
                row.querySelector('.weed-status').value = data.status || '';
            }

            function addObservation(data = {}) {
                const container = document.getElementById('efficacy-observations-container');
                if (!container) return;
                const index = container.querySelectorAll('.observation-card').length;
                const card = document.createElement('div');
                card.className = 'observation-card border p-4 rounded-lg bg-white space-y-3';
                card.dataset.obsIndex = String(index);
                card.innerHTML = `
                    <div class="flex justify-between items-center">
                        <h5 class="font-semibold text-gray-700">Observation</h5>
                        <button type="button" data-action="remove-observation" class="text-red-500 hover:text-red-700 font-bold">&times;</button>
                    </div>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                        <div>
                            <label class="block text-xs font-medium text-gray-600">Observation Date</label>
                            <input type="date" class="p-2 border rounded-md text-sm w-full form-input obs-date">
                        </div>
                        <div>
                            <label class="block text-xs font-medium text-gray-600">DA-A (auto)</label>
                            <input type="number" class="p-2 border rounded-md text-sm w-full form-input obs-daa bg-slate-100" placeholder="Days After App." readonly>
                        </div>
                        <div>
                            <label class="block text-xs font-medium text-gray-600">% Phytotoxicity</label>
                            <input type="number" step="any" min="0" max="100" class="p-2 border rounded-md text-sm w-full form-input obs-phyto" placeholder="0-100">
                        </div>
                    </div>
                    <div>
                        <h6 class="text-sm font-medium text-gray-700 mt-2">Weed Status Details</h6>
                        <div class="weed-details-container space-y-2 mt-1">
                            <!-- Weed cover rows will be added here -->
                        </div>
                        <button type="button" data-action="add-weed-cover" class="mt-2 text-xs text-teal-600 hover:text-teal-800 font-semibold flex items-center gap-1"><i data-lucide="plus" class="h-3 w-3"></i> Add Weed Detail</button>
                    </div>
                    <div>
                        <label class="block text-xs font-medium text-gray-600">General Notes</label>
                        <textarea rows="2" class="p-2 border rounded-md text-sm w-full form-input obs-notes" placeholder="General observation notes..."></textarea>
                    </div>
                `;
                container.appendChild(card);

                // Populate card with data if provided
                card.querySelector('.obs-date').value = data.date ? new Date(data.date).toISOString().split('T')[0] : '';
                card.querySelector('.obs-daa').value = data.daa || '';
                card.querySelector('.obs-phyto').value = data.phyto || '';
                card.querySelector('.obs-notes').value = data.notes || '';
                if (data.weedDetails && data.weedDetails.length > 0) {
                    data.weedDetails.forEach(detail => addWeedCoverRow(card, detail));
                } else {
                    addWeedCoverRow(card); // Add one default empty row
                }

                lucide.createIcons();

                const dateInput = card.querySelector('.obs-date');
                const daaInput = card.querySelector('.obs-daa');
                const trialDateInput = document.getElementById('trial-date');

                const calculateDaa = () => {
                    if (dateInput.value && trialDateInput.value) {
                        const obsDate = new Date(dateInput.value);
                        const trialDate = new Date(trialDateInput.value);
                        const diffTime = obsDate.getTime() - trialDate.getTime();
                        const diffDays = Math.round(diffTime / (1000 * 60 * 60 * 24));
                        daaInput.value = String(diffDays >= 0 ? diffDays : 0);
                    } else {
                        daaInput.value = '';
                    }
                };

                const rebindTrialDateListener = () => {
                    const allTrialDateInputs = document.querySelectorAll('#trial-date');
                    allTrialDateInputs.forEach(input => {
                        input.removeEventListener('change', updateAllDaa);
                        input.addEventListener('change', updateAllDaa);
                    });
                };

                const updateAllDaa = () => {
                    document.querySelectorAll('.observation-card').forEach(c => {
                        const odi = c.querySelector('.obs-date');
                        const tdi = document.getElementById('trial-date');
                        const dai = c.querySelector('.obs-daa');
                        if (odi.value && tdi.value) {
                            const obsDate = new Date(odi.value);
                            const trialDate = new Date(tdi.value);
                            const diffTime = obsDate.getTime() - trialDate.getTime();
                            const diffDays = Math.round(diffTime / (1000 * 60 * 60 * 24));
                            dai.value = String(diffDays >= 0 ? diffDays : 0);
                        }
                    });
                };

                dateInput.addEventListener('change', calculateDaa);
                rebindTrialDateListener();

                if (index === 0 && !data.date) {
                    dateInput.value = trialDateInput.value;
                }
                calculateDaa(); // Calculate on creation
            }

            function renderEfficacyObservations(observations) {
                const container = document.getElementById('efficacy-observations-container');
                if (!container) return;
                container.innerHTML = '';
                if (observations && observations.length > 0) {
                    observations.forEach(obs => addObservation(obs));
                } else {
                    addObservation(); // Add one empty observation if none exist
                }
            }

            function collectEfficacyDataFromModal() {
                const data = [];
                document.querySelectorAll('#trial-modal .observation-card').forEach(card => {
                    const date = card.querySelector('.obs-date').value;
                    const daa = card.querySelector('.obs-daa').value;
                    const phyto = card.querySelector('.obs-phyto').value;
                    const notes = card.querySelector('.obs-notes').value;

                    const weedDetails = [];
                    card.querySelectorAll('.weed-details-row').forEach(row => {
                        const species = row.querySelector('.weed-species').value;
                        const cover = row.querySelector('.weed-cover').value;
                        const status = row.querySelector('.weed-status').value;
                        const detailNotes = row.querySelector('.weed-notes').value;

                        if (species || cover || status || detailNotes) {
                            weedDetails.push({
                                species: species.trim(),
                                cover: cover ? parseFloat(cover) : null,
                                status,
                                notes: detailNotes.trim()
                            });
                        }
                    });

                    // Only add the observation if it has any meaningful data
                    if (date || daa || phyto || notes || weedDetails.some(wd => wd.species || wd.cover != null)) {
                        data.push({
                            date,
                            daa: daa ? parseInt(daa, 10) : null,
                            phyto: phyto ? parseFloat(phyto) : null,
                            notes: notes.trim(),
                            weedDetails
                        });
                    }
                });
                return data;
            }

            // --- PHOTO & CAMERA HANDLING ---
            function handlePhotoSelection(event, trialId = null) {
                state.photoQueue = [...event.target.files];
                if (state.photoQueue.length > 0) processPhotoQueue(trialId);
            }

            function processPhotoQueue(trialId) {
                if (state.photoQueue.length === 0) return;
                const file = state.photoQueue.shift();
                const reader = new FileReader();
                reader.onload = e => openCropper(e.target.result, trialId);
                reader.readAsDataURL(file);
            }

            function openCropper(imageData, trialId) {
                state.currentTrialIdForCamera = trialId;
                imageToCrop.src = imageData;
                cropperModal.style.display = 'block';
                if (cropper) cropper.destroy();
                cropper = new Cropper(imageToCrop, { viewMode: 0, autoCrop: false, background: false, movable: true, zoomable: true, scalable: true, rotatable: true });
            }

            function closeCropper() {
                if (cropper) cropper.destroy();
                cropper = null;
                cropperModal.style.display = 'none';
                if (state.photoQueue.length > 0) processPhotoQueue(state.currentTrialIdForCamera);
                else state.currentTrialIdForCamera = null;
            }

            async function cropAndSaveImage() {
                const croppedImageData = cropper.getCroppedCanvas().toDataURL('image/jpeg', 1.0);
                const trialId = state.currentTrialIdForCamera;
                const currentCameraMode = state.cameraMode; // Save the mode before it could be changed
                closeCropper();

                const form = document.getElementById('trial-form');
                let photoDate = form ? form.querySelector('#photo-date').value : new Date().toISOString().split('T')[0];

                const photoData = {
                    fileData: croppedImageData,
                    fileName: `cropped_${Date.now()}.jpg`,
                    mimeType: 'image/jpeg',
                    label: '',
                    date: photoDate,
                    weather: null,
                    tempId: `photo_${Date.now()}`
                };

                if (trialId) {
                    // IMPORTANT: ADD TO SYNC QUEUE IMMEDIATELY
                    const syncItem = {
                        id: `sync_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
                        trialId: trialId,
                        photo: photoData,
                        type: currentCameraMode === 'weed' ? 'weed_upload' : 'general_upload',
                        status: 'pending',
                        attempts: 0,
                        lastError: null
                    };

                    // Add to global sync queue
                    state.syncQueue.push(syncItem);
                    saveSyncQueue();

                    // Immediate Update: Add to local state for instant visibility
                    const trial = state.trials.find(t => t.ID === trialId);
                    if (trial) {
                        if (currentCameraMode === 'weed') {
                            const weedPhotos = safeJsonParse(trial.WeedPhotosJSON);
                            weedPhotos.push({
                                url: '', // No URL yet
                                tempId: syncItem.photo.tempId,
                                fileData: syncItem.photo.fileData, // Local preview
                                date: syncItem.photo.date,
                                identifications: null, // Loading indicator
                                label: "Processing..."
                            });
                            trial.WeedPhotosJSON = JSON.stringify(weedPhotos);
                        } else {
                            const generalPhotos = safeJsonParse(trial.PhotoURLs);
                            generalPhotos.push({
                                url: '',
                                tempId: syncItem.photo.tempId,
                                fileData: syncItem.photo.fileData, // Local preview
                                date: syncItem.photo.date,
                                label: "Processing...",
                                weather: null
                            });
                            trial.PhotoURLs = JSON.stringify(generalPhotos);
                        }
                    }

                    // Refresh UI immediately
                    const modal = document.getElementById('weed-modal');
                    if (modal && currentCameraMode === 'weed') {
                        const trialData = state.trials.find(t => t.ID === trialId);
                        document.getElementById('weed-photo-grid').innerHTML = safeJsonParse(trialData.WeedPhotosJSON).map((p, i) => render.weedPhotoCard(p, trialId, i)).join('');
                    } else {
                        applyFilters(); // Re-render trial cards
                    }

                    // Trigger Background Sync
                    processSyncQueue();
                } else { // Adding from inside the main trial modal
                    state.croppedPhotosData.push(photoData);
                    updatePhotoPreview();
                }
                state.cameraMode = 'general'; // Reset after async operations complete
            }

            async function openCamera(trialId = null) {
                state.currentTrialIdForCamera = trialId;
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) return showToast("Camera not supported on this browser.", "error");
                try {
                    cameraStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
                    videoElement.srcObject = cameraStream;
                    cameraModal.classList.remove('hidden');
                    cameraModal.style.display = 'flex'; // FORCE FLEX for centering
                } catch (err) {
                    console.error("Camera Error:", err);
                    showToast("Could not access camera. Check browser permissions.", 'error');
                    state.currentTrialIdForCamera = null;
                }
            }

            function closeCamera() {
                if (cameraStream) { cameraStream.getTracks().forEach(track => track.stop()); }
                cameraModal.style.display = 'none';
            }

            function capturePhoto() {
                canvasElement.width = videoElement.videoWidth;
                canvasElement.height = videoElement.videoHeight;
                canvasElement.getContext('2d').drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);
                closeCamera();
                openCropper(canvasElement.toDataURL('image/jpeg', 1.0), state.currentTrialIdForCamera);
            }

            function updatePhotoPreview() {
                const previewContainer = document.getElementById('photo-preview'); if (!previewContainer) return;
                previewContainer.innerHTML = state.croppedPhotosData.map((data, index) => {
                    const imgSrc = data.fileData || data.url;
                    if (!imgSrc) return '';
                    const displaySrc = imgSrc.startsWith('data:image') ? imgSrc : `https://images.weserv.nl/?url=${encodeURIComponent(imgSrc)}&w=100&h=100&fit=crop`;

                    const task = state.backgroundQueue.get(data.tempId);
                    let statusIndicator = '';
                    if (task) {
                        if (task.status === 'processing') statusIndicator = `<div class="absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center text-white text-xs animate-pulse">Analyzing...</div>`;
                        if (task.status === 'error') statusIndicator = `<div class="absolute inset-0 bg-red-500 bg-opacity-70 flex items-center justify-center text-white text-xs font-bold">Failed</div>`;
                    }

                    return `<div class="relative group">
                        <img src="${displaySrc}" class="h-24 w-24 object-cover rounded-md border">
                        <input type="text" data-index="${index}" class="photo-label-input absolute bottom-0 left-0 w-full text-xs p-1 bg-black bg-opacity-50 text-white" placeholder="Label..." value="${sanitizeHTML(data.label) || ''}">
                        <button data-action="remove-photo" data-index="${index}" class="absolute top-0 right-0 bg-red-500 text-white rounded-full h-5 w-5 flex items-center justify-center text-xs font-bold opacity-0 group-hover:opacity-100 transition-opacity">&times;</button>
                        ${statusIndicator}
                    </div>`;
                }).join('');
            }

            // --- QR CODE LOGIC ---
            function openQrLabel(trialId) {
                const trial = state.trials.find(t => t.ID === trialId);
                if (!trial) return;
                openModal('qrLabel', false, { trial });
                setTimeout(() => {
                    new QRCode(document.getElementById("qr-code-canvas"), {
                        text: trial.ID,
                        width: 200,
                        height: 200,
                        colorDark: "#000000",
                        colorLight: "#ffffff",
                        correctLevel: QRCode.CorrectLevel.H
                    });
                }, 50);
            }

            async function openQrScanner() {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    return showToast("Camera not supported on this browser.", "error");
                }
                try {
                    qrScannerModal.classList.remove('hidden');
                    qrStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
                    qrVideo.srcObject = qrStream;
                    startPlotScanning();
                } catch (err) {
                    console.error("QR Scanner Camera Error:", err);
                    showToast("Could not access camera for scanning.", 'error');
                    qrScannerModal.classList.add('hidden');
                }
            }

            function closeQrScanner() {
                if (qrStream) { qrStream.getTracks().forEach(track => track.stop()); }
                if (qrAnimationFrame) cancelAnimationFrame(qrAnimationFrame);
                qrScannerModal.classList.add('hidden');
            }

            function startPlotScanning() {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');

                const scanLoop = () => {
                    if (qrVideo.readyState === qrVideo.HAVE_ENOUGH_DATA) {
                        canvas.height = qrVideo.videoHeight;
                        canvas.width = qrVideo.videoWidth;
                        context.drawImage(qrVideo, 0, 0, canvas.width, canvas.height);
                        const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
                        const code = jsQR(imageData.data, imageData.width, imageData.height, {
                            inversionAttempts: "dontInvert",
                        });

                        if (code) {
                            const detectedId = code.data;
                            const trial = state.trials.find(t => t.ID === detectedId);
                            if (trial) {
                                showToast(`Plot recognized: ${trial.FormulationName}`, 'success');
                                closeQrScanner();
                                openTrialDetail(trial.ID);
                                return;
                            }
                        }
                    }
                    qrAnimationFrame = requestAnimationFrame(scanLoop);
                };
                qrAnimationFrame = requestAnimationFrame(scanLoop);
            }

            // --- SPECIFIC FEATURE LOGIC (FORMULATIONS, TRIALS, AI, ETC.) ---
            function addFormulationIngredientRow(ingredient = null) {
                const container = document.getElementById('formulation-ingredients-container'); if (!container) return;
                const opts = state.ingredients.map(ing => `<option value="${ing.ID}">${sanitizeHTML(ing.Name)}</option>`).join('');
                const row = document.createElement('div'); row.className = 'flex items-center space-x-2 formulation-ingredient-row';
                row.innerHTML = `<select class="ingredient-selector flex-grow p-2 border rounded-md bg-white form-input"><option value="">Select ingredient</option>${opts}</select><input type="number" step="any" class="ingredient-quantity w-24 p-2 border rounded-md form-input" placeholder="Qty"><select class="ingredient-unit-selector w-20 p-2 border rounded-md bg-white form-input"><option>ml</option><option>L</option><option>gm</option><option>kg</option></select><button type="button" data-action="remove-ingredient-row" class="text-red-500 font-bold">&times;</button>`;
                container.appendChild(row);
                if (ingredient) { row.querySelector('.ingredient-selector').value = ingredient.id; row.querySelector('.ingredient-quantity').value = ingredient.quantity; row.querySelector('.ingredient-unit-selector').value = ingredient.unit; }
            }

            function updateFormulationCost() {
                const ingredients = [...document.querySelectorAll('.formulation-ingredient-row')].map(r => { const selector = r.querySelector('.ingredient-selector'); if (!selector || selector.value === "") return null; return { id: selector.value, quantity: r.querySelector('.ingredient-quantity').value, unit: r.querySelector('.ingredient-unit-selector').value }; }).filter(Boolean);
                document.getElementById('formulation-total-cost').textContent = `${CURRENCY_SYMBOL}${calculateFormulationCost(ingredients).toFixed(2)}`;
            }

            function calculateFormulationCost(ingredients) {
                if (!ingredients || !state.ingredients) return 0;
                return ingredients.reduce((acc, currentIng) => {
                    const details = state.ingredients.find(i => i.ID === currentIng.id);
                    if (!details) return acc;
                    const baseCost = parseFloat(details.Cost);
                    const baseUnit = details.Unit.toLowerCase();
                    let usedQuantity = parseFloat(currentIng.quantity) || 0;
                    const usedUnit = currentIng.unit.toLowerCase();
                    if (isNaN(baseCost) || isNaN(usedQuantity)) return acc;
                    let quantityInBaseUnit = usedQuantity;
                    if (baseUnit === 'l' && usedUnit === 'ml') quantityInBaseUnit /= 1000;
                    else if (baseUnit === 'ml' && usedUnit === 'l') quantityInBaseUnit *= 1000;
                    else if (baseUnit === 'kg' && usedUnit === 'gm') quantityInBaseUnit /= 1000;
                    else if (baseUnit === 'gm' && usedUnit === 'kg') quantityInBaseUnit *= 1000;
                    return acc + (baseCost * quantityInBaseUnit);
                }, 0);
            }

            // --- BACKGROUND PROCESSING & AI ---
            async function analyzePhotoForEfficacy(fileData, mimeType) {
                try {
                    if (!fileData || typeof fileData !== 'string' || !fileData.includes(',')) {
                        throw new Error("Invalid image data provided for analysis.");
                    }
                    const prompt = `As an agricultural expert analyzing a photo from a herbicide trial, provide your best estimate for the following metrics. For weedStatus, identify up to 2 dominant weed species visible and describe their status. Respond ONLY with a single minified JSON object in this exact format: {"percentPhytotoxicity": NUMBER, "weedDetails": [{"species": "...", "cover": NUMBER, "status": "Controlled|Burndown|Re-emerged|Resistant|Unaffected", "notes": "..."}]}.
                    - "percentPhytotoxicity": Estimate the visible damage (discoloration, necrosis, wilting) to the weeds as a percentage (0-100).
                    - "weedDetails": An array of objects.
                    - "species": The scientific or common name of the weed.
                    - "cover": Estimate the percentage of the ground covered by this specific weed species (0-100).
                    - "status": The observed condition of the weed.
                    - "notes": A brief qualitative observation.`;

                    const geminiCall = (genAI) => genAI.models.generateContent({
                        model: state.settings.apiModel || 'gemini-2.5-flash-lite',
                        contents: [{ parts: [{ text: prompt }, { inlineData: { mimeType: mimeType, data: fileData.split(',')[1] } }] }],
                        config: {
                            responseMimeType: "application/json",
                            responseSchema: {
                                type: Type.OBJECT,
                                properties: {
                                    percentPhytotoxicity: { type: Type.NUMBER },
                                    weedDetails: {
                                        type: Type.ARRAY,
                                        items: {
                                            type: Type.OBJECT,
                                            properties: {
                                                species: { type: Type.STRING },
                                                cover: { type: Type.NUMBER },
                                                status: { type: Type.STRING },
                                                notes: { type: Type.STRING }
                                            },
                                            required: ["species", "cover", "status", "notes"]
                                        }
                                    }
                                },
                                required: ["percentPhytotoxicity", "weedDetails"]
                            }
                        }
                    });

                    const response = await callGeminiApi('Analyzing photo for efficacy', geminiCall);
                    const parsed = JSON.parse(response.text);
                    return {
                        phyto: parsed.percentPhytotoxicity || 0,
                        weedDetails: parsed.weedDetails || []
                    };
                } catch (error) {
                    console.error('Efficacy analysis via Gemini failed:', error);
                    if (error.message === 'ALL_KEYS_EXHAUSTED' || error.message.includes('quota')) {
                        throw new Error('QUOTA_EXCEEDED');
                    }
                    showToast(`Efficacy analysis failed: ${error.message}`, 'error');
                    return null;
                }
            }

            async function identifyWeedsFromPhoto(fileData, mimeType) {
                try {
                    if (!fileData || typeof fileData !== 'string' || !fileData.includes(',')) {
                        throw new Error("Invalid image data provided for identification.");
                    }
                    const prompt = `You are an expert botanist specializing in weed identification for agriculture. Analyze this photo and identify ALL visible weed species. For EACH different weed species you can see:
1. Provide the scientific name
2. List common names
3. Give a confidence score (0-1) for your identification
4. Categorize the growth stage

IMPORTANT: Identify EVERY distinct weed species visible in the photo, not just the most prominent one. List them all in the identifications array.

Respond ONLY with a single minified JSON object in this format: {"identifications": [{"name": "Scientific Name", "commonNames": ["Common Name 1", ...], "confidence": 0.95, "growthStage": "Seedling|Vegetative|Flowering|Mature"}]}`;

                    const geminiCall = (genAI) => genAI.models.generateContent({
                        model: state.settings.apiModel || 'gemini-2.5-flash-lite',
                        contents: [{ parts: [{ text: prompt }, { inlineData: { mimeType: mimeType, data: fileData.split(',')[1] } }] }],
                        config: {
                            responseMimeType: "application/json",
                            responseSchema: {
                                type: Type.OBJECT,
                                properties: {
                                    identifications: {
                                        type: Type.ARRAY,
                                        items: {
                                            type: Type.OBJECT,
                                            properties: {
                                                name: { type: Type.STRING },
                                                commonNames: { type: Type.ARRAY, items: { type: Type.STRING } },
                                                confidence: { type: Type.NUMBER },
                                                growthStage: { type: Type.STRING }
                                            },
                                            required: ["name", "commonNames", "confidence", "growthStage"]
                                        }
                                    }
                                },
                                required: ["identifications"]
                            }
                        }
                    });

                    const response = await callGeminiApi('Identifying weeds from photo', geminiCall);
                    console.log('Weed identification raw response:', response);

                    // Handle different response formats from the SDK
                    let resultText = '';
                    if (typeof response === 'string') {
                        resultText = response;
                    } else if (response?.text) {
                        resultText = typeof response.text === 'function' ? response.text() : response.text;
                    } else if (response?.candidates?.[0]?.content?.parts?.[0]?.text) {
                        resultText = response.candidates[0].content.parts[0].text;
                    }

                    console.log('Weed identification result text:', resultText);

                    if (!resultText) {
                        console.warn('Empty response from weed identification');
                        return [];
                    }

                    // Clean up the response text
                    const cleanedText = resultText.replace(/```json/g, '').replace(/```/g, '').trim();
                    const parsed = JSON.parse(cleanedText);
                    console.log('Weed identification parsed:', parsed);

                    return parsed.identifications || parsed.results || [];
                } catch (error) {
                    console.error('Weed identification via Gemini failed:', error);
                    showToast(`Weed identification failed: ${error.message}`, 'error');
                    return [];
                }
            }

            async function uploadPhotos(photosData) {

                if (!photosData || photosData.length === 0) return [];
                const results = [];
                for (const photoData of photosData) {
                    try {
                        const result = await apiCall('uploadPhoto', {
                            fileData: photoData.fileData,
                            fileName: photoData.fileName,
                            mimeType: photoData.mimeType
                        }, false);
                        results.push(result);
                    } catch (error) {
                        console.error('Photo upload failed for one photo:', error);
                        results.push(null);
                    }
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
                return results.map((result, index) => {
                    if (!result || !result.url) return null;
                    return {
                        ...photosData[index],
                        url: result.url
                    };
                }).filter(Boolean);
            }

            function handleOpenPhotoEditModal(trialId, photoIndex) {
                const trial = state.trials.find(t => t.ID === trialId);
                if (!trial) return;

                const photos = safeJsonParse(trial.PhotoURLs);
                const photo = photos[photoIndex];
                if (!photo) return;

                openModal('photoEdit', true);

                // Defer population slightly to ensure DOM is ready
                setTimeout(() => {
                    const form = document.getElementById('photo-edit-form');
                    if (!form) return;

                    form.querySelector('[name="trialId"]').value = trialId;
                    form.querySelector('[name="photoIndex"]').value = String(photoIndex);
                    form.querySelector('[name="label"]').value = photo.label || '';

                    if (photo.date) {
                        form.querySelector('[name="date"]').value = new Date(photo.date).toISOString().split('T')[0];
                    }

                    if (photo.weather) {
                        form.querySelector('[name="temp"]').value = photo.weather.temp || '';
                        form.querySelector('[name="humidity"]').value = photo.weather.humidity || '';
                        form.querySelector('[name="wind"]').value = photo.weather.wind || '';
                        form.querySelector('[name="rain"]').value = photo.weather.rain || '';
                    }
                }, 50);
            }

            async function processAndAddPhotoObservation(trialId, photosData) {
                console.log('processAndAddPhotoObservation called with:', { trialId, cameraMode: state.cameraMode, photoCount: photosData.length });
                const trialIndex = state.trials.findIndex(t => t.ID === trialId);
                if (trialIndex === -1) return showToast('Error: Could not find the trial.', 'error');

                showToast(`Uploading ${photosData.length} photo(s)...`, 'info');
                const successfulUploads = await uploadPhotos(photosData);
                console.log('Successful uploads:', successfulUploads.length);

                if (successfulUploads.length > 0) {
                    const trial = state.trials[trialIndex];
                    const payload = {};

                    console.log('Camera mode check:', state.cameraMode, state.cameraMode === 'weed' ? 'WEED MODE' : 'GENERAL MODE');
                    if (state.cameraMode === 'weed') {
                        // --- WEED IDENTIFICATION MODE ---
                        console.log('Entering WEED identification mode');
                        let weedPhotos = safeJsonParse(trial.WeedPhotosJSON);
                        const newWeedSpecies = new Set(); // Collect newly identified species

                        for (const photo of successfulUploads) {
                            try {
                                showToast(`Identifying weeds in photo...`, 'info');
                                const identifications = await identifyWeedsFromPhoto(photo.fileData, photo.mimeType);

                                weedPhotos.push({
                                    url: photo.url,
                                    date: photo.date,
                                    identifications: identifications,
                                    label: photo.label || (identifications.length > 0 ? identifications.map(i => i.name).join(', ') : "Unidentified Weed")
                                });

                                // Collect all newly identified species names
                                if (identifications.length > 0) {
                                    identifications.forEach(id => {
                                        if (id.name && id.name.trim()) {
                                            newWeedSpecies.add(id.name.trim());
                                        }
                                        // Also add common names
                                        if (id.commonNames && id.commonNames.length > 0) {
                                            id.commonNames.forEach(cn => {
                                                if (cn && cn.trim()) newWeedSpecies.add(cn.trim());
                                            });
                                        }
                                    });
                                }
                            } catch (err) {
                                console.error("Weed identification failed:", err);
                                weedPhotos.push({
                                    url: photo.url,
                                    date: photo.date,
                                    identifications: [],
                                    label: "Unidentified Weed"
                                });
                            }
                        }
                        payload.WeedPhotosJSON = JSON.stringify(weedPhotos);

                        // Update WeedSpecies field - merge new species with existing (no duplicates)
                        const existingSpecies = (trial.WeedSpecies || '').split(',').map(s => s.trim()).filter(Boolean);
                        const allSpecies = [...new Set([...existingSpecies, ...newWeedSpecies])];
                        if (allSpecies.length > 0) {
                            payload.WeedSpecies = allSpecies.join(', ');
                        }
                    } else {
                        // --- GENERAL EFFICACY MODE ---
                        let currentPhotos = safeJsonParse(trial.PhotoURLs);
                        successfulUploads.forEach(p => currentPhotos.push({ url: p.url, label: p.label, date: p.date, weather: p.weather }));
                        payload.PhotoURLs = JSON.stringify(currentPhotos);

                        // Only auto-analyze if enabled in settings (saves API quota)
                        if (state.settings.autoAnalyzePhotos) {
                            showToast(`Photos added. Analyzing ${successfulUploads.length} photo(s) for efficacy data...`, 'info');

                            let efficacyData = safeJsonParse(trial.EfficacyDataJSON);
                            let aiAnalysisComplete = false;

                            for (const photo of successfulUploads) {
                                try {
                                    const efficacyResult = await analyzePhotoForEfficacy(photo.fileData, photo.mimeType);
                                    if (efficacyResult) {
                                        const observationDate = new Date(photo.date);
                                        const trialDate = new Date(trial.Date);
                                        const daaValue = Math.round((observationDate.getTime() - trialDate.getTime()) / (1000 * 60 * 60 * 24));
                                        const daa = daaValue >= 0 ? daaValue : 0;

                                        efficacyData.push({
                                            date: observationDate.toISOString().split('T')[0],
                                            daa,
                                            phyto: efficacyResult.phyto,
                                            notes: `AI analysis from photo taken on ${observationDate.toLocaleDateString()}`,
                                            photoUrl: photo.url,
                                            weedDetails: efficacyResult.weedDetails,
                                        });
                                        aiAnalysisComplete = true;
                                    }
                                } catch (err) {
                                    showToast(`AI analysis failed for one photo: ${err.message}`, 'error');
                                    if (err.message === 'QUOTA_EXCEEDED') {
                                        showToast('API Quota limit reached. Halting analysis for remaining photos.', 'error');
                                        break;
                                    }
                                }
                            }

                            if (aiAnalysisComplete) {
                                payload.EfficacyDataJSON = JSON.stringify(efficacyData);
                                payload.AISummariesJSON = '{}';
                            }
                        } else {
                            showToast('Photos added. Enable "Auto-Analyze Photos" in Settings for AI efficacy analysis.', 'success');
                        }
                    }

                    const result = await apiCall('updateTrialRecord', { ID: trialId, ...payload }, false);

                    // Handle both response formats: {record: {...}} or direct record {...}
                    const updatedRecord = result?.record || (result?.ID ? result : null);
                    if (updatedRecord) {
                        const updatedTrialIndex = state.trials.findIndex(t => t.ID === trialId);
                        if (updatedTrialIndex > -1) state.trials[updatedTrialIndex] = updatedRecord;

                        if (state.cameraMode === 'weed') {
                            showToast('Weed identification photos saved.', 'success');
                        } else if (payload.EfficacyDataJSON) {
                            showToast('Efficacy data updated. AI summary will be regenerated.', 'success');
                        } else {
                            showToast('Photos saved.', 'success');
                        }

                        applyFilters();
                        if (document.querySelector(`#trial-detail-modal`)) {
                            openTrialDetail(trialId);
                        }
                    } else {
                        console.error('updateTrialRecord response:', result);
                        throw new Error('Failed to save updated trial data to the server. Check console for details.');
                    }
                }
                applyFilters();
            }


            // --- INITIALIZATION ---
            async function initializeApp(showOverlay = true) {
                if (window.__EMBEDDED_STATE__) {
                    state = window.__EMBEDDED_STATE__;
                    showToast('Loaded data from standalone file.', 'success');
                    switchPage(state.currentPage || 'dashboard');
                    window.apiCall = async (action, payload) => {
                        console.log('API calls disabled in standalone mode.', { action, payload });
                        showToast('Functionality limited in offline mode.', 'error');
                        return null;
                    }
                    return;
                }

                if (showOverlay) loadingOverlay.classList.remove('hidden');
                try {
                    loadSettings();
                    if (!state.settings.scriptUrl) {
                        mainContent.innerHTML = `<div class="text-center p-8 bg-white rounded-lg shadow"><p class="text-amber-600 font-semibold">Configuration Needed</p><p class="text-gray-600 mt-2">Please go to Settings to enter your Google Apps Script URL.</p></div>`;
                        switchPage('settings');
                        return;
                    }

                    const allData = await apiCall('getAllData', {}, false);
                    if (allData === null) {
                        mainContent.innerHTML = `<div class="text-center p-8 bg-white rounded-lg shadow"><p class="text-red-500 font-semibold">Could not load app data.</p><p class="text-gray-600 mt-2">Check your connection and Data Source settings. Ensure your script is deployed correctly.</p><div class="mt-4 flex justify-center gap-4"><button onclick="location.reload()" class="bg-blue-600 text-white px-4 py-2 rounded-lg">Retry</button><button onclick="window.switchPageToSettings()" class="bg-gray-600 text-white px-4 py-2 rounded-lg">Go to Settings</button></div></div>`;
                        // Add temporary global helper for the button
                        window.switchPageToSettings = () => { switchPage('settings'); };
                        return;
                    }

                    const normalizeIDs = (arr) => Array.isArray(arr) ? arr.map(item => ({ ...item, ID: String(item.ID || ''), FormulationID: String(item.FormulationID || '') })) : [];
                    state.ingredients = normalizeIDs(allData.ingredients);
                    state.formulations = normalizeIDs(allData.formulations);
                    state.trials = (allData.trials || []).map(t => ({ ...normalizeIDs([t])[0], WeedPhotosJSON: t.WeedPhotosJSON || '[]', EfficacyDataJSON: t.EfficacyDataJSON || '[]', IsCompleted: t.IsCompleted || false, AISummariesJSON: t.AISummariesJSON || '{}' }));
                    state.organisations = normalizeIDs(allData.organisations);
                    injectSyncPlaceholders();
                    switchPage(state.currentPage || 'dashboard');
                    processSyncQueue();
                } catch (error) {
                    console.error("Initialization failed:", error);
                    mainContent.innerHTML = `<div class="text-center p-8 bg-white rounded-lg shadow"><p class="text-red-500 font-semibold">A critical error occurred.</p><p class="text-gray-600 mt-2">Please check the console and refresh. Error: ${error.message}</p></div>`;
                } finally {
                    if (showOverlay) loadingOverlay.classList.add('hidden');
                    lucide.createIcons();
                }
            }

            function loadSettings() {
                const settingsStr = localStorage.getItem('appSettings');
                const defaultSettings = {
                    apiKeys: [],
                    currentApiKeyIndex: 0,
                    scriptUrl: DEFAULT_SCRIPT_URL,
                    sheetId: DEFAULT_SHEET_ID,
                    folderId: DEFAULT_FOLDER_ID,
                    apiModel: 'gemini-1.5-flash-lite',
                    autoAnalyzePhotos: false,
                    showPhotoDates: false,
                    includeTimeline: false,
                    qrCodeFields: { FormulationName: true, InvestigatorName: true, Date: true, Dosage: true, Location: false, Result: false, WeedSpecies: false, Weather: false },
                    qrOnlineFields: { showInvestigator: true, showDate: true, showLocation: true, showDosage: true, showWeedSpecies: true, showResult: true, showWeather: true, showIngredients: false, showConclusion: true, showPhotos: true }
                };

                if (settingsStr) {
                    const parsed = JSON.parse(settingsStr);
                    // Backwards compatibility for old single key format
                    if (parsed.apiKey && !parsed.apiKeys) {
                        parsed.apiKeys = [parsed.apiKey].filter(Boolean);
                        delete parsed.apiKey;
                    }
                    state.settings = { ...defaultSettings, ...parsed };

                    // FORCE FIX: Reset A6 to ID if found (assumes A6 was set by accident due to bad default)
                    if (state.settings.cardSize === 'A6') {
                        state.settings.cardSize = 'ID';
                        localStorage.setItem('appSettings', JSON.stringify(state.settings));
                    }
                    // Default to ID if missing
                    if (!state.settings.cardSize) {
                        state.settings.cardSize = 'ID';
                    }

                    // Ensure apiKeys is an array
                    if (!Array.isArray(state.settings.apiKeys)) {
                        state.settings.apiKeys = [];
                    }
                    // Ensure index is valid
                    if (state.settings.currentApiKeyIndex >= state.settings.apiKeys.length) {
                        state.settings.currentApiKeyIndex = 0;
                    }
                } else {
                    state.settings = defaultSettings;
                    state.settings.cardSize = 'ID'; // Set explicit default for fresh install
                }

                const chat = localStorage.getItem('aiChatHistory');
                state.aiChatHistory = chat ? JSON.parse(chat) : [];

                const savedQueue = localStorage.getItem('syncQueue');
                if (savedQueue) {
                    try {
                        state.syncQueue = JSON.parse(savedQueue);
                        // Reset 'processing' back to 'pending' as the process was interrupted
                        state.syncQueue.forEach(s => { if (s.status === 'processing') s.status = 'pending'; });
                    } catch (e) { console.error("Could not parse saved sync queue", e); }
                }
            }

            async function handleSettingsSave(form) {
                const apiModel = document.getElementById('settings-api-model').value;
                const keyInputs = Array.from(form.querySelectorAll('.api-key-input'));
                const apiKeys = keyInputs.map(input => input.value.trim()).filter(Boolean);

                const scriptUrl = form.querySelector('#script-url').value.trim();
                const sheetIdRaw = form.querySelector('#sheet-url').value.trim();
                const folderIdRaw = form.querySelector('#folder-url').value.trim();

                const sheetId = (sheetIdRaw.match(/[-\w]{25,}/) || [])[0] || state.settings.sheetId;
                const folderId = (folderIdRaw.match(/[-\w]{25,}/) || [])[0] || state.settings.folderId;

                const logoInput = form.querySelector('#settings-logo-hidden');
                const logoBase64 = logoInput ? logoInput.value : state.settings.logoBase64;
                const cardSize = form.querySelector('#settings-card-size').value;

                let needsReload = false;
                if (sheetId && state.settings.sheetId !== sheetId) needsReload = true;
                if (scriptUrl && state.settings.scriptUrl !== scriptUrl) needsReload = true;

                const oldKeyJson = JSON.stringify(state.settings.apiKeys);
                const newKeyJson = JSON.stringify(apiKeys);

                // Update settings object
                const newSettings = {
                    ...state.settings,
                    scriptUrl,
                    sheetId,
                    folderId,
                    logoBase64,
                    cardSize,
                    apiKeys,
                    currentApiKeyIndex: 0,
                    apiModel,
                    autoAnalyzePhotos: document.getElementById('auto-analyze-photos').checked
                };

                // Capture QR fields
                if (newSettings.qrCodeFields) {
                    Object.keys(newSettings.qrCodeFields).forEach(key => {
                        const el = form.querySelector(`[name="qr-${key}"]`);
                        if (el) newSettings.qrCodeFields[key] = el.checked;
                    });
                }
                if (newSettings.qrOnlineFields) {
                    Object.keys(newSettings.qrOnlineFields).forEach(key => {
                        const el = form.querySelector(`[name="qro-${key}"]`);
                        if (el) newSettings.qrOnlineFields[key] = el.checked;
                    });
                }


                state.settings = newSettings;
                localStorage.setItem('appSettings', JSON.stringify(state.settings));

                // CRITICAL: Sync settings to backend so online QR codes reflect current preferences
                try {
                    await apiCall('saveAllSettings', { settings: newSettings });
                    console.log('Settings synced to backend successfully');
                } catch (error) {
                    console.warn('Failed to sync settings to backend:', error);
                    showToast('Settings saved locally, but failed to sync to server. Online QR codes may not reflect changes.', 'warning');
                }

                if (needsReload) {
                    if (confirm('Critical settings changed. Reload app to apply?')) {
                        window.location.reload();
                    }
                } else if (oldKeyJson !== newKeyJson) {
                    showToast('Settings saved. New API keys applied.', 'info');
                } else {
                    showToast('Settings saved successfully.', 'success');
                }

                closeModal();
            }

            async function handleSaveLiveQrSettingsFinal() {
                const form = document.getElementById('live-qr-settings-form');
                if (!form) return;

                const trialId = form.dataset.id;
                if (!trialId) {
                    showToast('Trial ID missing. Cannot save settings.', 'error');
                    return;
                }

                // Collect checkbox states for this individual trial
                const individualSettings = {};
                Object.keys(state.settings.qrOnlineFields).forEach(key => {
                    const checkbox = form.querySelector(`[name="${key}"]`);
                    if (checkbox) {
                        individualSettings[key] = checkbox.checked;
                    }
                });

                // Save to backend
                try {
                    const payload = {
                        id: trialId,
                        LiveQRSettings: JSON.stringify(individualSettings)
                    };

                    await apiCall('saveLiveQrSettings', payload);

                    // Update local state
                    const trialIndex = state.trials.findIndex(t => t.ID === trialId);
                    if (trialIndex !== -1) {
                        state.trials[trialIndex].LiveQRSettings = JSON.stringify(individualSettings);
                    }

                    showToast('Individual QR settings saved for this trial!', 'success');
                    closeModal();
                } catch (error) {
                    console.error('Failed to save live QR settings:', error);
                    showToast('Failed to save QR settings. Please try again.', 'error');
                }
            }

            async function manageBulkAnalysis() {
                if (state.bulkAnalysisState.isRunning && !state.bulkAnalysisState.isPaused) {
                    showToast('An analysis is already in progress.', 'info');
                    return;
                }

                if (!state.bulkAnalysisState.isPaused) {
                    const trialsToProcess = state.trials.filter(trial => {
                        const efficacyData = safeJsonParse(trial.EfficacyDataJSON, []);
                        const summaries = safeJsonParse(trial.AISummariesJSON, {});
                        const photos = safeJsonParse(trial.PhotoURLs, []);

                        const hasEfficacy = efficacyData.length > 0;
                        const hasSummary = Object.keys(summaries).length > 0 && summaries.cover && summaries.phyto;
                        const hasPhotos = photos.length > 0;

                        const needsEfficacyGeneration = hasPhotos && !hasEfficacy;
                        const needsSummaryGeneration = hasEfficacy && !hasSummary;

                        return needsEfficacyGeneration || needsSummaryGeneration;
                    });

                    if (trialsToProcess.length === 0) {
                        showToast('All trials are already fully analyzed.', 'info');
                        return;
                    }

                    state.bulkAnalysisState = {
                        isRunning: true,
                        isPaused: false,
                        lastProcessedIndex: -1,
                        trialsToProcess: trialsToProcess,
                        totalToProcess: trialsToProcess.length,
                    };
                } else { // Resuming
                    state.bulkAnalysisState.isRunning = true;
                    state.bulkAnalysisState.isPaused = false;
                }

                renderBulkAnalysisControls();
                showToast(`Starting AI analysis for ${state.bulkAnalysisState.totalToProcess} trials...`, 'info');

                await runBulkAnalysisLoop();
            }

            async function handleSingleAiGeneration(trialId) {
                const trial = state.trials.find(t => t.ID === trialId);
                if (!trial) return;

                showToast(`Generating AI report for ${trial.FormulationName}...`, 'info');

                try {
                    let efficacyData = safeJsonParse(trial.EfficacyDataJSON, []);
                    let efficacyWasGenerated = false;

                    // Step 1: Generate efficacy from photos if needed
                    if (efficacyData.length === 0) {
                        const photos = safeJsonParse(trial.PhotoURLs, []);
                        if (photos.length > 0) {
                            const newEfficacyObservations = [];
                            for (const photo of photos) {
                                if (!photo.url) continue;
                                const imageData = await getImageAsResizedBase64(photo.url);
                                if (!imageData) continue;

                                const analysisResult = await analyzePhotoForEfficacy(imageData, 'image/jpeg');

                                if (analysisResult) {
                                    const observationDate = new Date(photo.date || trial.Date);
                                    const trialDate = new Date(trial.Date);
                                    const daa = Math.round((observationDate.getTime() - trialDate.getTime()) / (1000 * 60 * 60 * 24));

                                    newEfficacyObservations.push({
                                        date: observationDate.toISOString().split('T')[0],
                                        daa: daa >= 0 ? daa : 0,
                                        phyto: analysisResult.phyto,
                                        notes: `AI analysis from photo on ${observationDate.toLocaleDateString()}`,
                                        photoUrl: photo.url,
                                        weedDetails: analysisResult.weedDetails,
                                    });
                                }
                            }

                            if (newEfficacyObservations.length > 0) {
                                trial.EfficacyDataJSON = JSON.stringify(newEfficacyObservations);
                                efficacyWasGenerated = true;
                            } else {
                                showToast('No analyzable photos found to generate efficacy data.', 'error');
                            }
                        } else {
                            showToast('No photos available to analyze.', 'error');
                        }
                    }

                    // Step 2: Generate summaries if efficacy data exists (either pre-existing or just generated)
                    efficacyData = safeJsonParse(trial.EfficacyDataJSON, []);
                    if (efficacyData.length > 0) {
                        await updateTrialAISummaries(trial.ID, efficacyWasGenerated);
                        showToast('AI report generated successfully!', 'success');
                        applyFilters(); // Refresh UI
                    } else if (efficacyWasGenerated) {
                        // Saved efficacy but failed summary step maybe? 
                        // Just saving trial record in updateTrialAISummaries handles saving, but if we didn't call it...
                        const payload = { id: trial.ID, EfficacyDataJSON: trial.EfficacyDataJSON, AISummariesJSON: '{}' };
                        await apiCall('updateTrialRecord', payload, false);
                        showToast('Efficacy data generated. Summary generation skipped/failed.', 'info');
                        applyFilters();
                    }

                } catch (error) {
                    console.error("Single AI Gen Error:", error);
                    showToast(`Analysis failed: ${error.message}`, 'error');
                }
            }

            async function updateTrialAISummaries(trialId, wasEfficacyGenerated = false) {
                const trialIndex = state.trials.findIndex(t => t.ID === trialId);
                if (trialIndex === -1) return;

                const trial = state.trials[trialIndex];
                let efficacyData = safeJsonParse(trial.EfficacyDataJSON, []);
                if (efficacyData.length === 0) return;

                const currentSummaries = safeJsonParse(trial.AISummariesJSON, {});
                let finalSummaries = { ...currentSummaries };
                let summariesWereUpdated = false;

                // Determine context for AI based on trial completion
                const isFinal = String(trial.IsCompleted).toLowerCase() === 'true' || String(trial.ControlFinalized).toLowerCase() === 'true';
                const status = isFinal ? "Finalized/Completed" : "Ongoing";

                if (!finalSummaries.cover) {
                    const allWeedSpecies = [...new Set(efficacyData.flatMap(obs => (obs.weedDetails || []).map(wc => wc.species.trim())))];
                    const colors = ['#4A90E2', '#D0021B', '#F5A623', '#7ED321', '#50E3C2', '#9013FE'];
                    const coverDatasets = allWeedSpecies.map((species, index) => ({
                        label: species,
                        data: efficacyData.map(obs => { const weed = (obs.weedDetails || []).find(wc => wc.species.trim() === species); return weed ? { x: parseFloat(obs.daa), y: parseFloat(weed.cover) } : null; }).filter(p => p && !isNaN(p.x) && !isNaN(p.y)).sort((a, b) => a.x - b.x),
                        borderColor: colors[index % colors.length], tension: 0.1, fill: false
                    }));
                    const coverConfig = { type: 'line', data: { datasets: coverDatasets }, options: { scales: { x: { type: 'linear' }, y: { beginAtZero: true, max: 100 } } } };
                    const summary = await getChartSummaryFromAI(coverConfig, '% Cover by Species', allWeedSpecies.join(', '), status, trial.Result);
                    finalSummaries.cover = summary;
                    summariesWereUpdated = true;
                }

                if (!finalSummaries.phyto) {
                    const phytoData = { label: '% Phytotoxicity', data: efficacyData.map(d => ({ x: parseFloat(d.daa), y: parseFloat(d.phyto) })).filter(p => !isNaN(p.x) && !isNaN(p.y)).sort((a, b) => a.x - b.x), borderColor: '#d97706', tension: 0.1, fill: false };
                    const phytoConfig = { type: 'line', data: { datasets: [phytoData] }, options: { scales: { x: { type: 'linear' }, y: { beginAtZero: true, max: 100 } } } };
                    const summary = await getChartSummaryFromAI(phytoConfig, '% Phytotoxicity', 'Overall', status, trial.Result);
                    finalSummaries.phyto = summary;
                    summariesWereUpdated = true;
                }

                if (summariesWereUpdated || wasEfficacyGenerated) {
                    trial.AISummariesJSON = JSON.stringify(finalSummaries);
                    const payload = { id: trial.ID, AISummariesJSON: trial.AISummariesJSON };
                    if (wasEfficacyGenerated) {
                        payload.EfficacyDataJSON = trial.EfficacyDataJSON;
                    }
                    await apiCall('updateTrialRecord', payload, false);
                }
            }

            async function runBulkAnalysisLoop() {
                const { trialsToProcess, totalToProcess } = state.bulkAnalysisState;
                let successCount = 0;
                let errorCount = 0;

                for (let i = state.bulkAnalysisState.lastProcessedIndex + 1; i < totalToProcess; i++) {
                    if (!state.bulkAnalysisState.isRunning) break;
                    const trial = trialsToProcess[i];
                    state.bulkAnalysisState.lastProcessedIndex = i;
                    renderBulkAnalysisControls();

                    try {
                        let efficacyData = safeJsonParse(trial.EfficacyDataJSON, []);
                        let efficacyWasGenerated = false;

                        // Step 1: Generate efficacy from photos if needed
                        if (efficacyData.length === 0) {
                            const photos = safeJsonParse(trial.PhotoURLs, []);
                            if (photos.length > 0) {
                                const newEfficacyObservations = [];
                                for (const photo of photos) {
                                    if (!photo.url) continue;
                                    const imageData = await getImageAsResizedBase64(photo.url);
                                    if (!imageData) continue;

                                    const analysisResult = await analyzePhotoForEfficacy(imageData, 'image/jpeg');

                                    if (analysisResult) {
                                        const observationDate = new Date(photo.date || trial.Date);
                                        const trialDate = new Date(trial.Date);
                                        const daa = Math.round((observationDate.getTime() - trialDate.getTime()) / (1000 * 60 * 60 * 24));

                                        newEfficacyObservations.push({
                                            date: observationDate.toISOString().split('T')[0],
                                            daa: daa >= 0 ? daa : 0,
                                            phyto: analysisResult.phyto,
                                            notes: `AI analysis from photo on ${observationDate.toLocaleDateString()}`,
                                            photoUrl: photo.url,
                                            weedDetails: analysisResult.weedDetails,
                                        });
                                    }
                                }

                                if (newEfficacyObservations.length > 0) {
                                    trial.EfficacyDataJSON = JSON.stringify(newEfficacyObservations);
                                    efficacyWasGenerated = true;
                                }
                            }
                        }

                        // Step 2: Generate summaries if efficacy data exists
                        efficacyData = safeJsonParse(trial.EfficacyDataJSON, []);
                        if (efficacyData.length > 0) {
                            await updateTrialAISummaries(trial.ID, efficacyWasGenerated);
                            successCount++;
                        }
                    } catch (error) {
                        if (error.message === 'QUOTA_EXCEEDED') {
                            state.bulkAnalysisState.isRunning = false;
                            state.bulkAnalysisState.isPaused = true;
                            renderBulkAnalysisControls();
                            showToast('Analysis paused. All API keys have exceeded their quota.', 'error');
                            return; // Exit the loop
                        }
                        console.error(`Failed to process trial ${trial.ID}:`, error);
                        errorCount++;
                    }
                }

                showToast(`Finished. ${successCount} trials updated, ${errorCount} failed.`, errorCount > 0 ? 'error' : 'success');
                cancelBulkAnalysis();
                if (successCount > 0) initializeApp(false);
            }

            function cancelBulkAnalysis() {
                state.bulkAnalysisState = { isRunning: false, isPaused: false, lastProcessedIndex: -1, trialsToProcess: [], totalToProcess: 0 };
                renderBulkAnalysisControls();
                showToast('Analysis cancelled.', 'info');
            }

            function renderBulkAnalysisControls() {
                const controlsEl = document.getElementById('bulk-analysis-controls');
                const progressEl = document.getElementById('summary-progress');
                if (!controlsEl || !progressEl) return;

                const { isRunning, isPaused, lastProcessedIndex, totalToProcess } = state.bulkAnalysisState;

                if (isRunning && !isPaused) {
                    controlsEl.innerHTML = `<button data-action="cancel-bulk-analysis" class="bg-red-600 text-white px-4 py-2 rounded-lg">Cancel Analysis</button>`;
                    progressEl.textContent = `Processing ${lastProcessedIndex + 1}/${totalToProcess}...`;
                } else if (isPaused) {
                    controlsEl.innerHTML = `
                        <button data-action="manage-bulk-analysis" class="bg-green-600 text-white px-4 py-2 rounded-lg">Resume Analysis</button>
                        <button data-action="cancel-bulk-analysis" class="bg-gray-500 text-white px-4 py-2 rounded-lg">Cancel</button>
                    `;
                    progressEl.textContent = `Paused due to API quota limit. Processed ${lastProcessedIndex + 1}/${totalToProcess}.`;
                } else {
                    controlsEl.innerHTML = `<button data-action="manage-bulk-analysis" class="bg-indigo-600 text-white px-4 py-2 rounded-lg">Generate AI Efficacy Data & Summaries</button>`;
                    progressEl.textContent = '';
                }
            }

            function bindEventListeners() {
                document.getElementById('sidebar-nav').addEventListener('click', e => {
                    const target = e.target.closest('a');
                    if (target && target.dataset.page) {
                        e.preventDefault();
                        switchPage(target.dataset.page);
                    }
                });

                // Close menus when clicking outside
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('[data-action="toggle-card-menu"]')) {
                        document.querySelectorAll('.card-menu').forEach(el => el.classList.add('hidden'));
                    }
                });

                document.body.addEventListener('click', e => {
                    const target = e.target.closest('[data-action]');
                    if (!target) return;
                    const { action, type, id, index, sort, trialId, photoIndex, obsIndex } = target.dataset;
                    const actions = {
                        openModal: () => handleOpenModal(type),
                        'toggle-card-menu': () => {
                            const menu = document.getElementById(`card-menu-${id}`);
                            document.querySelectorAll('.card-menu').forEach(el => {
                                if (el !== menu) el.classList.add('hidden');
                            });
                            if (menu) menu.classList.toggle('hidden');
                        },
                        'open-weed-modal': () => handleOpenModal('weedId', id),
                        'open-organise-modal': () => openModal('organise'),
                        'open-plot-scanner': () => openQrScanner(),
                        'close-qr-scanner': () => closeQrScanner(),
                        'go-to-compare': () => { switchPage('compareTrials'); },
                        'get-location': () => getGeoLocation(coords => { document.getElementById('trial-form').querySelector('[name="location"]').value = `${coords.lat.toFixed(5)}, ${coords.lon.toFixed(5)}`; showToast('Location captured!', 'success'); }),
                        'fetch-trial-weather': () => fetchWeatherForTrialDate(),
                        edit: () => handleEdit(type, id),
                        delete: () => handleDelete(type, id),
                        duplicate: () => handleDuplicateItem(type, id),
                        'finalize-trial': () => handleFinalizeTrial(id),
                        'restart-trial': () => handleRestartTrial(id),
                        'toggle-live-status': () => handleToggleLiveStatus(id),
                        'manage-live-qr': () => {
                            const trial = state.trials.find(t => t.ID === id);
                            if (!trial) {
                                console.error('Trial not found:', id);
                                showToast('Trial not found. Please refresh the page.', 'error');
                                return;
                            }
                            openModal('liveQrSettings', false, { trial });
                        },
                        'save-live-qr-settings-final': () => handleSaveLiveQrSettingsFinal(),
                        'generate-qr-final': () => generateTrialCardsCombined(id, target.dataset.mode),
                        'analyze-trial-efficacy': () => analyzeTrialEfficacy(id),
                        'edit-control-days': () => {
                            // Ensure event doesn't bubble if this button is inside a card
                            e.stopPropagation();
                            handleQuickEditControl(id);
                        },
                        'generate-qr-label': () => openModal('qrModeChoice', { trial: state.trials.find(t => t.ID === id) }),
                        'delete-weed-photo': () => handleWeedPhotoDelete(trialId, parseInt(index, 10)),
                        'view-trial': () => openTrialDetail(id),
                        'sort-trials': () => applyFilters({ sortBy: sort }),
                        'reset-filters': () => {
                            // Clear filter state
                            state.filterState = { search: '', formulationText: '', formulation: '', startDate: '', endDate: '', sortBy: 'date' };
                            // Update UI inputs
                            const searchInput = document.querySelector('[data-type="trial-search"]');
                            const formTextInput = document.querySelector('[data-type="trial-formulation-text"]');
                            const formInput = document.querySelector('[data-type="trial-formulation"]');
                            const startInput = document.querySelector('[data-type="trial-start-date"]');
                            const endInput = document.querySelector('[data-type="trial-end-date"]');
                            if (searchInput) searchInput.value = '';
                            if (formTextInput) formTextInput.value = '';
                            if (formInput) formInput.value = '';
                            if (startInput) startInput.value = '';
                            if (endInput) endInput.value = '';
                            applyFilters();
                        },
                        'add-observation': () => addObservation(),
                        'remove-observation': () => target.closest('.observation-card').remove(),
                        'add-weed-cover': () => addWeedCoverRow(target.closest('.observation-card')),
                        'remove-weed-cover': () => target.closest('.weed-details-row').remove(),
                        'fetch-obs-weather': () => fetchWeatherForObservation(obsIndex),
                        'export-pdf-with-report': () => openReportPreviewModal(id, { withIngredients: true, withWeeds: true, withEfficacy: true, withTimeline: state.settings.includeTimeline, showPhotoDates: state.settings.showPhotoDates }),
                        'export-pdf-efficacy-no-ingredients': () => openReportPreviewModal(id, { withIngredients: false, withWeeds: true, withEfficacy: true, withTimeline: state.settings.includeTimeline, showPhotoDates: state.settings.showPhotoDates }),
                        'export-pdf-ingredients': () => generateComprehensivePdf(id, { withIngredients: true, withEfficacy: false, withTimeline: state.settings.includeTimeline, showPhotoDates: state.settings.showPhotoDates }),
                        'export-pdf-no-ingredients': () => generateComprehensivePdf(id, { withIngredients: false, withEfficacy: false, withTimeline: state.settings.includeTimeline, showPhotoDates: state.settings.showPhotoDates }),
                        'export-pdf-weeds-ingredients': () => generateComprehensivePdf(id, { withIngredients: true, withWeeds: true, withEfficacy: false, withTimeline: state.settings.includeTimeline, showPhotoDates: state.settings.showPhotoDates }),
                        'export-pdf-weeds': () => generateComprehensivePdf(id, { withIngredients: false, withWeeds: true, withEfficacy: false, withTimeline: state.settings.includeTimeline, showPhotoDates: state.settings.showPhotoDates }),
                        'export-ppt': () => generatePpt(id),
                        'export-json': exportJson,
                        'export-zip': exportWithPhotos,
                        'export-standalone': exportStandaloneHTML,
                        'import-data': handleImport,
                        'clear-data': () => clearAllData(true),
                        'force-reload': () => { showToast('Clearing cache & reloading...', 'success'); localStorage.clear(); setTimeout(() => window.location.reload(), 1500); },
                        'test-api-key': () => testApiKey(),
                        'add-ingredient-row': addFormulationIngredientRow,
                        'apply-bulk-add': handleBulkIngredients,
                        'apply-bulk-add-cost': handleBulkIngredientsCost,
                        'close-modal': closeModal,
                        'close-qr-scanner': () => closeQrScanner(),
                        'cancel-crop': closeCropper,
                        'crop-image': cropAndSaveImage,
                        'rotate-left': () => { if (cropper) cropper.rotate(-90); },
                        'rotate-right': () => { if (cropper) cropper.rotate(90); },
                        'open-camera': () => openCamera(),
                        'quick-open-camera': () => { state.cameraMode = 'general'; openCamera(id); },
                        'open-weed-camera': () => { state.cameraMode = 'weed'; openCamera(trialId); },
                        'close-camera': closeCamera,
                        'capture-photo': capturePhoto,
                        'remove-ingredient-row': () => { target.closest('.formulation-ingredient-row').remove(); updateFormulationCost(); },
                        'remove-photo': () => { state.croppedPhotosData.splice(parseInt(index, 10), 1); updatePhotoPreview(); },
                        'reset-data-sources': () => { localStorage.removeItem('appSettings'); loadSettings(); showToast('Data sources reset.', 'success'); initializeApp(); },
                        'open-photo-edit-modal': () => handleOpenPhotoEditModal(trialId, photoIndex),
                        'attach-ai-image': () => document.getElementById('ai-image-input').click(),
                        'remove-ai-image': () => { state.aiAttachedImage = { fileData: null, mimeType: null }; document.getElementById('ai-image-preview-container').style.display = 'none'; document.getElementById('ai-image-input').value = ''; },
                        'clear-chat': () => showConfirmation('Clear Chat History?', 'This will permanently delete the conversation.', () => { state.aiChatHistory = []; localStorage.removeItem('aiChatHistory'); if (document.getElementById('ai-chat-box')) document.getElementById('ai-chat-box').innerHTML = ''; appendMessageToChat('Hello! Ask me a question.', 'ai', false); showToast('Chat history cleared.'); }),
                        'run-comparison': runComparison,
                        'export-professional-report': () => generateProfessionalPdfReport(),
                        'manage-bulk-analysis': () => manageBulkAnalysis(),
                        'cancel-bulk-analysis': () => cancelBulkAnalysis(),
                        'generate-single-ai': () => handleSingleAiGeneration(id),
                        'add-api-key': () => {
                            const container = document.getElementById('api-keys-container');
                            if (container) {
                                const newIndex = container.querySelectorAll('.api-key-row').length;
                                container.insertAdjacentHTML('beforeend', render.apiKeyInput('', newIndex));
                            }
                        },
                        'remove-api-key': () => {
                            const row = target.closest('.api-key-row');
                            if (row) {
                                if (document.querySelectorAll('.api-key-row').length > 1) {
                                    row.remove();
                                } else {
                                    row.querySelector('.api-key-input').value = '';
                                }
                            }
                        },
                        'remove-compare-trial': () => {
                            // Remove from selection state
                            state.selectedTrials = state.selectedTrials.filter(tid => tid !== id);
                            // Rerender the comparison page content to update list
                            render.compareTrials();
                            updateSelectionBar();
                        },
                        'print-cards': () => generateCardsForPrint(),
                        'print-pdf': () => generateCardsPdf(),
                        'clear-selection': () => {
                            state.selectedTrials = [];
                            updateSelectionBar();
                            if (state.currentPage === 'compareTrials') render.compareTrials();
                            document.querySelectorAll('input[data-action="select-trial"]').forEach(cb => cb.checked = false);
                        },
                        'retry-sync': () => {
                            const item = state.syncQueue.find(s => s.id === id);
                            if (item) {
                                item.status = 'pending';
                                processSyncQueue();
                            }
                        }
                    };
                    const handler = actions[action];
                    if (handler) {
                        e.preventDefault();
                        e.stopPropagation();
                        handler();
                    }
                });

                document.body.addEventListener('input', e => {
                    const target = e.target;
                    if (target.id === 'import-file-input') document.querySelector('[data-action="import-data"]').disabled = !target.files.length;

                    if (target.matches('[data-action="filter"]')) {
                        // Handle formulation specific search separately or generally
                        if (target.dataset.type === 'formulation') {
                            const searchTerm = target.value.toLowerCase();
                            const filteredFormulations = state.formulations.filter(f => f.Name.toLowerCase().includes(searchTerm));
                            render.formulations(filteredFormulations);
                        } else {
                            applyFilters();
                        }
                    }

                    if (target.matches('[data-action="toggle-photo-dates"]')) {
                        state.settings.showPhotoDates = target.checked;
                        localStorage.setItem('appSettings', JSON.stringify(state.settings));
                    }
                    if (target.matches('[data-action="toggle-include-timeline"]')) {
                        state.settings.includeTimeline = target.checked;
                        localStorage.setItem('appSettings', JSON.stringify(state.settings));
                    }

                    if (target.matches('[data-action="select-trial"]')) {
                        const { id } = target.dataset;
                        if (target.checked) { if (!state.selectedTrials.includes(id)) state.selectedTrials.push(id); } else { state.selectedTrials = state.selectedTrials.filter(trialId => trialId !== id); }
                        updateSelectionBar();
                    }
                    if (target.id === 'trial-photos') handlePhotoSelection(e);
                    if (target.matches('.photo-label-input')) state.croppedPhotosData[target.dataset.index].label = target.value;
                    if (target.closest('#formulation-form')) updateFormulationCost();

                    // Listen for comparison filter changes
                    if (target.id === 'compare-weed-filter' || target.id === 'compare-metric-filter') {
                        runComparison();
                    }
                });

                document.body.addEventListener('change', async e => {
                    const target = e.target;
                    if (target.matches('[data-action="update-result"]')) {
                        const { id } = target.dataset; const newResult = target.value; const trialIndex = state.trials.findIndex(t => t.ID === id); if (trialIndex === -1) return;
                        state.trials[trialIndex].Result = newResult;
                        const result = await apiCall('updateTrialRecord', { id, Result: newResult }, false);
                        const updatedRecord = result?.record || (result?.ID ? result : null);
                        if (updatedRecord) {
                            const idx = state.trials.findIndex(t => t.ID === updatedRecord.ID);
                            if (idx > -1) state.trials[idx] = updatedRecord;
                            showToast('Result updated!', 'success');
                            if (state.currentPage === 'dashboard') render.dashboard();
                        } else {
                            showToast('Failed to update result.', 'error');
                        }
                    }
                    if (target.matches('[data-action="toggle-completed"]')) handleToggleCompleted(target.dataset.id, target.checked);
                    if (target.matches('[data-action="quick-add-photo"]')) {
                        if (target.files.length > 0) {
                            state.cameraMode = 'general';
                            state.photoQueue = [...target.files];
                            processPhotoQueue(target.dataset.id);
                        }
                        target.value = '';
                    }
                    if (target.id === 'weed-photos-input') {
                        if (target.files.length > 0) {
                            console.log('weed-photos-input triggered, setting cameraMode to weed');
                            state.cameraMode = 'weed';
                            state.photoQueue = [...target.files];
                            processPhotoQueue(target.dataset.trialId);
                        }
                        target.value = '';
                    }
                    if (target.id === 'ai-image-input') {
                        const file = target.files[0];
                        if (file) {
                            const reader = new FileReader();
                            reader.onload = e => { state.aiAttachedImage = { fileData: e.target.result, mimeType: file.type }; document.getElementById('ai-image-preview').src = e.target.result; document.getElementById('ai-image-preview-container').style.display = 'block'; };
                            reader.readAsDataURL(file);
                        }
                    }
                });

                document.body.addEventListener('submit', e => { e.preventDefault(); handleFormSubmit(e.target); });
            }

            function updateSelectionBar() {
                const count = state.selectedTrials.length;
                const bar = document.getElementById('selection-bar');
                const countEl = document.getElementById('selected-items-count');
                if (!bar || !countEl) return;
                countEl.textContent = `${count} selected`;
                if (count > 0) bar.classList.remove('hidden'); else bar.classList.add('hidden');
            }

            function saveSyncQueue() {
                try {
                    localStorage.setItem('syncQueue', JSON.stringify(state.syncQueue));
                } catch (e) {
                    console.error("Sync storage failed (Quota?)", e);
                    // If photos are too large, we might fail here, but better to keep trying than crash
                }
            }

            function injectSyncPlaceholders() {
                if (!state.syncQueue || state.syncQueue.length === 0) return;
                state.syncQueue.forEach(item => {
                    const trial = state.trials.find(t => t.ID === item.trialId);
                    if (trial) {
                        if (item.type === 'weed_upload') {
                            const photos = safeJsonParse(trial.WeedPhotosJSON);
                            if (!photos.some(p => p.tempId === item.photo.tempId)) {
                                photos.push({
                                    url: '',
                                    tempId: item.photo.tempId,
                                    fileData: item.photo.fileData,
                                    date: item.photo.date,
                                    identifications: null,
                                    label: "Processing..."
                                });
                                trial.WeedPhotosJSON = JSON.stringify(photos);
                            }
                        } else {
                            const photos = safeJsonParse(trial.PhotoURLs);
                            if (!photos.some(p => p.tempId === item.photo.tempId)) {
                                photos.push({
                                    url: '',
                                    tempId: item.photo.tempId,
                                    fileData: item.photo.fileData,
                                    date: item.photo.date,
                                    label: "Processing...",
                                    weather: null
                                });
                                trial.PhotoURLs = JSON.stringify(photos);
                            }
                        }
                    }
                });
            }

            function renderSyncStatus() {
                const el = document.getElementById('sync-status');
                if (!el) return;

                saveSyncQueue(); // Save state whenever UI updates

                const pending = state.syncQueue.filter(s => s.status === 'pending' || s.status === 'retry').length;
                const processing = state.syncQueue.filter(s => s.status === 'processing').length;
                const failed = state.syncQueue.filter(s => s.status === 'error').length;

                if (pending === 0 && processing === 0 && failed === 0) {
                    el.innerHTML = '';
                    return;
                }

                let html = '';
                if (processing > 0) html += `<span class="text-blue-600 animate-pulse flex items-center gap-1"><i data-lucide="refresh-cw" class="h-3 w-3"></i> Syncing...</span>`;
                else if (pending > 0) html += `<span class="text-gray-500 flex items-center gap-1"><i data-lucide="clock" class="h-3 w-3"></i> ${pending} Queued</span>`;

                if (failed > 0) html += `<span class="text-red-600 border border-red-200 bg-red-50 px-2 py-0.5 rounded flex items-center gap-1 cursor-pointer" onclick="retryAllSync()"><i data-lucide="alert-circle" class="h-3 w-3"></i> ${failed} Failed</span>`;

                el.innerHTML = html;
                lucide.createIcons();
            }

            window.retryAllSync = () => {
                state.syncQueue.forEach(s => { if (s.status === 'error') s.status = 'pending'; });
                processSyncQueue();
            };

            let isSyncing = false;
            async function processSyncQueue() {
                if (isSyncing || state.syncQueue.length === 0) return;
                isSyncing = true;
                renderSyncStatus();

                while (state.syncQueue.some(s => s.status === 'pending' || s.status === 'retry')) {
                    const next = state.syncQueue.find(s => s.status === 'pending' || s.status === 'retry');
                    if (!next) break;

                    next.status = 'processing';
                    renderSyncStatus();

                    try {
                        // 1. Upload to Drive
                        const uploadRes = await uploadPhotos([next.photo]);
                        if (!uploadRes || uploadRes.length === 0) throw new Error("Upload failed");
                        const uploadedPhoto = uploadRes[0];

                        // 2. Perform AI if needed
                        let aiResult = null;
                        if (next.type === 'weed_upload') {
                            aiResult = await identifyWeedsFromPhoto(next.photo.fileData, next.photo.mimeType);
                        } else if (state.settings.autoAnalyzePhotos) {
                            aiResult = await analyzePhotoForEfficacy(next.photo.fileData, next.photo.mimeType);
                        }

                        // 3. Update trial on server
                        const trial = state.trials.find(t => t.ID === next.trialId);
                        if (!trial) throw new Error("Trial not found during sync");

                        const payload = {};
                        if (next.type === 'weed_upload') {
                            let weedPhotos = safeJsonParse(trial.WeedPhotosJSON);
                            const tempIdx = weedPhotos.findIndex(p => p.tempId === next.photo.tempId);
                            const realItem = {
                                url: uploadedPhoto.url,
                                date: uploadedPhoto.date,
                                identifications: aiResult || [],
                                label: aiResult && aiResult.length > 0 ? aiResult.map(i => i.name).join(', ') : "Unidentified Weed"
                            };
                            if (tempIdx > -1) weedPhotos[tempIdx] = realItem;
                            else weedPhotos.push(realItem);
                            payload.WeedPhotosJSON = JSON.stringify(weedPhotos);

                            // Also update WeedSpecies
                            const newWeeds = (aiResult || []).map(i => i.name).filter(Boolean);
                            const existing = (trial.WeedSpecies || '').split(',').map(s => s.trim()).filter(Boolean);
                            const all = [...new Set([...existing, ...newWeeds])];
                            if (all.length > 0) payload.WeedSpecies = all.join(', ');
                        } else {
                            let generalPhotos = safeJsonParse(trial.PhotoURLs);
                            const tempIdx = generalPhotos.findIndex(p => p.tempId === next.photo.tempId);
                            const realItem = { url: uploadedPhoto.url, label: uploadedPhoto.label, date: uploadedPhoto.date, weather: uploadedPhoto.weather };
                            if (tempIdx > -1) generalPhotos[tempIdx] = realItem;
                            else generalPhotos.push(realItem);
                            payload.PhotoURLs = JSON.stringify(generalPhotos);

                            if (aiResult) {
                                let efficacyData = safeJsonParse(trial.EfficacyDataJSON);
                                const observationDate = new Date(next.photo.date);
                                const trialDate = new Date(trial.Date);
                                const daa = Math.max(0, Math.round((observationDate.getTime() - trialDate.getTime()) / (1000 * 60 * 60 * 24)));

                                efficacyData.push({
                                    date: observationDate.toISOString().split('T')[0],
                                    daa,
                                    phyto: aiResult.phyto,
                                    notes: `AI analysis from photo taken on ${observationDate.toLocaleDateString()}`,
                                    photoUrl: uploadedPhoto.url,
                                    weedDetails: aiResult.weedDetails,
                                });
                                payload.EfficacyDataJSON = JSON.stringify(efficacyData);
                                payload.AISummariesJSON = '{}';
                            }
                        }

                        const updateRes = await apiCall('updateTrialRecord', { ID: next.trialId, ...payload }, false);
                        const updatedTrial = updateRes?.record || (updateRes?.ID ? updateRes : null);

                        if (updatedTrial) {
                            const triIdx = state.trials.findIndex(t => t.ID === next.trialId);
                            if (triIdx > -1) state.trials[triIdx] = updatedTrial;
                        }

                        // Success: remove from queue
                        state.syncQueue = state.syncQueue.filter(s => s.id !== next.id);

                        // Refresh UI
                        refreshRelevantUI(next.trialId, next.type);

                    } catch (err) {
                        console.error("Sync failed:", err);
                        next.status = 'error';
                        next.attempts++;
                        next.lastError = err.message;
                        if (err.message.includes('Network') || err.message.includes('fetch')) break;
                    }
                    renderSyncStatus();
                }

                isSyncing = false;
                renderSyncStatus();
            }

            function refreshRelevantUI(trialId, type) {
                // If modal is open for this trial, refresh its content
                const modal = document.getElementById('weed-modal');
                if (modal && type === 'weed_upload') {
                    const trial = state.trials.find(t => t.ID === trialId);
                    const grid = document.getElementById('weed-photo-grid');
                    if (grid) grid.innerHTML = safeJsonParse(trial.WeedPhotosJSON).map((p, i) => render.weedPhotoCard(p, trialId, i)).join('');
                } else if (state.currentPage === 'trials' || state.currentPage === 'dashboard') {
                    applyFilters(); // Re-render trial cards
                }

                // Also update detail modal if open
                if (document.getElementById('trial-detail-modal')) {
                    openTrialDetail(trialId);
                }
            }

            function appendMessageToChat(text, sender, isLoading = false, image = null, mimeType = null) {
                const chatBox = document.getElementById('ai-chat-box');
                if (!chatBox) return;

                const messageContainer = document.createElement('div');
                messageContainer.className = `flex ${sender === 'user' ? 'justify-end' : 'justify-start'} mb-4`;

                const messageDiv = document.createElement('div');
                messageDiv.className = `max-w-md p-3 rounded-lg shadow-md ${sender === 'user' ? 'bg-blue-500 text-white' : 'bg-gray-200 text-gray-800'}`;

                if (isLoading) {
                    messageDiv.innerHTML = `<div class="flex items-center gap-2"><div class="animate-spin rounded-full h-4 w-4 border-b-2 border-gray-900"></div><span>Thinking...</span></div>`;
                } else {
                    const sanitizedText = sanitizeHTML(text).replace(/\n/g, '<br>');
                    let imageHTML = '';
                    if (image) {
                        imageHTML = `<img src="${image}" class="max-w-xs rounded-md my-2" alt="User attachment"/>`;
                    }
                    messageDiv.innerHTML = `${imageHTML}${sanitizedText}`;
                }

                messageContainer.appendChild(messageDiv);
                chatBox.appendChild(messageContainer);
                chatBox.scrollTop = chatBox.scrollHeight;
            }

            function setupTrialModalLogic() {
                const form = document.getElementById('trial-form');
                if (!form) return;

                const controlFinalizedCheckbox = form.querySelector('#control-finalized');
                const finalizationDetailsDiv = form.querySelector('#finalization-details');

                const updateFinalizationDate = () => {
                    if (finalizationDetailsDiv) {
                        if (controlFinalizedCheckbox.checked) {
                            finalizationDetailsDiv.classList.remove('hidden');
                            const finalizationDateInput = form.querySelector('#finalization-date');
                            if (finalizationDateInput && !finalizationDateInput.value) {
                                finalizationDateInput.value = new Date().toISOString().split('T')[0];
                            }
                        } else {
                            finalizationDetailsDiv.classList.add('hidden');
                        }
                    }
                };

                controlFinalizedCheckbox?.addEventListener('change', updateFinalizationDate);
                updateFinalizationDate(); // Initial check
            }

            function getChartDefaults() {
                return {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                font: { size: 12, family: 'Segoe UI' },
                                color: '#475569', // slate-600
                                boxWidth: 15,
                                padding: 20,
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleFont: { size: 14, weight: 'bold' },
                            bodyFont: { size: 12 },
                            padding: 12,
                            cornerRadius: 4,
                            displayColors: true,
                            boxPadding: 4,
                        }
                    },
                    scales: {
                        x: {
                            grid: { display: false, borderColor: '#e2e8f0' /* slate-200 */ },
                            ticks: { color: '#64748b', font: { size: 11 } } // slate-500
                        },
                        y: {
                            beginAtZero: true,
                            grid: { color: '#f1f5f9', borderColor: '#e2e8f0' }, // slate-100, slate-200
                            ticks: { color: '#64748b', font: { size: 11 } }
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index',
                    },
                    elements: {
                        point: {
                            radius: 4,
                            hoverRadius: 7,
                            borderWidth: 2,
                            hoverBorderWidth: 2
                        },
                        line: {
                            tension: 0.4,
                            borderWidth: 3,
                        }
                    }
                };
            }

            async function renderChartToImage(chartConfig, width = 1200, height = 600) {
                return new Promise((resolve, reject) => {
                    try {
                        const offscreenCanvas = document.createElement('canvas');
                        offscreenCanvas.width = width;
                        offscreenCanvas.height = height;

                        const ctx = offscreenCanvas.getContext('2d');
                        ctx.fillStyle = 'white';
                        ctx.fillRect(0, 0, width, height);

                        const config = JSON.parse(JSON.stringify(chartConfig)); // Deep copy

                        config.options = {
                            ...config.options,
                            animation: false,
                            responsive: false,
                            devicePixelRatio: 2 // Render at 2x resolution for HD output
                        };

                        const chart = new Chart(ctx, config);

                        setTimeout(() => {
                            try {
                                resolve(chart.toBase64Image());
                            } catch (e) {
                                reject(e);
                            } finally {
                                chart.destroy();
                            }
                        }, 300);
                    } catch (e) {
                        console.error("Error creating chart for image render:", e);
                        reject(e);
                    }
                });
            }

            function prepareTrialChartData(trial) {
                if (!trial) return null;

                let efficacyData = safeJsonParse(trial.EfficacyDataJSON);

                // Data fixup for legacy
                if (efficacyData.length > 0 && efficacyData.some(d => (d.cover !== undefined) && d.weedDetails === undefined)) {
                    efficacyData.forEach(obs => {
                        if ((obs.cover !== undefined) && obs.weedDetails === undefined) {
                            obs.weedDetails = [{ species: (trial.WeedSpecies || 'Unknown').split(',')[0].trim(), cover: obs.cover, status: '', notes: '' }];
                        }
                    });
                }

                if (efficacyData.length === 0) return null;

                const colors = ['#4A90E2', '#D0021B', '#F5A623', '#7ED321', '#50E3C2', '#9013FE', '#000000', '#4a4a4a', '#f8e71c', '#b8e986'];
                const allWeedSpecies = [...new Set(efficacyData.flatMap(obs => (obs.weedDetails || []).map(wc => wc.species.trim())))];

                // 1. Cover Chart
                const coverDatasets = allWeedSpecies.map((species, index) => {
                    const speciesData = efficacyData
                        .map(obs => {
                            const weed = (obs.weedDetails || []).find(wc => wc.species.trim() === species);
                            return weed ? { x: parseFloat(obs.daa), y: parseFloat(weed.cover) } : null;
                        })
                        .filter(p => p && !isNaN(p.x) && !isNaN(p.y))
                        .sort((a, b) => a.x - b.x);

                    const color = colors[index % colors.length];
                    return {
                        label: species,
                        data: speciesData,
                        borderColor: color,
                        backgroundColor: color + '33',
                        fill: true,
                        pointRadius: 5,
                        pointBackgroundColor: color,
                        pointHoverRadius: 8,
                    };
                });

                const chartDefaults = getChartDefaults();
                const coverChartOptions = {
                    ...chartDefaults,
                    scales: {
                        ...chartDefaults.scales,
                        x: { ...chartDefaults.scales.x, type: 'linear', title: { display: true, text: 'Days After Application (DA-A)' } },
                        y: { ...chartDefaults.scales.y, max: 100, title: { display: true, text: '% Cover' } }
                    },
                    plugins: {
                        ...chartDefaults.plugins,
                        legend: { ...chartDefaults.plugins.legend, display: allWeedSpecies.length > 1 },
                        tooltip: {
                            ...chartDefaults.plugins.tooltip,
                            callbacks: {
                                label: function (context) {
                                    let label = context.dataset.label || '';
                                    if (label) { label += ': '; }
                                    if (context.parsed.y !== null) { label += context.parsed.y.toFixed(1) + '%'; }
                                    return label;
                                }
                            }
                        }
                    }
                };

                // 2. Phyto Chart
                const phytoData = {
                    label: '% Phytotoxicity',
                    data: efficacyData.map(d => ({ x: parseFloat(d.daa), y: parseFloat(d.phyto) })).filter(p => !isNaN(p.x) && !isNaN(p.y)).sort((a, b) => a.x - b.x),
                    borderColor: '#d97706',
                    backgroundColor: '#d9770633',
                    fill: true,
                    pointRadius: 5,
                    pointBackgroundColor: '#d97706',
                };

                const phytoChartOptions = {
                    ...chartDefaults,
                    scales: {
                        ...chartDefaults.scales,
                        x: { ...chartDefaults.scales.x, type: 'linear', title: { display: true, text: 'Days After Application (DA-A)' } },
                        y: { ...chartDefaults.scales.y, max: 100, title: { display: true, text: '% Phytotoxicity' } }
                    },
                    plugins: { ...chartDefaults.plugins, legend: { display: false } }
                };

                return {
                    coverDatasets,
                    coverChartOptions,
                    phytoData,
                    phytoChartOptions,
                    allWeedSpecies
                };
            }

            // New helper to decouple drawing charts from any AI/Async logic
            function renderTrialChartsToCanvases(trial, coverCanvasId, phytoCanvasId) {
                const chartData = prepareTrialChartData(trial);
                if (!chartData) return;

                const { coverDatasets, coverChartOptions, phytoData, phytoChartOptions } = chartData;

                const coverCtx = document.getElementById(coverCanvasId);
                if (coverCtx) {
                    new Chart(coverCtx, {
                        type: 'line',
                        data: { datasets: coverDatasets },
                        options: coverChartOptions
                    });
                }

                const phytoCtx = document.getElementById(phytoCanvasId);
                if (phytoCtx && phytoData.data.length > 0) {
                    new Chart(phytoCtx, {
                        type: 'line',
                        data: { datasets: [phytoData] },
                        options: phytoChartOptions
                    });
                }
            }

            // Main render function for trial details uses the helper but assigns to state for tracking
            function renderSingleTrialCharts(trial) {
                if (!trial) return;
                if (state.charts.singleCoverChart) state.charts.singleCoverChart.destroy();
                if (state.charts.singlePhytoChart) state.charts.singlePhytoChart.destroy();

                const coverCtx = document.getElementById('single-cover-chart');
                const phytoCtx = document.getElementById('single-phyto-chart');

                let efficacyData = safeJsonParse(trial.EfficacyDataJSON);

                if (efficacyData.length > 0 && efficacyData.some(d => (d.cover !== undefined) && d.weedDetails === undefined)) {
                    efficacyData.forEach(obs => {
                        if ((obs.cover !== undefined) && obs.weedDetails === undefined) {
                            obs.weedDetails = [{ species: (trial.WeedSpecies || 'Unknown').split(',')[0].trim(), cover: obs.cover, status: '', notes: '' }];
                        }
                    });
                }

                if (efficacyData.length === 0) return;

                const colors = ['#4A90E2', '#D0021B', '#F5A623', '#7ED321', '#50E3C2', '#9013FE', '#000000', '#4a4a4a', '#f8e71c', '#b8e986'];
                const allWeedSpecies = [...new Set(efficacyData.flatMap(obs => (obs.weedDetails || []).map(wc => wc.species.trim())))];

                const coverDatasets = allWeedSpecies.map((species, index) => {
                    const speciesData = efficacyData
                        .map(obs => {
                            const weed = (obs.weedDetails || []).find(wc => wc.species.trim() === species);
                            return weed ? { x: parseFloat(obs.daa), y: parseFloat(weed.cover) } : null;
                        })
                        .filter(p => p && !isNaN(p.x) && !isNaN(p.y))
                        .sort((a, b) => a.x - b.x);

                    const color = colors[index % colors.length];
                    return {
                        label: species,
                        data: speciesData,
                        borderColor: color,
                        backgroundColor: color + '33', // 20% opacity
                        fill: true,
                        pointRadius: 5,
                        pointBackgroundColor: color,
                        pointHoverRadius: 8,
                    };
                });

                const chartDefaults = getChartDefaults();
                const coverChartOptions = {
                    ...chartDefaults,
                    scales: {
                        ...chartDefaults.scales,
                        x: { ...chartDefaults.scales.x, type: 'linear', title: { display: true, text: 'Days After Application (DA-A)' } },
                        y: { ...chartDefaults.scales.y, max: 100, title: { display: true, text: '% Cover' } }
                    },
                    plugins: {
                        ...chartDefaults.plugins,
                        legend: { ...chartDefaults.plugins.legend, display: allWeedSpecies.length > 1 },
                        tooltip: {
                            ...chartDefaults.plugins.tooltip,
                            callbacks: {
                                label: function (context) {
                                    let label = context.dataset.label || '';
                                    if (label) { label += ': '; }
                                    if (context.parsed.y !== null) { label += context.parsed.y.toFixed(1) + '%'; }
                                    return label;
                                }
                            }
                        }
                    }
                };

                if (coverCtx && coverDatasets.length > 0) {
                    state.charts.singleCoverChart = new Chart(coverCtx, {
                        type: 'line',
                        data: { datasets: coverDatasets },
                        options: coverChartOptions
                    });
                }

                const phytoData = {
                    label: '% Phytotoxicity',
                    data: efficacyData.map(d => ({ x: parseFloat(d.daa), y: parseFloat(d.phyto) })).filter(p => !isNaN(p.x) && !isNaN(p.y)).sort((a, b) => a.x - b.x),
                    borderColor: '#d97706',
                    backgroundColor: '#d9770633',
                    fill: true,
                    pointRadius: 5,
                    pointBackgroundColor: '#d97706',
                };

                if (phytoCtx && phytoData.data.length > 0) {
                    state.charts.singlePhytoChart = new Chart(phytoCtx, {
                        type: 'line',
                        data: { datasets: [phytoData] },
                        options: {
                            ...chartDefaults,
                            scales: {
                                ...chartDefaults.scales,
                                x: { ...chartDefaults.scales.x, type: 'linear', title: { display: true, text: 'Days After Application (DA-A)' } },
                                y: { ...chartDefaults.scales.y, max: 100, title: { display: true, text: '% Phytotoxicity' } }
                            },
                            plugins: { ...chartDefaults.plugins, legend: { display: false } }
                        }
                    });
                }
            }

            // Cache for AI summaries to avoid duplicate API calls
            const aiSummaryCache = new Map();

            async function getChartSummaryFromAI(chartConfig, chartTitle, seriesName, trialStatus = "Ongoing", userResult = "") {
                // Create a cache key based on chart data and title
                const datasets = chartConfig.data.datasets.map(ds => ({
                    label: ds.label,
                    data: ds.data.map(p => ({ x: p.x, y: p.y }))
                }));
                const cacheKey = `${chartTitle}_${seriesName}_${JSON.stringify(datasets)}`;

                // Check if we have a cached summary
                if (aiSummaryCache.has(cacheKey)) {
                    console.log('Using cached AI summary for:', chartTitle);
                    return aiSummaryCache.get(cacheKey);
                }

                try {
                    const chartType = chartConfig.type;

                    const prompt = `Act as a Senior Agronomist analyzing a ${chartType} chart titled "${chartTitle}" for ${seriesName}.
                    
                    Context:
                    - Trial Status: ${trialStatus}
                    - User's Manual Verdict: ${userResult ? userResult : "Not provided"}
                    - Goal: Weed control/elimination.

                    Data Points (x=Day, y=Value):
                    ${JSON.stringify(datasets)}

                    Interpretation Rules:
                    1. **High Phytotoxicity (>70%)** on weeds is **EXCELLENT/POSITIVE** (indicates high efficacy).
                    2. **Low Phytotoxicity** is **POOR** (weeds surviving).
                    3. **Decreasing % Cover** is **POSITIVE**.
                    4. **Increasing/Static % Cover** is **NEGATIVE** (unless identified as "Dead/Dry" vegetation).

                    Output Guidelines:
                    - Write a concise, professional summary (3-4 sentences max).
                    - Use human-like, natural language. **DO NOT** use mathematical notation like "x=4" or "y=88". Instead say "by Day 4" or "peaking at 88%".
                    - Avoid listing every single data point. Focus on the biological trend (e.g., "Rapid burndown observed...", "Steady control maintained...", "Weeds recovered after initial injury...").
                    - If finalized, state a clear conclusion on efficacy based on the User's Verdict and data.`;

                    const geminiCall = (genAI) => genAI.models.generateContent({
                        model: state.settings.apiModel || 'gemini-2.5-flash-lite',
                        contents: [{ parts: [{ text: prompt }] }]
                    });

                    const response = await callGeminiApi(`Summarizing chart: ${chartTitle}`, geminiCall);
                    const summaryText = response.text;

                    // Cache the result
                    aiSummaryCache.set(cacheKey, summaryText);

                    return summaryText;
                } catch (error) {
                    console.error('AI Summary Error:', error);
                    return "AI summary could not be generated at this time.";
                }
            }

            async function generateComprehensivePdf(trialId, options = { withIngredients: true, withWeeds: false, chartImages: null }) {
                const trial = state.trials.find(t => t.ID === trialId);
                if (!trial) return;
                showToast('Generating PDF...', 'info');

                const { jsPDF } = window.jspdf;
                const doc = new jsPDF();
                const pageWidth = doc.internal.pageSize.getWidth();

                // --- Header ---
                doc.setFillColor(13, 148, 136); // Teal header
                doc.rect(0, 0, pageWidth, 40, 'F');
                doc.setTextColor(255, 255, 255);
                doc.setFontSize(22);
                doc.text("Herbicide Trial Report", pageWidth / 2, 25, { align: 'center' });

                doc.setTextColor(0, 0, 0);
                doc.setFontSize(16);
                doc.text(trial.FormulationName, 14, 50);

                doc.setFontSize(10);
                doc.setTextColor(100);
                const leftColX = 14;
                const rightColX = pageWidth / 2 + 10;
                let y = 60;

                doc.text(`Investigator: ${trial.InvestigatorName || 'N/A'}`, leftColX, y);
                doc.text(`Date: ${new Date(trial.Date).toLocaleDateString()}`, rightColX, y); y += 6;
                doc.text(`Location: ${trial.Location || 'N/A'}`, leftColX, y);
                doc.text(`Dosage: ${trial.Dosage || 'N/A'}`, rightColX, y); y += 6;
                doc.text(`Replication: ${trial.Replication || 'N/A'}`, leftColX, y);
                doc.text(`Result: ${trial.Result || 'N/A'}`, rightColX, y); y += 10;

                // --- Weather ---
                if (trial.Temperature) {
                    doc.setFillColor(241, 245, 249); // Slate-100
                    doc.rect(14, y - 5, pageWidth - 28, 18, 'F');
                    doc.setFont(undefined, 'bold');
                    doc.text("Weather Conditions:", 16, y);
                    doc.setFont(undefined, 'normal');
                    doc.text(`Temp: ${trial.Temperature}°C   Humidity: ${trial.Humidity}%   Wind: ${trial.Windspeed} km/h   Rain: ${trial.Rain} mm`, 16, y + 6);
                    y += 20;
                }

                // --- Conclusion & Notes ---
                doc.setFont(undefined, 'bold');
                doc.text("Conclusion:", 14, y);
                doc.setFont(undefined, 'normal');
                const conclusionLines = doc.splitTextToSize(trial.Conclusion || 'N/A', pageWidth - 28);
                doc.text(conclusionLines, 14, y + 5);
                y += (conclusionLines.length * 5) + 8;

                doc.setFont(undefined, 'bold');
                doc.text("Notes:", 14, y);
                doc.setFont(undefined, 'normal');
                const notesLines = doc.splitTextToSize(trial.Notes || 'N/A', pageWidth - 28);
                doc.text(notesLines, 14, y + 5);
                y += (notesLines.length * 5) + 12;

                // --- Efficacy Logic ---
                const summaries = safeJsonParse(trial.AISummariesJSON, {});
                if (options.withEfficacy !== false) {
                    if (summaries.cover || options.chartImages?.cover) {
                        if (y > 200) { doc.addPage(); y = 20; }
                        doc.setFont(undefined, 'bold');
                        doc.text("Efficacy Analysis:", 14, y);
                        y += 8;

                        if (options.chartImages?.cover) {
                            try {
                                doc.addImage(options.chartImages.cover, 'PNG', 14, y, 180, 90);
                                y += 95;
                            } catch (e) { }
                        }

                        if (summaries.cover) {
                            doc.setFont(undefined, 'normal');
                            doc.setFontSize(9);
                            const lines = doc.splitTextToSize("Analysis: " + summaries.cover, pageWidth - 28);
                            doc.text(lines, 14, y);
                            y += (lines.length * 5) + 10;
                        }
                    }

                    if (summaries.phyto || options.chartImages?.phyto) {
                        if (y > 200) { doc.addPage(); y = 20; }

                        if (options.chartImages?.phyto) {
                            try {
                                doc.setFont(undefined, 'bold');
                                doc.setFontSize(10);
                                doc.text("Phytotoxicity Analysis:", 14, y);
                                y += 5;
                                doc.addImage(options.chartImages.phyto, 'PNG', 14, y, 180, 90);
                                y += 95;
                            } catch (e) { }
                        }

                        if (summaries.phyto) {
                            doc.setFont(undefined, 'normal');
                            doc.setFontSize(9);
                            const lines = doc.splitTextToSize("Analysis: " + summaries.phyto, pageWidth - 28);
                            doc.text(lines, 14, y);
                            y += (lines.length * 5) + 10;
                        }
                    }
                }

                // --- Weed Status Timeline ---
                if (options.withTimeline) {
                    const efficacyData = safeJsonParse(trial.EfficacyDataJSON);
                    if (efficacyData.length > 0) {
                        if (y > 220) { doc.addPage(); y = 20; }
                        doc.setFontSize(14);
                        doc.setFont(undefined, 'bold');
                        doc.text("Weed Status Timeline", 14, y);
                        y += 8;

                        const timelineRows = efficacyData.flatMap(obs => (obs.weedDetails || []).map(wd => [obs.daa, wd.species, wd.status, wd.notes]));
                        doc.autoTable({
                            startY: y,
                            head: [['DA-A', 'Species', 'Status', 'Notes']],
                            body: timelineRows,
                            headStyles: { fillColor: [13, 148, 136] },
                            theme: 'striped',
                            styles: { fontSize: 8 }
                        });
                        y = doc.lastAutoTable.finalY + 12;
                    }
                }

                doc.setFontSize(10);
                doc.setTextColor(0, 0, 0);

                // --- Ingredients (Optional) ---
                if (options.withIngredients) {
                    const formulation = state.formulations.find(f => f.ID === trial.FormulationID);
                    if (formulation) {
                        const ingredients = safeJsonParse(formulation.IngredientsJSON);
                        doc.autoTable({
                            startY: y,
                            head: [['Ingredient', 'Quantity', 'Unit']],
                            body: ingredients.map(i => [i.name, i.quantity, i.unit]),
                            headStyles: { fillColor: [13, 148, 136] },
                            theme: 'striped'
                        });
                        y = doc.lastAutoTable.finalY + 10;
                    }
                }

                // --- Photos ---
                const photos = safeJsonParse(trial.PhotoURLs);
                if (photos.length > 0) {
                    if (y > 200) { doc.addPage(); y = 20; }
                    doc.setFontSize(14);
                    doc.setFont(undefined, 'bold');
                    doc.text("Photo Log", 14, y);
                    y += 10;

                    let xOffset = 14;
                    for (let i = 0; i < photos.length; i++) {
                        const p = photos[i];
                        if (!p.url) continue;
                        try {
                            const imgData = await getImageAsResizedBase64(p.url, 300); // Helper to get Base64
                            if (imgData) {
                                if (xOffset + 50 > pageWidth) { xOffset = 14; y += 60; }
                                if (y > 250) { doc.addPage(); y = 20; xOffset = 14; }

                                doc.addImage(imgData, 'JPEG', xOffset, y, 50, 50);
                                doc.setFontSize(8);
                                // If label exists, show label. If not, fallback to date with prefix.
                                const primaryLabel = p.label ? p.label : (p.date ? `Photo: ${p.date}` : '-');
                                doc.text(primaryLabel, xOffset, y + 54);

                                // Only show secondary date if it's explicitly requested AND a label exists (to avoid double date)
                                if (p.label && options.showPhotoDates) {
                                    doc.text(p.date || '', xOffset, y + 58);
                                }
                                xOffset += 60;
                            }
                        } catch (e) { console.warn("Could not add image to PDF", e); }
                    }
                    y += 70;
                }

                // --- Weeds (Optional) ---
                if (options.withWeeds) {
                    const weedPhotos = safeJsonParse(trial.WeedPhotosJSON);
                    if (weedPhotos.length > 0) {
                        doc.addPage();
                        doc.setFontSize(16);
                        doc.text("Weed Identification", 14, 20);
                        let weedY = 30;

                        for (const p of weedPhotos) {
                            if (!p.url) continue;
                            if (weedY > 220) { doc.addPage(); weedY = 20; }
                            try {
                                const imgData = await getImageAsResizedBase64(p.url, 300);
                                if (imgData) {
                                    doc.addImage(imgData, 'JPEG', 14, weedY, 60, 60);
                                    const bestMatch = p.identifications?.[0];
                                    doc.setFontSize(12);
                                    doc.text(bestMatch?.name || 'Unknown', 80, weedY + 10);
                                    doc.setFontSize(10);
                                    doc.text(`Common: ${bestMatch?.commonNames?.[0] || '-'}`, 80, weedY + 20);
                                    doc.text(`Confidence: ${bestMatch?.confidence ? (bestMatch.confidence * 100).toFixed(1) + '%' : 'N/A'}`, 80, weedY + 30);
                                    weedY += 70;
                                }
                            } catch (e) { }
                        }
                    }
                }

                doc.save(`${trial.FormulationName}_Report.pdf`);
                showToast('PDF downloaded.', 'success');
            }

            // --- Helper for PDF generation ---
            async function getImageAsResizedBase64(url, width = 800) {
                if (url.startsWith('data:image')) return url;
                // Use a proxy to avoid CORS if needed, or fetch directly if allowed
                const proxyUrl = `https://images.weserv.nl/?url=${encodeURIComponent(url)}&w=${width}&output=jpg&q=80`;
                try {
                    const res = await fetch(proxyUrl);
                    const blob = await res.blob();
                    return new Promise((resolve) => {
                        const reader = new FileReader();
                        reader.onloadend = () => resolve(reader.result);
                        reader.readAsDataURL(blob);
                    });
                } catch (e) {
                    console.error("Image fetch failed", e);
                    return null;
                }
            }

            async function generateProfessionalPdfReport() {
                if (state.selectedTrials.length === 0) return showToast('Select at least one trial to compare.', 'error');
                showToast('Generating report... this may take a moment.', 'info');
                // Simple implementation - in real app, this would be much more complex
                // calling 'runComparison' to get data then putting it in PDF
                runComparison();

                setTimeout(() => {
                    const canvas = document.getElementById('compare-chart');
                    if (canvas) {
                        const imgData = canvas.toDataURL('image/png');
                        const { jsPDF } = window.jspdf;
                        const doc = new jsPDF('l'); // Landscape
                        doc.setFontSize(20);
                        doc.text("Comparative Analysis Report", 14, 20);
                        doc.addImage(imgData, 'PNG', 10, 30, 280, 150);
                        doc.save('Comparative_Report.pdf');
                        showToast('Report downloaded.');
                    }
                }, 1500); // Wait for chart to render
            }

            async function generatePpt(trialId) {
                const trial = state.trials.find(t => t.ID === trialId);
                if (!trial) return;
                showToast('Generating PowerPoint...', 'info');

                const pptx = new PptxGenJS();
                pptx.layout = 'LAYOUT_16x9';

                // Slide 1: Title
                const slide1 = pptx.addSlide();
                slide1.addText('Herbicide Trial Report', { x: 1, y: 1, w: '80%', fontSize: 24, bold: true, color: '008080' });
                slide1.addText(trial.FormulationName, { x: 1, y: 2, w: '80%', fontSize: 18 });
                slide1.addText(`Investigator: ${trial.InvestigatorName}`, { x: 1, y: 3, fontSize: 14 });
                slide1.addText(`Date: ${new Date(trial.Date).toLocaleDateString()}`, { x: 1, y: 3.5, fontSize: 14 });

                // Slide 2: Photos
                const photos = safeJsonParse(trial.PhotoURLs).slice(0, 4);
                if (photos.length > 0) {
                    const slide2 = pptx.addSlide();
                    slide2.addText('Field Photos', { x: 0.5, y: 0.5, fontSize: 18, color: '008080' });

                    let xPos = 0.5;
                    for (const p of photos) {
                        if (p.url) {
                            slide2.addImage({ path: p.url, x: xPos, y: 1.5, w: 3, h: 3 });
                            xPos += 3.2;
                        }
                    }
                }

                pptx.writeFile({ fileName: `${trial.FormulationName}_Presentation.pptx` });
                showToast('PPT downloaded.', 'success');
            }

            function exportJson() {
                const dataStr = JSON.stringify(state, null, 2);
                const blob = new Blob([dataStr], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `herbicide_data_${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }

            async function exportWithPhotos() {
                showToast('Creating ZIP archive...', 'info');
                const zip = new JSZip();
                zip.file("data.json", JSON.stringify(state, null, 2));

                const photosFolder = zip.folder("photos");
                const allPhotos = state.trials.flatMap(t => safeJsonParse(t.PhotoURLs));

                for (let i = 0; i < allPhotos.length; i++) {
                    const p = allPhotos[i];
                    if (p.url) {
                        try {
                            const imgData = await getImageAsResizedBase64(p.url, 1000);
                            if (imgData) {
                                // Remove data:image/jpeg;base64, prefix
                                const base64Data = imgData.split(',')[1];
                                photosFolder.file(`photo_${i}.jpg`, base64Data, { base64: true });
                            }
                        } catch (e) { }
                    }
                }

                const content = await zip.generateAsync({ type: "blob" });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(content);
                a.download = `herbicide_data_complete_${new Date().toISOString().split('T')[0]}.zip`;
                a.click();
                showToast('ZIP downloaded.', 'success');
            }

            function exportStandaloneHTML() {
                showToast('Generating standalone HTML...', 'info');
                // Logic to bundle state into HTML file
                const html = document.documentElement.outerHTML.replace('const state = {', `const state = ${JSON.stringify(state)}; //`);
                const blob = new Blob([html], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'herbicide-app-standalone.html';
                a.click();
            }

            function handleImport(event) {
                const file = document.getElementById('import-file-input').files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        if (file.name.endsWith('.json')) {
                            const importedState = JSON.parse(e.target.result);
                            state = { ...state, ...importedState };
                            saveStateToLocalStorage(); // Mock persistence
                            initializeApp(false);
                            showToast('Data imported successfully.', 'success');
                        } else {
                            showToast('ZIP import not fully supported in this demo version.', 'info');
                        }
                    } catch (err) {
                        showToast('Invalid file format.', 'error');
                    }
                };
                reader.readAsText(file);
            }

            function saveStateToLocalStorage() {
                // Backup state to localStorage for offline recovery
                // Uses safeStringify to avoid circular reference errors
                try {
                    localStorage.setItem('backupState', safeStringify(state));
                    console.log('State backup saved successfully');
                } catch (e) {
                    console.warn('Failed to save state backup to localStorage:', e.message);
                    // Fallback: try to save only critical data
                    try {
                        const criticalData = {
                            settings: state.settings,
                            filterState: state.filterState,
                            aiChatHistory: state.aiChatHistory
                        };
                        localStorage.setItem('backupState', JSON.stringify(criticalData));
                        console.log('Critical data backup saved as fallback');
                    } catch (fallbackError) {
                        console.error('All backup attempts failed:', fallbackError);
                    }
                }
            }

            async function clearAllData(confirm = false) {
                if (!confirm) {
                    showConfirmation('Delete Everything?', 'This will wipe all data from the database.', () => clearAllData(true));
                    return;
                }

                // In a real app, this would make API calls to delete everything
                state.trials = [];
                state.formulations = [];
                state.ingredients = [];
                state.organisations = [];
                state.syncQueue = [];
                saveSyncQueue();

                await apiCall('clearAllData', {}, false); // Assuming backend support
                initializeApp();
                showToast('All data cleared.', 'success');
            }

            function runComparison() {
                const weedSelect = document.getElementById('compare-weed-filter');
                const metricSelect = document.getElementById('compare-metric-filter');

                if (!weedSelect) return;

                const selectedWeed = weedSelect.value;
                const metric = metricSelect ? metricSelect.value : 'cover'; // 'cover' or 'phyto'

                if (!selectedWeed && metric === 'cover') {
                    document.getElementById('compare-chart-title').textContent = "Please select a weed species to compare.";
                    return;
                }

                const ctx = document.getElementById('compare-chart');
                if (!ctx) return;

                if (state.charts.compareChart) state.charts.compareChart.destroy();

                const trialsToCompare = state.selectedTrials.map(id => state.trials.find(t => t.ID === id)).filter(Boolean);

                const datasets = trialsToCompare.map((t, i) => {
                    const efficacy = safeJsonParse(t.EfficacyDataJSON);
                    let dataPoints = [];

                    if (metric === 'phyto') {
                        // For phyto, we generally take the 'phyto' value of the observation directly, or average if multiple points same day
                        dataPoints = efficacy.map(obs => ({ x: obs.daa, y: obs.phyto })).filter(p => p.x != null && p.y != null).sort((a, b) => a.x - b.x);
                    } else {
                        // For cover, we need the specific weed details
                        dataPoints = efficacy.map(obs => {
                            const detail = (obs.weedDetails || []).find(d => d.species === selectedWeed);
                            return detail ? { x: obs.daa, y: detail.cover } : null;
                        }).filter(Boolean).sort((a, b) => a.x - b.x);
                    }

                    const colors = ['#4A90E2', '#D0021B', '#F5A623', '#7ED321', '#9013FE', '#000000', '#FF00FF', '#00FFFF'];
                    return {
                        label: t.FormulationName,
                        data: dataPoints,
                        borderColor: colors[i % colors.length],
                        fill: false,
                        tension: 0.2
                    };
                });

                state.charts.compareChart = new Chart(ctx, {
                    type: 'line',
                    data: { datasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: { type: 'linear', title: { display: true, text: 'DA-A' } },
                            y: { beginAtZero: true, max: 100, title: { display: true, text: metric === 'phyto' ? '% Phytotoxicity' : '% Cover' } }
                        },
                        plugins: {
                            legend: { position: 'top' },
                            tooltip: { mode: 'index', intersect: false }
                        }
                    }
                });

                const metricTitle = metric === 'phyto' ? '% Phytotoxicity Comparison' : `% Cover Comparison: ${selectedWeed}`;
                document.getElementById('compare-chart-title').textContent = metricTitle;
            }

            // --- MISSING HELPERS ---
            function fetchWeatherForTrialDate() {
                const location = document.querySelector('[name="location"]').value;
                const date = document.querySelector('[name="date"]').value;
                if (!location || !date) return showToast('Enter location and date first.', 'error');

                // Mock weather fetch
                document.querySelector('[name="temperature"]').value = (25 + Math.random() * 5).toFixed(1);
                document.querySelector('[name="humidity"]').value = (60 + Math.random() * 20).toFixed(0);
                document.querySelector('[name="windspeed"]').value = (10 + Math.random() * 15).toFixed(1);
                document.querySelector('[name="rain"]').value = (Math.random() * 5).toFixed(1);
                showToast('Weather data fetched (simulated).', 'success');
            }

            function fetchWeatherForObservation(index) {
                // Similar mock
                showToast('Weather data fetched (simulated).', 'success');
            }

            async function handleToggleCompleted(id, isChecked) {
                const trial = state.trials.find(t => t.ID === id);
                if (trial) {
                    trial.IsCompleted = isChecked;
                    const result = await apiCall('updateTrialRecord', { ID: id, IsCompleted: isChecked }, false);
                    const updatedRecord = result?.record || (result?.ID ? result : null);
                    if (updatedRecord) {
                        const idx = state.trials.findIndex(t => t.ID === updatedRecord.ID);
                        if (idx > -1) state.trials[idx] = updatedRecord;
                        if (state.currentPage === 'dashboard') render.dashboard();
                        else if (state.currentPage === 'trials') applyFilters();
                    }
                }
            }

            function handleFinalizeTrial(id) {
                const trial = state.trials.find(t => t.ID === id);
                if (!trial) return;
                trial.ControlFinalized = true;
                trial.FinalizationDate = new Date().toISOString().split('T')[0];
                // Calc days
                const days = Math.floor((new Date() - new Date(trial.Date)) / (1000 * 60 * 60 * 24));
                trial.FinalControlDuration = days < 0 ? 0 : days;

                apiCall('updateTrialRecord', {
                    id,
                    ControlFinalized: true,
                    FinalizationDate: trial.FinalizationDate,
                    FinalControlDuration: trial.FinalControlDuration
                }, false);

                applyFilters(); // Re-render trial card with persistent sorting
                showToast('Trial control finalized.', 'success');
            }

            function handleRestartTrial(id) {
                const trial = state.trials.find(t => t.ID === id);
                if (!trial) return;
                trial.ControlFinalized = false;
                trial.FinalControlDuration = null;
                trial.FinalizationDate = null;

                apiCall('updateTrialRecord', {
                    id,
                    ControlFinalized: false,
                    FinalizationDate: null,
                    FinalControlDuration: null
                }, false);
                applyFilters(); // Re-render trial card with persistent sorting
                showToast('Trial counting restarted.', 'success');
            }

            async function analyzeTrialEfficacy(id) {
                const trial = state.trials.find(t => t.ID === id);
                if (!trial) return showToast('Trial not found.', 'error');

                console.log('Analyzing trial:', id, 'Trial data:', trial);

                const photos = safeJsonParse(trial.PhotoURLs);
                console.log('Photos found:', photos.length, photos);

                if (photos.length === 0) {
                    return showToast('No photos to analyze in this trial. Add photos first.', 'error');
                }

                // Check for API keys
                if (!state.settings.apiKeys || state.settings.apiKeys.length === 0) {
                    return showToast('No API keys configured. Go to Settings to add a Gemini API key.', 'error');
                }

                const confirmRun = confirm(`This will analyze ${photos.length} photo(s) for efficacy data using ${photos.length} API call(s). Continue?`);
                if (!confirmRun) return;

                showToast(`Analyzing ${photos.length} photo(s) for efficacy...`, 'info');

                let efficacyData = safeJsonParse(trial.EfficacyDataJSON);
                let aiAnalysisComplete = false;
                let photosAnalyzed = 0;

                for (const photo of photos) {
                    try {
                        // Skip photos that already have efficacy data linked
                        const alreadyAnalyzed = efficacyData.some(e => e.photoUrl === photo.url);
                        if (alreadyAnalyzed) {
                            console.log('Skipping already analyzed photo:', photo.url);
                            continue;
                        }

                        // Need to fetch the photo as base64 for analysis
                        showToast(`Analyzing photo ${photosAnalyzed + 1}/${photos.length}...`, 'info');

                        // Fetch photo and convert to base64
                        const photoData = await fetchPhotoAsBase64(photo.url);
                        if (!photoData) {
                            console.error('Could not fetch photo:', photo.url);
                            continue;
                        }

                        const efficacyResult = await analyzePhotoForEfficacy(photoData.fileData, photoData.mimeType);
                        if (efficacyResult) {
                            const observationDate = new Date(photo.date || trial.Date);
                            const trialDate = new Date(trial.Date);
                            const daaValue = Math.round((observationDate.getTime() - trialDate.getTime()) / (1000 * 60 * 60 * 24));
                            const daa = daaValue >= 0 ? daaValue : 0;

                            efficacyData.push({
                                date: observationDate.toISOString().split('T')[0],
                                daa,
                                phyto: efficacyResult.phyto,
                                notes: `AI analysis from photo taken on ${observationDate.toLocaleDateString()}`,
                                photoUrl: photo.url,
                                weedDetails: efficacyResult.weedDetails,
                            });
                            aiAnalysisComplete = true;
                            photosAnalyzed++;
                        }
                    } catch (err) {
                        console.error('Photo analysis failed:', err);
                        showToast(`Analysis failed: ${err.message}`, 'error');
                        if (err.message === 'QUOTA_EXCEEDED' || err.message === 'ALL_KEYS_EXHAUSTED') {
                            showToast('API Quota exhausted. Try again later.', 'error');
                            break;
                        }
                    }
                }

                if (aiAnalysisComplete) {
                    trial.EfficacyDataJSON = JSON.stringify(efficacyData);
                    trial.AISummariesJSON = '{}'; // Clear cached summaries

                    const result = await apiCall('updateTrialRecord', {
                        ID: id,
                        EfficacyDataJSON: trial.EfficacyDataJSON,
                        AISummariesJSON: '{}'
                    }, true);

                    if (result) {
                        showToast(`Efficacy analysis complete! Analyzed ${photosAnalyzed} photo(s). Opening report...`, 'success');
                        applyFilters();
                        // Open the trial detail view to show the analysis results
                        setTimeout(() => openTrialDetail(id), 500);
                    } else {
                        showToast('Failed to save analysis results.', 'error');
                    }
                } else {
                    showToast('No new photos to analyze. All photos already have efficacy data.', 'info');
                    // Still open the trial detail to show existing data
                    openTrialDetail(id);
                }
            }

            // Helper function to fetch a photo URL and convert to base64
            async function fetchPhotoAsBase64(url) {
                try {
                    // Use the proxy to avoid CORS issues
                    const proxiedUrl = `https://images.weserv.nl/?url=${encodeURIComponent(url)}&output=jpg`;
                    const response = await fetch(proxiedUrl);
                    const blob = await response.blob();

                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = () => resolve({
                            fileData: reader.result,
                            mimeType: blob.type || 'image/jpeg'
                        });
                        reader.onerror = reject;
                        reader.readAsDataURL(blob);
                    });
                } catch (error) {
                    console.error('Error fetching photo as base64:', error);
                    return null;
                }
            }

            function handleQuickEditControl(id) {
                const trial = state.trials.find(t => t.ID === id);
                if (!trial) return;

                const currentDays = trial.FinalControlDuration ||
                    Math.floor((new Date() - new Date(trial.Date)) / (1000 * 60 * 60 * 24));

                const newDays = prompt("Set final control days:", currentDays);
                if (newDays !== null && !isNaN(parseInt(newDays))) {
                    trial.ControlFinalized = true;
                    trial.FinalControlDuration = parseInt(newDays);
                    trial.FinalizationDate = new Date().toISOString().split('T')[0];

                    apiCall('updateTrialRecord', {
                        id: trial.ID,
                        ControlFinalized: true,
                        FinalizationDate: trial.FinalizationDate,
                        FinalControlDuration: trial.FinalControlDuration
                    }, false);
                    applyFilters();
                    showToast('Control days updated.', 'success');
                }
            }

            async function handleWeedPhotoUpload(trialId, photos) {
                console.log('handleWeedPhotoUpload called, setting cameraMode to weed');
                state.cameraMode = 'weed'; // Explicitly set weed mode
                const result = await processAndAddPhotoObservation(trialId, photos);
            }

            function handleWeedPhotoDelete(trialId, index) {
                const trial = state.trials.find(t => t.ID === trialId);
                const photos = safeJsonParse(trial.WeedPhotosJSON);
                photos.splice(index, 1);
                trial.WeedPhotosJSON = JSON.stringify(photos);
                apiCall('updateTrialRecord', { id: trialId, WeedPhotosJSON: trial.WeedPhotosJSON }, false);
                // Refresh modal if open
                const modal = document.getElementById('weed-modal');
                if (modal) {
                    document.getElementById('weed-photo-grid').innerHTML = photos.map((p, i) => render.weedPhotoCard(p, trialId, i)).join('');
                }
            }

            async function handleAiQuery(query) {
                appendMessageToChat(query, 'user');
                document.getElementById('ai-input').value = '';
                appendMessageToChat('', 'ai', true);

                // Mock AI response for chat
                setTimeout(() => {
                    const chatBox = document.getElementById('ai-chat-box');
                    chatBox.lastChild.remove(); // Remove loading
                    appendMessageToChat("I'm ready to help analyze your trials. (AI Chat Integration Placeholder)", 'ai');
                }, 1000);
            }

            function handleOrganiseSubmit(form) {
                const orgId = form.querySelector('[name="organisationId"]').value;
                const newName = form.querySelector('[name="newOrganisationName"]').value;

                if (newName) {
                    const newOrg = { ID: 'temp_' + Date.now(), Name: newName, TrialIDs: JSON.stringify(state.selectedTrials) };
                    state.organisations.push(newOrg);
                    apiCall('addOrganisation', newOrg, false).then(res => {
                        const record = res?.record || (res?.ID ? res : null);
                        if (record) {
                            state.organisations[state.organisations.length - 1] = record;
                            render.organisations();
                        }
                    });
                } else if (orgId) {
                    const org = state.organisations.find(o => o.ID === orgId);
                    const currentTrials = safeJsonParse(org.TrialIDs);
                    const updatedTrials = [...new Set([...currentTrials, ...state.selectedTrials])];
                    org.TrialIDs = JSON.stringify(updatedTrials);
                    apiCall('updateOrganisation', { id: orgId, TrialIDs: org.TrialIDs }, false);
                }

                closeModal();
                showToast('Trials added to organisation.', 'success');
                state.selectedTrials = [];
                updateOrganiseBar();
            }

            function handlePhotoEditSubmit(form) {
                const trialId = form.querySelector('[name="trialId"]').value;
                const photoIndex = parseInt(form.querySelector('[name="photoIndex"]').value);
                const trial = state.trials.find(t => t.ID === trialId);

                const photos = safeJsonParse(trial.PhotoURLs);
                if (photos[photoIndex]) {
                    photos[photoIndex].label = form.querySelector('[name="label"]').value;
                    photos[photoIndex].date = form.querySelector('[name="date"]').value;
                    // Update weather if changed...

                    trial.PhotoURLs = JSON.stringify(photos);
                    apiCall('updateTrialRecord', { id: trialId, PhotoURLs: trial.PhotoURLs }, false);
                    showToast('Photo details updated.', 'success');
                    closeModal();
                    openTrialDetail(trialId); // Refresh detail view
                }
            }

            function handleBulkIngredients() {
                const text = document.getElementById('bulk-ingredients-input').value;
                if (!text) return showToast('Please enter ingredients.', 'error');

                // Split by comma
                const items = text.split(',').map(s => s.trim()).filter(Boolean);
                let addedCount = 0;

                items.forEach(itemStr => {
                    // Regex: Name (Group 1), Quantity (Group 2), Unit (Group 4)
                    // Example: "Acetic Acid 500ml" -> "Acetic Acid", "500", "ml"
                    const match = itemStr.match(/^(.+?)\s+(\d+(?:\.\d+)?)\s*([a-zA-Z]+)$/);
                    if (match) {
                        const name = match[1].trim();
                        const quantity = match[2];
                        const unit = match[3];

                        // Try to find ingredient by name match
                        const ingredient = state.ingredients.find(ing => ing.Name.toLowerCase() === name.toLowerCase());
                        if (ingredient) {
                            addFormulationIngredientRow({ id: ingredient.ID, quantity, unit });
                            addedCount++;
                        } else {
                            showToast(`Ingredient '${name}' not found in database.`, 'error');
                        }
                    } else {
                        showToast(`Could not parse: '${itemStr}'. Use format 'Name QuantityUnit'.`, 'error');
                    }
                });

                if (addedCount > 0) {
                    updateFormulationCost();
                    showToast(`${addedCount} ingredients added.`, 'success');
                }
            }

            async function handleBulkIngredientsCost() {
                const text = document.getElementById('bulk-ingredients-cost-input').value;
                if (!text) return showToast('Please enter ingredients.', 'error');

                const items = text.split(',').map(s => s.trim()).filter(Boolean);
                let count = 0;

                showToast(`Processing ${items.length} items...`, 'info');

                for (const itemStr of items) {
                    // Regex: Name Cost Unit
                    // Example: "Glyphosate 15000 L" -> "Glyphosate", "15000", "L"
                    const match = itemStr.match(/^(.+?)\s+(\d+(?:\.\d+)?)\s*([a-zA-Z]+)$/);
                    if (match) {
                        const name = match[1].trim();
                        const cost = parseFloat(match[2]);
                        const unit = match[3];

                        const payload = {
                            ID: `temp_${Date.now()}_${count}`,
                            Name: name, name: name,
                            Cost: cost, cost: cost,
                            Unit: unit, unit: unit
                        };

                        // Add locally first for responsiveness
                        state.ingredients.push(payload);
                        count++;

                        // Sync to backend (fire and forget for speed in bulk, or await)
                        // We await here to ensure data integrity
                        await apiCall('addIngredient', payload, false);
                    }
                }

                render.ingredients();
                showToast(`${count} ingredients added/synced.`, 'success');
            }

            async function openReportPreviewModal(trialId, options) {
                openModal('reportPreview');
                const trial = state.trials.find(t => t.ID === trialId);

                // 1. Render charts IMMEDIATELY. Do not wait for any async logic or timeouts.
                setTimeout(() => {
                    renderTrialChartsToCanvases(trial, 'preview-cover-canvas', 'preview-phyto-canvas');
                    document.getElementById('cover-report-section').classList.remove('hidden');
                    document.getElementById('phyto-report-section').classList.remove('hidden');
                }, 50);

                // 2. Fetch AI summaries in background INDEPENDENTLY
                const summaries = safeJsonParse(trial.AISummariesJSON, {});
                const coverInput = document.getElementById('cover-summary-textarea');
                const phytoInput = document.getElementById('phyto-summary-textarea');

                coverInput.value = summaries.cover || 'Generating professional analysis...';
                phytoInput.value = summaries.phyto || 'Generating professional analysis...';

                if (!summaries.cover || !summaries.phyto) {
                    // This is async and might take time, but the graphs are already visible
                    await updateTrialAISummaries(trialId);
                    const newSum = safeJsonParse(state.trials.find(t => t.ID === trialId).AISummariesJSON);
                    coverInput.value = newSum.cover || 'Analysis generation failed.';
                    phytoInput.value = newSum.phyto || 'Analysis generation failed.';
                }

                // Add persistence listeners
                // Add persistence listeners with Debounce
                let saveTimeout;
                const saveSummary = () => {
                    const t = state.trials.find(tr => tr.ID === trialId);
                    if (t) {
                        const s = safeJsonParse(t.AISummariesJSON, {});
                        s.cover = coverInput.value;
                        s.phyto = phytoInput.value;
                        t.AISummariesJSON = JSON.stringify(s);

                        clearTimeout(saveTimeout);
                        saveTimeout = setTimeout(() => {
                            apiCall('updateTrialRecord', { id: trialId, AISummariesJSON: t.AISummariesJSON }, false);
                            showToast('AI Summary saved to cloud.', 'success');
                        }, 1000);
                    }
                };
                coverInput.addEventListener('input', saveSummary);
                phytoInput.addEventListener('input', saveSummary);

                // Initialize regeneration logic
                const chartData = prepareTrialChartData(trial);

                document.getElementById('regenerate-cover-summary').onclick = async () => {
                    if (!chartData) return;
                    coverInput.value = 'Regenerating summary...';
                    const { coverChartOptions, allWeedSpecies } = chartData;
                    const summary = await getChartSummaryFromAI(coverChartOptions, '% Cover by Species', allWeedSpecies.join(', '), "Ongoing", trial.Result);
                    coverInput.value = summary;
                    saveSummary();
                };

                document.getElementById('regenerate-phyto-summary').onclick = async () => {
                    if (!chartData) return;
                    phytoInput.value = 'Regenerating summary...';
                    const { phytoChartOptions } = chartData;
                    const summary = await getChartSummaryFromAI(phytoChartOptions, '% Phytotoxicity', 'Overall', "Ongoing", trial.Result);
                    phytoInput.value = summary;
                    saveSummary();
                };

                document.getElementById('generate-pdf-from-preview').onclick = () => {
                    // Capture canvas images
                    const coverCanvas = document.getElementById('preview-cover-canvas');
                    const phytoCanvas = document.getElementById('preview-phyto-canvas');
                    const chartImages = {
                        cover: coverCanvas ? coverCanvas.toDataURL('image/png') : null,
                        phyto: phytoCanvas ? phytoCanvas.toDataURL('image/png') : null
                    };
                    const showPhotoDates = document.getElementById('show-photo-dates')?.checked || state.settings.showPhotoDates;
                    const withTimeline = document.getElementById('include-timeline')?.checked || state.settings.includeTimeline;
                    generateComprehensivePdf(trialId, { ...options, chartImages, showPhotoDates, withTimeline });
                };
            }

            function openTrialDetail(id) {
                const trial = state.trials.find(t => t.ID === id);
                openModal('trialDetail', false, { trial });
                setTimeout(() => renderSingleTrialCharts(trial), 100);
            }

            function applyFilters(overrides = {}) {
                const search = document.querySelector('[data-type="trial-search"]')?.value.toLowerCase() || state.filterState.search;
                const formulationText = document.querySelector('[data-type="trial-formulation-text"]')?.value.toLowerCase() || state.filterState.formulationText;
                const formulation = document.querySelector('[data-type="trial-formulation"]')?.value || state.filterState.formulation;
                const start = document.querySelector('[data-type="trial-start-date"]')?.value || state.filterState.startDate;
                const end = document.querySelector('[data-type="trial-end-date"]')?.value || state.filterState.endDate;
                const sortBy = overrides.sortBy || state.filterState.sortBy;

                state.filterState = { search, formulationText, formulation, startDate: start, endDate: end, sortBy };

                let filtered = state.trials.filter(t => {
                    const matchesSearch = !search || (t.InvestigatorName || '').toLowerCase().includes(search) || (t.WeedSpecies || '').toLowerCase().includes(search);
                    const matchesFormText = !formulationText || (t.FormulationName || '').toLowerCase().includes(formulationText);
                    const matchesForm = !formulation || t.FormulationName === formulation;
                    const matchesDate = (!start || t.Date >= start) && (!end || t.Date <= end);
                    return matchesSearch && matchesFormText && matchesForm && matchesDate;
                });

                if (sortBy === 'date') filtered.sort((a, b) => new Date(b.Date).getTime() - new Date(a.Date).getTime());
                if (sortBy === 'result') {
                    const scores = { 'Excellent': 4, 'Good': 3, 'Fair': 2, 'Poor': 1, '': 0 };
                    filtered.sort((a, b) => scores[b.Result || ''] - scores[a.Result || '']);
                }

                render.trials(filtered);
            }

            function getGeoLocation(callback) {
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                        pos => callback({ lat: pos.coords.latitude, lon: pos.coords.longitude }),
                        err => showToast('Location access denied.', 'error')
                    );
                } else {
                    showToast('Geolocation not supported.', 'error');
                }
            }

            // --- PLOT SCANNER LOGIC ---
            let scannerStream = null;
            let scannerAnimationId = null;
            // Create a single canvas for scanning to avoid garbage collection churn
            const scannerCanvas = document.createElement("canvas");
            const scannerCtx = scannerCanvas.getContext("2d");

            function openQrScanner() {
                const modal = document.getElementById('qr-scanner-modal-fixed');
                const video = document.getElementById('qr-video');
                if (!modal || !video) return;

                if (typeof jsQR === 'undefined') {
                    showToast('QR Scanner library not loaded. Please refresh.', 'error');
                    return;
                }

                // Check for Secure Context / Protocol
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    console.error("Camera API unavailable. Protocol:", window.location.protocol);
                    if (window.location.protocol === 'file:') {
                        alert("⚠️ Camera Blocked by Browser Security\n\nYou are opening this file directly (file://). Modern browsers block camera access in this mode for security.\n\nSolution:\nUse a local server (like 'Live Server' in VS Code) or upload to a secure website (https://).");
                    } else {
                        showToast("Camera API not supported or blocked by browser context.", "error");
                    }
                    return;
                }

                modal.classList.remove('hidden');

                // Helper to start camera with fallback
                const startCamera = (constraints) => {
                    navigator.mediaDevices.getUserMedia(constraints)
                        .then(stream => {
                            scannerStream = stream;
                            video.srcObject = stream;
                            video.setAttribute("playsinline", true); // Required for iOS Safari
                            video.play().catch(e => console.error("Video play error:", e));
                            requestAnimationFrame(scanQrTick);
                        })
                        .catch(err => {
                            console.warn("Camera failed with constraints:", constraints, err);
                            // Fallback: If environment camera failed, try ANY camera
                            if (constraints.video && constraints.video.facingMode === 'environment') {
                                console.log("Retrying with generic camera access...");
                                startCamera({ video: true });
                            } else {
                                console.error("All camera attempts failed:", err);
                                showToast("Could not access any camera. Please check permissions.", "error");
                                closeQrScanner();
                            }
                        });
                };

                // Initial attempt: Prefer back camera, HD resolution
                startCamera({
                    video: {
                        facingMode: "environment",
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                });
            }

            function closeQrScanner() {
                const modal = document.getElementById('qr-scanner-modal-fixed');
                const video = document.getElementById('qr-video');

                if (modal) modal.classList.add('hidden');

                if (scannerAnimationId) cancelAnimationFrame(scannerAnimationId);

                if (video) {
                    video.pause();
                    video.srcObject = null;
                }

                if (scannerStream) {
                    scannerStream.getTracks().forEach(track => track.stop());
                    scannerStream = null;
                }
            }

            function scanQrTick() {
                const video = document.getElementById('qr-video');
                const modal = document.getElementById('qr-scanner-modal-fixed');

                // Stop if modal is closed
                if (!modal || modal.classList.contains('hidden')) return;

                if (!video || !video.videoWidth) {
                    scannerAnimationId = requestAnimationFrame(scanQrTick);
                    return;
                }

                // Draw video frame to canvas
                scannerCanvas.width = video.videoWidth;
                scannerCanvas.height = video.videoHeight;
                scannerCtx.drawImage(video, 0, 0, scannerCanvas.width, scannerCanvas.height);

                const imageData = scannerCtx.getImageData(0, 0, scannerCanvas.width, scannerCanvas.height);

                // Scan for QR code
                const code = jsQR(imageData.data, imageData.width, imageData.height, {
                    inversionAttempts: "dontInvert",
                });

                if (code) {
                    // Success!
                    handleScannedQr(code.data);
                } else {
                    scannerAnimationId = requestAnimationFrame(scanQrTick);
                }
            }

            function handleScannedQr(data) {
                // Feedback
                if (navigator.vibrate) navigator.vibrate(200);

                // Try to extract Trial ID
                let trialId = null;

                // Case 1: URL with trialId parameter (Online QR)
                if (data.includes('trialId=')) {
                    try {
                        const url = new URL(data);
                        trialId = url.searchParams.get('trialId');
                    } catch (e) {
                        // Fallback regex
                        const match = data.match(/trialId=([^&]+)/);
                        if (match) trialId = match[1];
                    }
                }
                // Case 2: Just the ID
                else if (data.match(/^[0-9a-f]{8}-[0-9a-f]{4}/i)) {
                    trialId = data; // Assume it's an ID
                }

                if (trialId) {
                    const trial = state.trials.find(t => t.ID === trialId);
                    if (trial) {
                        showToast(`Found: ${trial.FormulationName}`, 'success');
                        closeQrScanner();
                        openTrialDetail(trialId);
                    } else {
                        // Avoid spamming if trial not found, maybe pause slightly?
                        // For now just close and warn
                        closeQrScanner();
                        showToast('Trial ID found in QR, but not in local database.', 'warning');
                    }
                } else {
                    // Determine if it looks like an offline QR
                    if (data.includes('H-APP:')) {
                        closeQrScanner();
                        alert("This is an Offline QR Code.\\n\\nContent:\\n" + data + "\\n\\nPlease use Online QR Codes for navigation.");
                    }
                    // Else: continue scanning (maybe it's not a relevant QR)
                    else {
                        // Optional: Ignore unknown QRs and keep scanning
                        scannerAnimationId = requestAnimationFrame(scanQrTick);
                    }
                }
            }

            // --- REPORTING & EXPORT LOGIC ---
            /* runComparison is defined earlier at ~3476 */

            async function getLogoDimensions(logoDataUrl) { return new Promise(resolve => { if (!logoDataUrl) { resolve(null); return; } const img = new Image(); img.onload = () => { const aspectRatio = img.width / img.height; const logoHeight = 1.2; const logoWidth = logoHeight * aspectRatio; resolve({ width: logoWidth, height: logoHeight }); }; img.onerror = () => resolve(null); img.src = logoDataUrl; }); }
            async function generateQrCodeDataUrl(dataString) { return new Promise((resolve, reject) => { try { const tempDiv = document.createElement('div'); new QRCode(tempDiv, { text: dataString, width: 256, height: 256, correctLevel: QRCode.CorrectLevel.M }); setTimeout(() => { const canvas = tempDiv.querySelector('canvas'); if (canvas) resolve(canvas.toDataURL('image/png')); else reject(new Error('QR Code generation failed.')); }, 100); } catch (error) { resolve(null); } }); }

            async function generateCardsForPrint() {
                if (state.selectedTrials.length === 0) return showToast('No trials selected.', 'error');

                // Map cardSize to dimensions (cm)
                let cardWidth = 9, cardHeight = 6;
                const sizeSetting = state.settings.cardSize || 'ID';
                if (sizeSetting === 'A6') { cardWidth = 10; cardHeight = 14; } // Portrait 
                if (sizeSetting === 'A4') { cardWidth = 19; cardHeight = 13; } // Landscape half
                const companyLogo = state.settings.logoBase64;

                showToast('Generating print layout...', 'info');

                const printWindow = window.open('', '_blank');
                if (!printWindow) return showToast("Pop-up blocker prevented opening print window.", 'error');

                let htmlContent = `
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>Print Trial Cards</title>
                <style>
                    @media print { body { -webkit-print-color-adjust: exact; print-color-adjust: exact; } }
                    body { margin: 0.5cm; font-family: sans-serif; }
                    .page {
                        display: grid;
                        grid-template-columns: repeat(auto-fill, minmax(${cardWidth}cm, 1fr));
                        gap: 0.5cm;
                        page-break-after: always;
                    }
                    .card {
                        width: ${cardWidth}cm;
                        height: ${cardHeight}cm;
                        border: 1px solid #ccc;
                        border-radius: 4px;
                        padding: 0.4cm;
                        box-sizing: border-box;
                        display: flex;
                        flex-direction: column;
                        justify-content: space-between;
                        page-break-inside: avoid;
                        overflow: hidden;
                        position: relative;
                    }
                    .card-header { display: flex; justify-content: space-between; align-items: flex-start; }
                    .card-header h3 { font-size: 12pt; margin: 0; font-weight: bold; color: #2c5282; max-width: 65%; }
                    .logo { max-width: 2.5cm; max-height: 1.2cm; object-fit: contain; }
                    .card-body p { font-size: 9pt; margin: 0.1cm 0; }
                    .card-footer { text-align: right; }
                    .qr-code { width: 2.5cm; height: 2.5cm; }
                     .qr-code { width: 2.5cm; height: 2.5cm; }
                 </style>
            </head>
            <body><div class="page">`;

                const selected = state.selectedTrials.map(id => state.trials.find(t => t.ID === id)).filter(Boolean);

                for (const trial of selected) {
                    // Generate QR
                    const params = new URLSearchParams({ trialId: trial.ID, spreadsheetId: state.settings.sheetId });
                    const qrDataString = `${state.settings.scriptUrl}?${params.toString()}`;
                    const qrCodeUrl = await generateQrCodeDataUrl(qrDataString);

                    htmlContent += `
                <div class="card">
                    <div>
                        <div class="card-header">
                            <h3>${sanitizeHTML(trial.FormulationName)}</h3>
                            ${companyLogo ? `<img src="${companyLogo}" class="logo" alt="Logo">` : ''}
                        </div>
                        <div class="card-body">
                            <p><strong>Investigator:</strong> ${sanitizeHTML(trial.InvestigatorName)}</p>
                            <p><strong>Date:</strong> ${new Date(trial.Date).toLocaleDateString()}</p>
                            <p><strong>Dosage:</strong> ${sanitizeHTML(trial.Dosage)}</p>
                        </div>
                    </div>
                    <div class="card-footer">
                        ${qrCodeUrl ? `<img src="${qrCodeUrl}" class="qr-code">` : ''}
                    </div>
                </div>`;
                }

                htmlContent += `</div></body></html>`;
                printWindow.document.write(htmlContent);
                printWindow.document.close();
                setTimeout(() => { printWindow.focus(); printWindow.print(); printWindow.close(); }, 500);
            }

            async function generateCardsPdf() {
                if (state.selectedTrials.length === 0) return showToast('No trials selected.', 'error');
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF();
                let y = 10;

                state.selectedTrials.forEach((id, index) => {
                    const trial = state.trials.find(t => t.ID === id);
                    if (!trial) return;
                    if (index > 0 && index % 2 === 0) { doc.addPage(); y = 10; }

                    doc.setFontSize(16);
                    doc.text(trial.FormulationName || 'Trial', 10, y);
                    y += 10;
                    doc.setFontSize(12);
                    doc.text(`Investigator: ${trial.InvestigatorName || '-'}`, 10, y);
                    y += 7;
                    doc.text(`Date: ${new Date(trial.Date).toLocaleDateString()}`, 10, y);
                    y += 7;
                    doc.text(`Result: ${trial.Result || '-'}`, 10, y);
                    y += 15;

                    // Add more details or photos here...
                    y += 20;
                });

                doc.save('trial-cards.pdf');
            }

            function generateTrialCards() {
                return state.selectedTrials.map(id => {
                    const trial = state.trials.find(t => t.ID === id);
                    if (!trial) return '';
                    return `<div class="bg-white p-6 rounded-xl border border-gray-200 shadow-sm break-inside-avoid">
    <div class="flex justify-between items-start mb-4">
        <div>
            <h3 class="font-bold text-xl">${sanitizeHTML(trial.FormulationName)}</h3>
            <p class="text-gray-500 text-sm">${new Date(trial.Date).toLocaleDateString()}</p>
        </div>
        <span
            class="px-3 py-1 rounded-full text-sm font-bold result-${(trial.Result || 'none').toLowerCase()}">${trial.Result
                        || 'None'}</span>
    </div>
    <div class="grid grid-cols-2 gap-4 text-sm text-gray-700">
        <p><strong>Investigator:</strong> ${sanitizeHTML(trial.InvestigatorName)}</p>
        <p><strong>Location:</strong> ${sanitizeHTML(trial.Location)}</p>
        <p><strong>Dosage:</strong> ${sanitizeHTML(trial.Dosage)}</p>
        <p><strong>Status:</strong> ${String(trial.IsCompleted).toLowerCase() === 'true' ? 'Completed' : 'Active'}</p>
    </div>
    <div class="mt-4 pt-4 border-t flex justify-end">
        <div id="qr-${trial.ID}"></div>
    </div>
</div>`;
                }).join('');
            }





            // --- STARTUP ---

            // --- SETTINGS LOGIC ---
            function bindSettingsEvents() {
                document.body.addEventListener('change', (e) => {
                    if (e.target.id === 'settings-logo-input') {
                        const file = e.target.files[0];
                        if (file) {
                            const reader = new FileReader();
                            reader.onload = (readerEvent) => {
                                const base64 = readerEvent.target.result;
                                document.getElementById('settings-logo-preview').src = base64;
                                document.getElementById('settings-logo-hidden').value = base64;
                            };
                            reader.readAsDataURL(file);
                        }
                    }
                });
            }

            bindEventListeners();
            bindSettingsEvents();
            initializeApp();
        });
    </script>
</body>

</html>
