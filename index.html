<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Herbicide Trial Manager</title>

    <!-- External Libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.23/jspdf.plugin.autotable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pptxgenjs@3.12.0/dist/pptxgen.bundle.js"></script>
    <!-- QR Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
    <!-- Statistical Analysis Library -->
    <script src="https://cdn.jsdelivr.net/npm/jstat@1.9.6/dist/jstat.min.js"></script>

    <style>
        :root {
            --primary-color: #0d9488;
            /* teal-600 */
            --primary-hover-color: #0f766e;
            /* teal-700 */
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #f1f5f9;
            /* slate-100 */
        }

        .btn-primary {
            background-color: var(--primary-color);
            transition: background-color 0.2s;
        }

        .btn-primary:hover {
            background-color: var(--primary-hover-color);
        }

        .form-input:focus {
            --tw-ring-color: var(--primary-color);
            border-color: var(--primary-color);
            outline: 2px solid transparent;
            outline-offset: 2px;
            --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
            --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);
            box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
        }

        .sidebar {
            transition: transform 0.3s ease-in-out;
        }

        @media (max-width: 768px) {
            .sidebar {
                transform: translateX(-100%);
            }

            .sidebar.open {
                transform: translateX(0);
            }
        }

        /* Animations */
        @keyframes contentFadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .dashboard-card {
            animation: contentFadeIn 0.5s ease-out forwards;
            opacity: 0;
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            border-radius: 8px;
            color: white;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s, bottom 0.3s;
            z-index: 10000;
        }

        .toast.show {
            opacity: 1;
            visibility: visible;
            bottom: 30px;
        }

        .toast.success {
            background-color: #10b981;
        }

        /* green-500 */
        .toast.error {
            background-color: #ef4444;
        }

        /* red-500 */
        .toast.info {
            background-color: #3b82f6;
        }

        /* blue-500 */

        /* Loading Overlay */
        #loading-overlay {
            z-index: 9999;
        }

        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: var(--primary-color);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Cropper Modal */
        /* Cropper Modal */
        #cropper-modal-fixed {
            display: none;
        }

        #image-to-crop {
            max-height: 60vh;
            max-width: 100%;
            display: block;
        }

        /* Camera Modal */
        #camera-modal-fixed {
            display: none;
        }

        /* Result Colors */
        .result-excellent {
            color: #059669;
            background-color: #d1fae5;
        }

        .result-good {
            color: #0284c7;
            background-color: #dbeafe;
        }

        .result-fair {
            color: #d97706;
            background-color: #fef3c7;
        }

        .result-poor {
            color: #dc2626;
            background-color: #fee2e2;
        }

        .result-none {
            color: #4b5563;
            background-color: #e5e7eb;
        }

        /* Utility */
        .hidden {
            display: none !important;
        }

        /* QR Scanner Overlay */
        .scanner-frame {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 250px;
            height: 250px;
            border: 4px solid var(--primary-color);
            border-radius: 12px;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.5);
            pointer-events: none;
        }

        .scanner-line {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: var(--primary-color);
            box-shadow: 0 0 8px var(--primary-color);
            animation: scan 2s linear infinite;
        }

        @keyframes scan {
            0% {
                top: 0;
            }

            100% {
                top: 100%;
            }
        }

        /* Selection Bar */
        #selection-bar {
            transition: transform 0.3s ease-in-out;
        }

        #selection-bar.hidden {
            transform: translate(-50%, 150%);
            display: flex !important;
        }
    </style>

    <!-- Import Map for Gemini SDK -->
    <script type="importmap">
    {
      "imports": {
        "@google/genai": "https://aistudiocdn.com/@google/genai@^1.29.0"
      }
    }
    </script>
</head>

<body class="bg-slate-100">
    <!-- Selection Bar -->
    <div id="selection-bar"
        class="fixed bottom-10 left-1/2 -translate-x-1/2 bg-slate-800 text-white py-3 px-6 rounded-full shadow-lg flex items-center gap-4 z-50 text-sm font-semibold hidden transition-transform duration-300">
        <span id="selected-items-count">0 selected</span>
        <div class="h-4 w-px bg-slate-600 mx-2"></div>
        <button data-action="open-organise-modal" class="hover:text-teal-300 transition flex items-center gap-2"><i
                data-lucide="folder-plus" class="h-4 w-4"></i>Group</button>
        <button data-action="go-to-compare" class="hover:text-teal-300 transition flex items-center gap-2"><i
                data-lucide="bar-chart-3" class="h-4 w-4"></i>Compare</button>
        <button data-action="print-pdf" class="hover:text-teal-300 transition flex items-center gap-2"><i
                data-lucide="file-down" class="h-4 w-4"></i>PDF Cards</button>
        <button data-action="print-cards" class="hover:text-teal-300 transition flex items-center gap-2"><i
                data-lucide="printer" class="h-4 w-4"></i>Print</button>
        <button data-action="clear-selection" class="ml-2 text-slate-400 hover:text-white">&times;</button>
    </div>
    <div class="flex h-screen">
        <!-- Sidebar -->
        <aside id="sidebar"
            class="sidebar bg-white w-64 flex-shrink-0 border-r border-slate-200 flex flex-col fixed inset-y-0 left-0 z-30 md:relative md:translate-x-0">
            <div class="px-6 py-4 border-b">
                <h2 class="font-bold text-xl text-teal-700 flex items-center gap-2"><i data-lucide="flask-conical"></i>
                    Trial Manager</h2>
            </div>
            <nav id="sidebar-nav" class="flex-grow p-4 space-y-2">
                <a href="#" data-page="dashboard"
                    class="flex items-center gap-3 px-4 py-2 rounded-lg text-slate-600 hover:bg-teal-50 hover:text-teal-700">
                    <i data-lucide="layout-dashboard"></i><span>Dashboard</span>
                </a>
                <a href="#" data-page="projects"
                    class="flex items-center gap-3 px-4 py-2 rounded-lg text-slate-600 hover:bg-teal-50 hover:text-teal-700">
                    <i data-lucide="folder-kanban"></i><span>Projects (RCBD)</span>
                </a>
                <a href="#" data-action="open-plot-scanner"
                    class="flex items-center gap-3 px-4 py-2 rounded-lg text-slate-600 hover:bg-teal-50 hover:text-teal-700">
                    <i data-lucide="scan-qr-code"></i><span>Plot Scanner</span>
                </a>
                <a href="#" data-page="formulations"
                    class="flex items-center gap-3 px-4 py-2 rounded-lg text-slate-600 hover:bg-teal-50 hover:text-teal-700">
                    <i data-lucide="flask-conical"></i><span>Formulations</span>
                </a>
                <a href="#" data-page="trials"
                    class="flex items-center gap-3 px-4 py-2 rounded-lg text-slate-600 hover:bg-teal-50 hover:text-teal-700">
                    <i data-lucide="list-checks"></i><span>Trials</span>
                </a>
                <a href="#" data-page="compareTrials"
                    class="flex items-center gap-3 px-4 py-2 rounded-lg text-slate-600 hover:bg-teal-50 hover:text-teal-700">
                    <i data-lucide="file-box"></i><span>Reports & Cards</span>
                </a>
                <a href="#" data-page="organisations"
                    class="flex items-center gap-3 px-4 py-2 rounded-lg text-slate-600 hover:bg-teal-50 hover:text-teal-700">
                    <i data-lucide="folder-kanban"></i><span>Organisations</span>
                </a>
                <a href="#" data-page="ingredients"
                    class="flex items-center gap-3 px-4 py-2 rounded-lg text-slate-600 hover:bg-teal-50 hover:text-teal-700">
                    <i data-lucide="shopping-bag"></i><span>Ingredient Costs</span>
                </a>
                <a href="#" data-page="aiAssistant"
                    class="flex items-center gap-3 px-4 py-2 rounded-lg text-slate-600 hover:bg-teal-50 hover:text-teal-700">
                    <i data-lucide="sparkles"></i><span>AI Assistant</span>
                </a>
                <div class="pt-4 mt-auto border-t">
                    <a href="#" data-page="dataMgmt"
                        class="flex items-center gap-3 px-4 py-2 rounded-lg text-slate-600 hover:bg-teal-50 hover:text-teal-700">
                        <i data-lucide="database"></i><span>Data Management</span>
                    </a>
                    <a href="#" data-page="settings"
                        class="flex items-center gap-3 px-4 py-2 rounded-lg text-slate-600 hover:bg-teal-50 hover:text-teal-700">
                        <i data-lucide="settings"></i><span>Settings</span>
                    </a>
                </div>
            </nav>
        </aside>

        <!-- Main Content -->
        <main class="flex-1 flex flex-col overflow-hidden">
            <!-- Header -->
            <header class="bg-white border-b border-slate-200 p-4 flex justify-between items-center flex-shrink-0">
                <button id="menu-toggle" class="md:hidden p-2 rounded-md text-slate-600 hover:bg-slate-100">
                    <i data-lucide="menu"></i>
                </button>
                <h1 id="page-title" class="text-xl font-semibold text-slate-800">Dashboard</h1>
                <div id="sync-status" class="flex items-center gap-2 text-xs font-semibold"></div>
                <div><!-- Placeholder for any header actions --></div>
            </header>

            <!-- Content Area -->
            <div id="main-content-wrapper" class="flex-1 overflow-y-auto p-6">
                <div id="main-content">
                    <!-- Dynamic content will be injected here -->
                </div>
                <!-- Selection Bar -->
                <div id="selection-bar"
                    class="fixed bottom-10 left-1/2 -translate-x-1/2 bg-slate-800 text-white py-3 px-6 rounded-full shadow-lg flex items-center gap-4 z-40 text-sm font-semibold hidden transition-transform duration-300">
                    <span id="selected-items-count">0 selected</span>
                    <div class="h-4 w-px bg-slate-600 mx-2"></div>
                    <button data-action="compare-trials"
                        class="hover:text-teal-300 transition flex items-center gap-2"><i data-lucide="bar-chart-3"
                            class="h-4 w-4"></i>Compare</button>
                    <button data-action="print-pdf" class="hover:text-teal-300 transition flex items-center gap-2"><i
                            data-lucide="file-down" class="h-4 w-4"></i>Download PDF</button>
                    <button data-action="print-cards" class="hover:text-teal-300 transition flex items-center gap-2"><i
                            data-lucide="printer" class="h-4 w-4"></i>Print Cards</button>
                    <button data-action="clear-selection" class="ml-2 text-slate-400 hover:text-white">&times;</button>
                </div>
            </div>
        </main>
    </div>

    <!-- Overlays and Modals -->
    <div id="modal-container" class="fixed inset-0 bg-black bg-opacity-50 z-40 overflow-y-auto hidden"></div>

    <div id="loading-overlay" class="fixed inset-0 bg-white bg-opacity-75 flex items-center justify-center hidden">
        <div class="spinner"></div>
    </div>

    <div id="toast" class="toast"></div>

    <!-- Cropper Modal -->
    <div id="cropper-modal-fixed"
        class="fixed inset-0 bg-black bg-opacity-70 flex flex-col items-center justify-center z-[9999] p-4 hidden">
        <div class="bg-white rounded-lg p-4 w-full max-w-2xl">
            <h3 class="text-lg font-bold mb-4">Crop & Rotate Image</h3>
            <div class="img-container">
                <img id="image-to-crop" src="" alt="Image to crop">
            </div>
            <div class="flex justify-center gap-4 mt-4">
                <button data-action="rotate-left" class="p-2 bg-slate-200 rounded-lg"><i
                        data-lucide="rotate-ccw"></i></button>
                <button data-action="rotate-right" class="p-2 bg-slate-200 rounded-lg"><i
                        data-lucide="rotate-cw"></i></button>
            </div>
            <div class="flex justify-end space-x-3 mt-4">
                <button data-action="cancel-crop"
                    class="bg-slate-200 text-slate-800 px-4 py-2 rounded-lg">Cancel</button>
                <button data-action="crop-image" class="btn-primary text-white px-4 py-2 rounded-lg">Apply Crop</button>
            </div>
        </div>
    </div>

    <!-- Camera Modal -->
    <div id="camera-modal-fixed"
        class="fixed inset-0 bg-black bg-opacity-80 z-[9999] flex items-center justify-center p-4 hidden">
        <div class="bg-white rounded-xl shadow-2xl w-full max-w-lg overflow-hidden flex flex-col">
            <div class="px-5 py-4 border-b">
                <h3 class="font-bold text-lg text-slate-800">Live Camera</h3>
            </div>
            <div
                class="relative bg-black w-full h-[60vh] md:h-[500px] flex items-center justify-center overflow-hidden">
                <video id="camera-stream" autoplay playsinline class="w-full h-full object-cover"></video>
                <canvas id="camera-canvas" class="hidden"></canvas>
            </div>
            <div class="px-5 py-4 border-t bg-slate-50 flex justify-end gap-3">
                <button data-action="close-camera"
                    class="px-4 py-2 rounded-lg text-slate-600 font-medium hover:bg-slate-200 transition">Cancel</button>
                <button data-action="capture-photo"
                    class="px-4 py-2 rounded-lg bg-teal-600 text-white font-medium hover:bg-teal-700 shadow-md transition">Capture</button>
            </div>
        </div>
    </div>

    <!-- QR Scanner Modal -->
    <div id="qr-scanner-modal-fixed"
        class="fixed inset-0 bg-black bg-opacity-80 z-[9999] flex items-center justify-center p-4 hidden">
        <div class="bg-white rounded-xl shadow-2xl w-full max-w-lg overflow-hidden flex flex-col">
            <div class="px-5 py-4 border-b flex justify-between items-center">
                <h3 class="font-bold text-lg text-slate-800">Plot Scanner</h3>
            </div>
            <div class="relative bg-black w-full aspect-square flex items-center justify-center overflow-hidden">
                <video id="qr-video" autoplay playsinline class="w-full h-full object-cover"></video>
                <!-- Scanner Lines Overlay -->
                <div class="scanner-frame z-10 pointer-events-none">
                    <div class="scanner-line"></div>
                </div>
                <div class="absolute top-4 w-full text-center text-white px-6 z-10 drop-shadow-md pointer-events-none">
                    <p class="text-sm bg-black/50 px-3 py-1 rounded-full inline-block backdrop-blur-sm">Point at plot QR
                        code</p>
                </div>
            </div>
            <div class="px-5 py-4 border-t bg-slate-50 flex justify-end gap-3">
                <button data-action="close-qr-scanner"
                    class="px-4 py-2 rounded-lg text-slate-600 font-medium hover:bg-slate-200 transition">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Quick Action Modal (Scan Result) -->
    <div id="scan-action-modal"
        class="fixed inset-0 bg-black bg-opacity-80 z-[9999] flex items-center justify-center p-4 hidden">
        <div
            class="bg-white rounded-xl shadow-2xl w-full max-w-sm overflow-hidden flex flex-col animate-in fade-in zoom-in duration-200">
            <div class="px-5 py-4 border-b bg-teal-50">
                <h3 class="font-bold text-lg text-teal-800" id="scan-match-title">Trial Found</h3>
                <p class="text-xs text-teal-600" id="scan-match-subtitle">Select an action</p>
            </div>
            <div class="p-6 grid grid-cols-1 gap-4">
                <button id="scan-action-camera"
                    class="flex items-center gap-4 p-4 bg-blue-50 hover:bg-blue-100 border border-blue-200 rounded-xl transition group">
                    <div
                        class="bg-blue-500 text-white p-3 rounded-full shadow-md group-hover:scale-110 transition-transform">
                        <i data-lucide="camera" class="h-6 w-6"></i>
                    </div>
                    <div class="text-left">
                        <span class="block font-bold text-gray-800">Add Photo</span>
                        <span class="block text-xs text-gray-500">Capture general trial image</span>
                    </div>
                </button>

                <button id="scan-action-weed"
                    class="flex items-center gap-4 p-4 bg-teal-50 hover:bg-teal-100 border border-teal-200 rounded-xl transition group">
                    <div
                        class="bg-teal-500 text-white p-3 rounded-full shadow-md group-hover:scale-110 transition-transform">
                        <i data-lucide="sprout" class="h-6 w-6"></i>
                    </div>
                    <div class="text-left">
                        <span class="block font-bold text-gray-800">Identify Weeds</span>
                        <span class="block text-xs text-gray-500">AI Weed Analysis</span>
                    </div>
                </button>

                <button id="scan-action-gallery"
                    class="flex items-center gap-4 p-4 bg-purple-50 hover:bg-purple-100 border border-purple-200 rounded-xl transition group">
                    <div
                        class="bg-purple-500 text-white p-3 rounded-full shadow-md group-hover:scale-110 transition-transform">
                        <i data-lucide="image" class="h-6 w-6"></i>
                    </div>
                    <div class="text-left">
                        <span class="block font-bold text-gray-800">Upload from Gallery</span>
                        <span class="block text-xs text-gray-500">Pick from device</span>
                    </div>
                </button>
                <input type="file" id="scan-gallery-input" accept="image/*" class="hidden">

                <button id="scan-action-detail"
                    class="flex items-center gap-4 p-4 bg-slate-50 hover:bg-slate-100 border border-slate-200 rounded-xl transition group">
                    <div
                        class="bg-slate-500 text-white p-3 rounded-full shadow-md group-hover:scale-110 transition-transform">
                        <i data-lucide="file-text" class="h-6 w-6"></i>
                    </div>
                    <div class="text-left">
                        <span class="block font-bold text-gray-800">View Details</span>
                        <span class="block text-xs text-gray-500">Full trial data & history</span>
                    </div>
                </button>
            </div>
            <div class="px-5 py-3 border-t bg-slate-50 flex justify-center">
                <button onclick="document.getElementById('scan-action-modal').classList.add('hidden')"
                    class="text-slate-500 hover:text-slate-700 text-sm font-medium px-4 py-2">
                    Cancel
                </button>
            </div>
        </div>
    </div>
    <!-- Quick Action Modal End -->

    <!-- Sidebar toggle script for mobile -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const menuToggle = document.getElementById('menu-toggle');
            const sidebar = document.getElementById('sidebar');

            if (menuToggle && sidebar) {
                // Toggle sidebar on mobile
                menuToggle.addEventListener('click', () => {
                    sidebar.classList.toggle('open');
                });

                // Close sidebar when a navigation link is clicked on mobile
                sidebar.addEventListener('click', (e) => {
                    if (window.innerWidth < 768 && e.target.closest('a[data-page]')) {
                        sidebar.classList.remove('open');
                    }
                });

                // Close sidebar when clicking on the main content area on mobile
                document.querySelector('main').addEventListener('click', () => {
                    if (window.innerWidth < 768 && sidebar.classList.contains('open')) {
                        sidebar.classList.remove('open');
                    }
                });
            }
        });
    </script>

    <!-- MAIN APPLICATION LOGIC -->
    <script type="module">
        import { GoogleGenAI, Type } from "@google/genai";

        document.addEventListener('DOMContentLoaded', () => {
            // --- STATE MANAGEMENT ---
            let state = {
                currentPage: 'dashboard',
                ingredients: [],
                formulations: [],
                trials: [],
                organisations: [],
                projects: [],
                blocks: [],
                selectedTrials: [],
                photoQueue: [],
                croppedPhotosData: [],
                currentTrialIdForCamera: null,
                cameraMode: 'general',
                aiChatHistory: [],
                aiAttachedImage: { fileData: null, mimeType: null },
                settings: {
                    apiKeys: [],
                    currentApiKeyIndex: 0,
                    scriptUrl: '',
                    sheetId: '',
                    folderId: '',
                    autoAnalyzePhotos: false,
                    qrCodeFields: { FormulationName: true, InvestigatorName: true, Date: true, Dosage: true, Location: false, Result: false, WeedSpecies: false, Weather: false },
                    qrOnlineFields: { showInvestigator: true, showDate: true, showLocation: true, showDosage: true, showWeedSpecies: true, showResult: true, showWeather: true, showIngredients: false, showConclusion: true, showPhotos: true }
                },
                charts: {},
                efficacyDataForModal: [],
                bulkAnalysisState: {
                    isRunning: false,
                    isPaused: false,
                    lastProcessedIndex: -1,
                    trialsToProcess: [],
                    totalToProcess: 0
                },
                backgroundQueue: new Map(),
                syncQueue: [], // New robust background sync queue
                aiQueue: [],
                isAiQueueRunning: false,
                // New state for persistent filters
                filterState: {
                    search: '',
                    formulationText: '', // New specific text filter
                    formulation: '',
                    startDate: '',
                    endDate: '',
                    sortBy: 'date'
                }
            };

            // --- DOM ELEMENTS ---
            const mainContent = document.getElementById('main-content');
            const modalContainer = document.getElementById('modal-container');

            // --- PROTOCOL MODAL HTML INJECTION ---
            const protocolModalHTML = `
            <div id="protocol-settings-modal" class="modal fixed inset-0 z-50 flex items-center justify-center bg-black/50 hidden">
                <div class="bg-white rounded-xl shadow-2xl w-full max-w-2xl transform transition-all scale-100 p-0 overflow-hidden">
                    <div class="bg-sky-600 p-6 flex justify-between items-center text-white">
                        <div class="flex items-center gap-3">
                            <div class="p-2 bg-white/20 rounded-lg"><i data-lucide="clipboard-list" class="h-6 w-6"></i></div>
                            <div>
                                <h3 class="text-xl font-bold">Protocol Settings</h3>
                                <p class="text-sky-100 text-sm">Define metadata for the regulatory report.</p>
                            </div>
                        </div>
                        <button onclick="closeModal()" class="text-white/80 hover:text-white transition"><i data-lucide="x" class="h-6 w-6"></i></button>
                    </div>
                    <div class="p-6 overflow-y-auto max-h-[70vh]">
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                            <div>
                                <label class="block text-sm font-semibold text-gray-700 mb-1">Investigator Name</label>
                                <input type="text" id="protocol-investigator" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-sky-500 focus:border-sky-500 transition" placeholder="e.g. Dr. Jane Doe">
                            </div>
                            <div>
                                <label class="block text-sm font-semibold text-gray-700 mb-1">Trial Location</label>
                                <input type="text" id="protocol-location" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-sky-500 focus:border-sky-500 transition" placeholder="e.g. Field 4B, Research Station">
                            </div>
                            <div>
                                <label class="block text-sm font-semibold text-gray-700 mb-1">Crop</label>
                                <input type="text" id="protocol-crop" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-sky-500 focus:border-sky-500 transition" placeholder="e.g. Soybean (Glycine max)">
                            </div>
                            <div>
                                <label class="block text-sm font-semibold text-gray-700 mb-1">Plot Size</label>
                                <input type="text" id="protocol-plot-size" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-sky-500 focus:border-sky-500 transition" placeholder="e.g. 3m x 5m">
                            </div>
                            <div>
                                <label class="block text-sm font-semibold text-gray-700 mb-1">Spray Volume</label>
                                <input type="text" id="protocol-spray-vol" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-sky-500 focus:border-sky-500 transition" placeholder="e.g. 200 L/ha">
                            </div>
                            <div>
                                <label class="block text-sm font-semibold text-gray-700 mb-1">Nozzle Type</label>
                                <input type="text" id="protocol-nozzle" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-sky-500 focus:border-sky-500 transition" placeholder="e.g. Flat Fan 11002">
                            </div>
                            <div>
                                <label class="block text-sm font-semibold text-gray-700 mb-1">Operating Pressure</label>
                                <input type="text" id="protocol-pressure" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-sky-500 focus:border-sky-500 transition" placeholder="e.g. 3 bar">
                            </div>
                            <div>
                                <label class="block text-sm font-semibold text-gray-700 mb-1">Application Equip.</label>
                                <input type="text" id="protocol-equipment" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-sky-500 focus:border-sky-500 transition" placeholder="e.g. Knapsack Sprayer">
                            </div>
                            <div class="col-span-full">
                                <label class="block text-sm font-semibold text-gray-700 mb-1">Application Dates (Details)</label>
                                <textarea id="protocol-dates" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-sky-500 focus:border-sky-500 transition" rows="2" placeholder="e.g. Pre-em: 2023-05-10, Post-em: 2023-06-01. Include stages if relevant."></textarea>
                            </div>
                        </div>
                    </div>
                    <div class="bg-gray-50 p-4 flex justify-end gap-3 border-t">
                        <button onclick="closeModal()" class="px-5 py-2 text-slate-600 font-semibold hover:bg-slate-200 rounded-lg transition">Cancel</button>
                        <button id="save-protocol-btn" onclick="saveProtocol()" class="px-5 py-2 bg-sky-600 text-white font-semibold rounded-lg shadow hover:bg-sky-700 transition flex items-center gap-2">
                             <i data-lucide="save" class="h-4 w-4"></i> Save Protocol
                        </button>
                    </div>
                </div>
            </div>`;

            // Append to body if not already present
            if (!document.getElementById('protocol-settings-modal')) {
                document.body.insertAdjacentHTML('beforeend', protocolModalHTML);
            }

            const loadingOverlay = document.getElementById('loading-overlay');
            const toast = document.getElementById('toast');
            const cropperModal = document.getElementById('cropper-modal-fixed');
            const imageToCrop = document.getElementById('image-to-crop');
            const cameraModal = document.getElementById('camera-modal-fixed');
            const videoElement = document.getElementById('camera-stream');
            const canvasElement = document.getElementById('camera-canvas');
            const qrScannerModal = document.getElementById('qr-scanner-modal-fixed');
            const qrVideo = document.getElementById('qr-video');
            let cropper = null;
            let cameraStream = null;
            let qrStream = null;
            let qrAnimationFrame = null;

            // --- CONFIGURATION ---
            // ⚠️ IMPORTANT: These values must be configured in Settings before first use!
            // Your credentials will be saved in browser localStorage (stored locally on your device only)
            const DEFAULT_SCRIPT_URL = '';
            const DEFAULT_SHEET_ID = '';
            const DEFAULT_FOLDER_ID = '';
            const CURRENCY_SYMBOL = '₹';

            // --- GEMINI AI SETUP ---
            function getActiveApiKey() {
                if (!state.settings.apiKeys || state.settings.apiKeys.length === 0) {
                    return null;
                }
                const key = state.settings.apiKeys[state.settings.currentApiKeyIndex];
                return key || null;
            }

            function getGenAIClient() {
                const activeKey = getActiveApiKey();
                if (!activeKey) {
                    showToast('Gemini API key is not set. Please configure it in Settings.', 'error');
                    switchPage('settings');
                    return null;
                }
                return new GoogleGenAI({ apiKey: activeKey });
            }

            async function testApiKey() {
                showToast('Testing API key...', 'info');

                // First, get the key from the input field (in case it hasn't been saved yet)
                const keyInputs = document.querySelectorAll('.api-key-input');
                let testKey = null;

                for (const input of keyInputs) {
                    if (input.value.trim()) {
                        testKey = input.value.trim();
                        break;
                    }
                }

                if (!testKey) {
                    testKey = getActiveApiKey();
                }

                if (!testKey) {
                    showToast('No API key to test. Please enter an API key first.', 'error');
                    return;
                }

                try {
                    // Check for input in DOM first (for testing before save)
                    const modelInput = document.getElementById('settings-api-model');
                    const modelId = modelInput ? modelInput.value : (state.settings.apiModel || 'gemini-2.0-flash-exp');

                    showToast(`Testing ${modelId}...`, 'info');
                    const genAI = new GoogleGenAI({ apiKey: testKey });

                    // Make a simple test call
                    const response = await genAI.models.generateContent({
                        model: modelId,
                        contents: [{ parts: [{ text: 'Say "API key is working!" in exactly those words.' }] }]
                    });

                    if (response && response.text) {
                        showToast('✅ API key is valid and working!', 'success');
                        console.log('API Test Response:', response.text);
                    } else {
                        showToast('⚠️ API responded but with unexpected format.', 'error');
                    }
                } catch (error) {
                    console.error('API Key Test Error:', error);
                    const errorMsg = (error.message || '').toLowerCase();

                    if (errorMsg.includes('api key not valid') || errorMsg.includes('invalid')) {
                        showToast('❌ API key is INVALID. Please check your key.', 'error');
                    } else if (errorMsg.includes('quota') || errorMsg.includes('429') || errorMsg.includes('resource exhausted')) {
                        showToast('⚠️ API key is valid but QUOTA EXHAUSTED. Wait or use different account.', 'error');
                    } else if (errorMsg.includes('permission') || errorMsg.includes('403')) {
                        showToast('❌ API key lacks permissions. Enable Generative Language API in Google Cloud.', 'error');
                    } else {
                        showToast(`❌ API Error: ${error.message}`, 'error');
                    }
                }
            }

            function rotateApiKey() {
                const keyCount = state.settings.apiKeys.length;
                if (keyCount <= 1) return false; // Cannot rotate if 0 or 1 keys

                const newIndex = (state.settings.currentApiKeyIndex + 1) % keyCount;
                state.settings.currentApiKeyIndex = newIndex;
                localStorage.setItem('appSettings', JSON.stringify(state.settings));
                showToast(`API quota likely exceeded. Trying next key (${newIndex + 1}/${keyCount})...`, 'info');

                return true;
            }

            async function _callGeminiApiWithRetries(apiCallFunction, retries = 0) {
                const maxRetries = state.settings.apiKeys.length || 1;
                if (retries >= maxRetries) {
                    throw new Error('ALL_KEYS_EXHAUSTED');
                }

                try {
                    const genAI = getGenAIClient();
                    if (!genAI) {
                        throw new Error("No valid API key found. Please add one in Settings.");
                    }
                    return await apiCallFunction(genAI);
                } catch (error) {
                    const errorMessage = (error.message || '').toLowerCase();
                    console.error('Gemini API Error:', error.message, 'Full error:', error);

                    // Check for specific error types
                    if (errorMessage.includes('api key not valid') || errorMessage.includes('invalid api key')) {
                        showToast('API key is invalid. Please check your key in Settings.', 'error');
                        throw new Error('INVALID_API_KEY: Your Gemini API key is not valid. Generate a new one at ai.google.dev');
                    }

                    if (errorMessage.includes('quota') || errorMessage.includes('resource exhausted') || errorMessage.includes('429')) {
                        console.warn(`Quota error with key index ${state.settings.currentApiKeyIndex}. Attempting rotation.`);
                        if (rotateApiKey()) {
                            await new Promise(resolve => setTimeout(resolve, 500));
                            return _callGeminiApiWithRetries(apiCallFunction, retries + 1);
                        } else {
                            // Only 1 key and it's exhausted
                            throw new Error('QUOTA_EXCEEDED: API quota exhausted. Wait a few minutes or add another API key from a different Google account.');
                        }
                    }

                    if (errorMessage.includes('permission denied') || errorMessage.includes('403')) {
                        throw new Error('API_PERMISSION_DENIED: The API key does not have permission for this operation. Enable the Generative Language API in Google Cloud Console.');
                    }

                    if (errorMessage.includes('network') || errorMessage.includes('fetch')) {
                        throw new Error('NETWORK_ERROR: Cannot connect to Gemini API. Check your internet connection.');
                    }

                    // Handle 503 - Model overloaded (temporary error, retry after delay)
                    if (errorMessage.includes('503') || errorMessage.includes('overloaded') || errorMessage.includes('unavailable')) {
                        const retryDelay = 10000 + (retries * 5000); // 10s, 15s, 20s...
                        console.warn(`Model overloaded (503). Retrying in ${retryDelay / 1000}s... (attempt ${retries + 1})`);
                        showToast(`Server busy. Retrying in ${retryDelay / 1000} seconds...`, 'info');
                        await new Promise(resolve => setTimeout(resolve, retryDelay));
                        return _callGeminiApiWithRetries(apiCallFunction, retries + 1);
                    }

                    // Handle 500 - Internal server error (temporary error, retry after delay)
                    if (errorMessage.includes('500') || errorMessage.includes('internal error') || errorMessage.includes('internal')) {
                        if (retries < 3) { // Limit 500 retries to 3 attempts
                            const retryDelay = 5000 + (retries * 3000); // 5s, 8s, 11s
                            console.warn(`Gemini internal error (500). Retrying in ${retryDelay / 1000}s... (attempt ${retries + 1}/3)`);
                            showToast(`AI server error. Retrying in ${retryDelay / 1000} seconds...`, 'info');
                            await new Promise(resolve => setTimeout(resolve, retryDelay));
                            return _callGeminiApiWithRetries(apiCallFunction, retries + 1);
                        } else {
                            throw new Error('API_ERROR: Gemini server experiencing internal errors after 3 retries. Please try again later.');
                        }
                    }

                    // For any other error, just throw it with more context
                    throw new Error(`API_ERROR: ${error.message}`);

                }
            }

            // Rate limiter: Track API call timestamps to enforce 15 RPM limit
            const apiCallTimestamps = [];
            const MAX_REQUESTS_PER_MINUTE = 15;
            const MIN_DELAY_MS = 4000; // 4 seconds = max 15 requests/minute

            function getRateLimitDelay() {
                const now = Date.now();
                // Remove timestamps older than 1 minute
                while (apiCallTimestamps.length > 0 && now - apiCallTimestamps[0] > 60000) {
                    apiCallTimestamps.shift();
                }

                // If we've made fewer than MAX requests in the last minute, calculate delay
                if (apiCallTimestamps.length >= MAX_REQUESTS_PER_MINUTE) {
                    // Wait until the oldest request expires from the window
                    const oldestTimestamp = apiCallTimestamps[0];
                    const waitTime = 60000 - (now - oldestTimestamp) + 100; // +100ms buffer
                    return Math.max(waitTime, MIN_DELAY_MS);
                }

                // Ensure minimum delay between requests
                if (apiCallTimestamps.length > 0) {
                    const lastCall = apiCallTimestamps[apiCallTimestamps.length - 1];
                    const timeSinceLastCall = now - lastCall;
                    if (timeSinceLastCall < MIN_DELAY_MS) {
                        return MIN_DELAY_MS - timeSinceLastCall;
                    }
                }

                return 0; // No delay needed
            }

            async function processAiQueue() {
                if (state.isAiQueueRunning) return;
                state.isAiQueueRunning = true;

                while (state.aiQueue.length > 0) {
                    // Check rate limit before making request
                    const delay = getRateLimitDelay();
                    if (delay > 0) {
                        console.log(`Rate limiter: waiting ${(delay / 1000).toFixed(1)}s before next API call (${apiCallTimestamps.length}/${MAX_REQUESTS_PER_MINUTE} RPM)`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }

                    const task = state.aiQueue[0];
                    try {
                        // Record this API call timestamp BEFORE the call
                        apiCallTimestamps.push(Date.now());

                        const result = await _callGeminiApiWithRetries(task.apiCallFunction);
                        task.resolve(result);
                    } catch (error) {
                        showToast(`Error in '${task.description}': ${error.message}`, 'error');
                        task.reject(error);
                    }
                    state.aiQueue.shift();
                }
                state.isAiQueueRunning = false;
            }

            function callGeminiApi(description, apiCallFunction) {
                return new Promise((resolve, reject) => {
                    state.aiQueue.push({ description, apiCallFunction, resolve, reject });
                    processAiQueue();
                });
            }

            // --- UTILITY FUNCTIONS ---
            function safeJsonParse(jsonString, defaultValue = []) {
                if (!jsonString || typeof jsonString !== 'string') return defaultValue;
                try {
                    const parsed = JSON.parse(jsonString);
                    return (typeof parsed === 'string') ? JSON.parse(parsed) : parsed;
                } catch (e) {
                    console.warn('JSON Parse Error:', e, 'Input:', jsonString);
                    return defaultValue;
                }
            }

            /**
             * Safely stringify objects, avoiding circular references and non-serializable values.
             * Automatically excludes Chart.js instances, Functions, DOM elements, and other problematic objects.
             * @param {*} obj - The object to stringify
             * @param {number} space - JSON formatting spaces (default: 0)
             * @returns {string} - Safe JSON string
             */
            function safeStringify(obj, space = 0) {
                const seen = new WeakSet();
                return JSON.stringify(obj, (key, value) => {
                    // Exclude known problematic keys
                    if (key === 'charts' || key === 'backgroundQueue') {
                        return undefined; // Don't serialize Chart.js instances or Map objects
                    }

                    // Skip functions
                    if (typeof value === 'function') {
                        return undefined;
                    }

                    // Skip DOM elements
                    if (value instanceof Element || value instanceof HTMLElement) {
                        return undefined;
                    }

                    // Handle circular references
                    if (typeof value === 'object' && value !== null) {
                        if (seen.has(value)) {
                            return undefined; // Skip circular reference
                        }
                        seen.add(value);
                    }

                    return value;
                }, space);
            }


            function sanitizeHTML(str) {
                if (typeof str !== 'string') return str;
                const temp = document.createElement('div');
                temp.textContent = str;
                return temp.innerHTML;
            }

            // --- TEMPLATES ---
            const templates = {
                page: (pageId) => ({
                    dashboard: `
                        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-6">
                            <div class="dashboard-card bg-white p-6 rounded-xl shadow-lg flex items-center gap-4"><div class="bg-teal-100 p-3 rounded-full"><i data-lucide="list-checks" class="text-teal-600"></i></div><div><p class="text-sm text-slate-500">Total Trials</p><p id="total-trials" class="text-2xl font-bold text-slate-800">0</p></div></div>
                            <div class="dashboard-card bg-white p-6 rounded-xl shadow-lg flex items-center gap-4" style="animation-delay: 0.1s;"><div class="bg-amber-100 p-3 rounded-full"><i data-lucide="loader-2" class="text-amber-600"></i></div><div><p class="text-sm text-slate-500">Active Trials</p><p id="active-trials" class="text-2xl font-bold text-slate-800">0</p></div></div>
                            <div class="dashboard-card bg-white p-6 rounded-xl shadow-lg flex items-center gap-4" style="animation-delay: 0.2s;"><div class="bg-green-100 p-3 rounded-full"><i data-lucide="check-circle-2" class="text-green-600"></i></div><div><p class="text-sm text-slate-500">Completed Trials</p><p id="completed-trials" class="text-2xl font-bold text-slate-800">0</p></div></div>
                        </div>
                        <div class="grid grid-cols-1 lg:grid-cols-5 gap-6">
                            <div class="lg:col-span-3 dashboard-card bg-white p-6 rounded-xl shadow-lg" style="animation-delay: 0.3s;"><h3 class="font-semibold text-slate-800 mb-4">Trials Over Time</h3><div class="h-80"><canvas id="trials-over-time-chart"></canvas></div></div>
                            <div class="lg:col-span-2 dashboard-card bg-white p-6 rounded-xl shadow-lg flex flex-col" style="animation-delay: 0.4s;"><h3 class="font-semibold text-slate-800 mb-4">Results Breakdown</h3><div class="h-80 flex items-center justify-center"><canvas id="results-breakdown-chart"></canvas></div></div>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mt-6">
                            <div class="dashboard-card bg-white p-6 rounded-xl shadow-lg" style="animation-delay: 0.5s;"><h3 class="font-semibold text-slate-800 mb-4 flex items-center gap-2"><i data-lucide="award" class="text-teal-600"></i> Top 10 Highest Control Days</h3><ul id="top-control-days-list" class="space-y-3 text-sm"></ul></div>
                            <div class="dashboard-card bg-white p-6 rounded-xl shadow-lg" style="animation-delay: 0.6s;"><h3 class="font-semibold text-slate-800 mb-4">Average Weather Conditions</h3><div id="avg-weather-conditions" class="grid grid-cols-2 gap-y-4 gap-x-2 text-left mt-4"></div></div>
                        </div>
                    `,
                    formulations: `<div class="flex flex-col md:flex-row justify-between items-center mb-6 gap-4"><div class="flex-grow"><input type="search" data-action="filter" data-type="formulation" placeholder="Search formulations by name..." class="w-full form-input px-4 py-2 border rounded-lg"></div><div><button data-action="openModal" data-type="formulation" class="btn-primary text-white px-4 py-2 rounded-lg shadow w-full md:w-auto flex items-center gap-2"><i data-lucide="plus"></i> New Formulation</button></div></div><div id="formulations-list" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6"></div>`,
                    trials: `
                        <div class="mb-6 border-b border-gray-200">
                            <nav class="-mb-px flex space-x-8" aria-label="Tabs">
                                <button data-action="switch-trials-tab" data-tab="standard" class="border-teal-500 text-teal-600 whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm">
                                    Standard Trials
                                </button>
                                <button data-action="switch-trials-tab" data-tab="rcbd" class="border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300 whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm">
                                    Project Plots
                                </button>
                            </nav>
                        </div>
                        <div class="bg-white p-4 rounded-lg shadow-md mb-6"><div class="flex justify-between items-center"><h3 class="font-semibold text-gray-800 mb-2">Filters & Sorting</h3><div class="flex gap-2"><button data-action="reset-filters" class="text-sm bg-red-100 text-red-700 px-3 py-1 rounded-md hover:bg-red-200">Reset Filters</button><button data-action="sort-trials" data-sort="date" class="text-sm bg-gray-200 px-3 py-1 rounded-md">Sort by Date</button><button data-action="sort-trials" data-sort="result" class="text-sm bg-gray-200 px-3 py-1 rounded-md">Sort by Result</button></div></div><div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mt-4"><input type="search" data-action="filter" data-type="trial-search" placeholder="General search (Investigator, Species)..." class="w-full px-4 py-2 border rounded-lg form-input"><input type="text" data-action="filter" data-type="trial-formulation-text" placeholder="Search by Formulation Name..." class="w-full px-4 py-2 border rounded-lg form-input bg-teal-50/50 border-teal-200"><select data-action="filter" data-type="trial-formulation" class="p-2 border rounded-lg bg-white form-input"><option value="">Filter by Formulation (List)</option></select><div class="grid grid-cols-2 gap-2"><input type="date" data-action="filter" data-type="trial-start-date" class="p-2 border rounded-lg form-input" title="Start Date"><input type="date" data-action="filter" data-type="trial-end-date" class="p-2 border rounded-lg form-input" title="End Date"></div></div></div><div class="flex justify-between items-center mb-6"><button data-action="openModal" data-type="trial" class="btn-primary text-white px-4 py-2 rounded-lg shadow w-full sm:w-auto flex items-center gap-2"><i data-lucide="plus"></i> Log New Trial</button></div>
                        <div id="trials-list-standard" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 items-stretch"></div>
                        <div id="trials-list-rcbd" class="hidden space-y-8"></div>

                        <!-- Bulk Action Bar -->
                        <div id="bulk-action-bar" class="fixed bottom-6 left-1/2 transform -translate-x-1/2 bg-slate-800 text-white px-6 py-3 rounded-full shadow-2xl flex items-center gap-6 z-50 transition-all duration-300 translate-y-20 opacity-0 hidden">
                            <span class="font-bold text-sm text-nowrap"><span id="selected-count">0</span> Selected</span>
                            <div class="h-4 w-px bg-slate-600"></div>
                            <div class="flex items-center gap-3">
                                <button data-action="go-to-compare" class="hover:text-teal-400 font-medium text-sm transition flex items-center gap-1"><i data-lucide="bar-chart-2" class="h-4 w-4"></i> Compare</button>
                                <button data-action="print-cards" class="hover:text-teal-400 font-medium text-sm transition flex items-center gap-1"><i data-lucide="printer" class="h-4 w-4"></i> Print</button>
                                <button data-action="delete-selected" class="hover:text-red-400 font-medium text-sm transition flex items-center gap-1"><i data-lucide="trash-2" class="h-4 w-4"></i> Delete</button>
                            </div>
                            <button data-action="clear-selection" class="ml-2 p-1 rounded-full hover:bg-slate-700 text-slate-400 hover:text-white"><i data-lucide="x" class="h-4 w-4"></i></button>
                        </div>
                    `,
                    compareTrials: `
                        <div class="flex flex-col h-full gap-6 pb-10">
                            <div class="bg-white p-4 rounded-lg shadow-md flex-shrink-0 flex justify-between items-center">
                                <h2 class="text-xl font-semibold text-gray-700">Comparative Analysis</h2>
                                <button data-action="export-professional-report" class="bg-teal-600 text-white px-4 py-2 rounded-lg text-sm flex items-center gap-2"><i data-lucide="file-text"></i> Export Report</button>
                            </div>
                            
                            <div id="compare-selection-warning" class="hidden flex-col items-center justify-center bg-white p-10 rounded-lg shadow-md text-center">
                                <div class="bg-amber-100 p-4 rounded-full mb-4"><i data-lucide="alert-circle" class="h-10 w-10 text-amber-600"></i></div>
                                <h3 class="text-lg font-bold text-gray-800">No Trials Selected</h3>
                                <p class="text-gray-600 max-w-md mt-2">Please go to the <strong>Trials</strong> page and select (checkbox) at least two trials to compare.</p>
                                <button onclick="switchPage('trials')" class="mt-6 btn-primary text-white px-6 py-2 rounded-lg">Go to Trials</button>
                            </div>

                            <div id="compare-content" class="flex-grow flex flex-col gap-6 overflow-y-auto">
                                <!-- Top Section: Charts & Controls -->
                                <div class="flex flex-col lg:flex-row gap-6">
                                    <!-- Controls Sidebar -->
                                    <div class="w-full lg:w-1/4 bg-white p-4 rounded-lg shadow-md space-y-6">
                                        <div>
                                            <h3 class="font-semibold text-slate-800 mb-3 border-b pb-2">Selected Trials</h3>
                                            <ul id="compare-selected-list" class="space-y-2 text-sm text-gray-600 max-h-48 overflow-y-auto"></ul>
                                        </div>
                                        
                                        <div>
                                            <h3 class="font-semibold text-slate-800 mb-3 border-b pb-2">Chart Settings</h3>
                                            <div class="space-y-4">
                                                <div>
                                                    <label class="block text-xs font-medium text-gray-600 mb-1">Weed Species</label>
                                                    <select id="compare-weed-filter" class="form-input w-full p-2 border rounded-md"></select>
                                                </div>
                                                <div>
                                                    <label class="block text-xs font-medium text-gray-600 mb-1">Metric</label>
                                                    <select id="compare-metric-filter" class="form-input w-full p-2 border rounded-md">
                                                        <option value="cover">% Cover</option>
                                                        <option value="phyto">% Phytotoxicity</option>
                                                    </select>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    <!-- Chart Area -->
                                    <div class="w-full lg:w-3/4 bg-white rounded-lg shadow-md p-4 flex flex-col min-h-[400px]">
                                        <h3 id="compare-chart-title" class="text-lg font-bold text-slate-800 mb-4 text-center">Comparison Chart</h3>
                                        <div class="flex-grow w-full relative">
                                            <canvas id="compare-chart"></canvas>
                                        </div>
                                    </div>
                                </div>

                                <!-- Bottom Section: Detailed Table -->
                                <div class="bg-white rounded-lg shadow-md p-6 overflow-x-auto">
                                    <h3 class="text-lg font-bold text-slate-800 mb-4">Detailed Side-by-Side Comparison</h3>
                                    <div id="compare-table-container"></div>
                                </div>
                            </div>
                        </div>
                    `,
                    projects: `
                        <div class="flex justify-between items-center mb-6">
                            <h2 class="text-2xl font-bold text-slate-800">All RCBD Projects</h2>
                            <button data-action="open-project-modal" class="btn-primary text-white px-4 py-2 rounded-lg shadow-md flex items-center gap-2">
                                <i data-lucide="plus"></i> New Project
                            </button>
                        </div>
                        <div id="projects-list" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6"></div>
                    `,
                    projectDashboard: `
                        <div id="project-dashboard-header" class="mb-8"></div>
                        <div class="grid grid-cols-1 lg:grid-cols-4 gap-6">
                            <div class="lg:col-span-3 space-y-6">
                                <div id="project-blocks-container" class="space-y-6"></div>
                            </div>
                            <div class="space-y-6">
                                <div id="project-actions-card" class="bg-white p-6 rounded-xl shadow-md border border-slate-100"></div>
                                <div class="bg-white p-6 rounded-xl shadow-md border border-slate-100">
                                    <h3 class="font-bold text-slate-800 mb-4">Quick Stats</h3>
                                    <div id="project-stats-content" class="space-y-2"></div>
                                </div>
                            </div>
                        </div>
                    `,
                    organisations: `<div class="flex justify-between items-center mb-6"><div><p class="text-sm text-gray-500">Group trials together for easier analysis.</p></div></div><div id="organisations-list" class="space-y-8"></div>`,
                    ingredients: `<div class="bg-white p-6 rounded-lg shadow mb-8"><h3 class="text-lg font-medium text-gray-800">Bulk Add Ingredients</h3><p class="text-sm text-gray-500 mb-2">Enter multiple ingredients in the format: Name Cost Unit, ... (e.g., Glyphosate 15000 L, Paraquat 8000 kg)</p><div class="flex gap-2"><textarea id="bulk-ingredients-cost-input" placeholder="IngredientA 100 kg, IngredientB 50 L" class="w-full p-2 border border-gray-300 rounded-md form-input" rows="4"></textarea><button type="button" data-action="apply-bulk-add-cost" class="bg-indigo-600 text-white px-4 py-2 rounded-lg self-start">Add Bulk</button></div></div><div class="flex justify-end items-center mb-6"><button data-action="openModal" data-type="ingredient" class="btn-primary text-white px-4 py-2 rounded-lg shadow flex items-center gap-2"><i data-lucide="plus"></i> Add New Cost</button></div><div id="ingredients-list" class="bg-white p-6 rounded-lg shadow"></div>`,
                    aiAssistant: `<div class="bg-white p-6 rounded-lg shadow">
                                        <div class="flex justify-between items-center mb-4"><h2 class="text-xl font-semibold text-gray-700">AI Assistant</h2><button data-action="clear-chat" class="text-sm bg-gray-200 px-3 py-1 rounded-md hover:bg-gray-300">Clear History</button></div>
                                        <div id="ai-chat-box" class="border rounded-lg p-4 overflow-y-auto mb-4 bg-gray-50 flex flex-col gap-2 h-96"></div>
                                        <div id="ai-image-preview-container" class="relative hidden w-20 mb-2"><img id="ai-image-preview" class="h-20 w-20 object-cover rounded-md border"><button data-action="remove-ai-image" class="absolute -top-2 -right-2 bg-red-500 text-white rounded-full h-5 w-5 flex items-center justify-center text-xs font-bold">&times;</button></div>
                                        <form id="ai-form" class="flex gap-4"><input type="file" id="ai-image-input" class="hidden" accept="image/*"><button type="button" data-action="attach-ai-image" class="p-2 border rounded-lg bg-gray-100 hover:bg-gray-200"><i data-lucide="paperclip" class="h-5 w-5 text-gray-600"></i></button><input type="text" id="ai-input" placeholder="Ask about your data, or attach an image..." class="flex-grow p-2 border rounded-lg form-input" required><button type="submit" class="btn-primary text-white px-5 py-2 rounded-lg flex items-center gap-2">Send <i data-lucide="send" class="h-4 w-4"></i></button></form>
                                </div>`,
                    dataMgmt: `<div class="space-y-8">
                                    <div><h2 class="text-xl font-semibold text-gray-700 mb-4">Export Data</h2><div class="bg-white p-6 rounded-lg shadow"><p class="text-gray-600 mb-4">Download your data for backup. ZIP includes photos, while Standalone HTML is a complete, viewable offline archive of the app.</p><div class="flex flex-wrap gap-4"><button data-action="export-json" class="bg-green-600 text-white px-4 py-2 rounded-lg">Export to JSON</button><button data-action="export-zip" class="bg-green-700 text-white px-4 py-2 rounded-lg">Export with Photos (ZIP)</button><button data-action="export-standalone" class="bg-blue-700 text-white px-4 py-2 rounded-lg">Export Standalone HTML</button></div></div></div>
                                    <div>
                                        <h2 class="text-xl font-semibold text-gray-700 mb-4">AI Analysis</h2>
                                        <div class="bg-white p-6 rounded-lg shadow">
                                            <p class="text-gray-600 mb-4">Intelligently generate AI summaries and efficacy data only for trials that need it. This saves time and API credits by skipping trials that are already up-to-date.</p>
                                            <div class="flex items-center gap-4">
                                                <div id="bulk-analysis-controls"></div>
                                                <div id="summary-progress" class="text-sm text-gray-600"></div>
                                            </div>
                                        </div>
                                    </div>
                                    <div><h2 class="text-xl font-semibold text-gray-700 mb-4">Import Data</h2><div class="bg-white p-6 rounded-lg shadow"><p class="text-gray-600 mb-4">Upload a previously exported JSON or ZIP file to restore your data. <strong class="text-red-600">This will overwrite all current data.</strong></p><input type="file" id="import-file-input" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100" accept=".json,.zip"><button data-action="import-data" class="mt-4 bg-blue-600 text-white px-4 py-2 rounded-lg" disabled>Import Data</button></div></div>
                                    <div><h2 class="text-xl font-semibold text-gray-700 mb-4">Clear All Data</h2><div class="bg-white p-6 rounded-lg shadow border-red-300"><p class="text-gray-600 mb-4">Permanently delete all your data. <strong class="text-red-600">This action cannot be undone.</strong></p><button data-action="clear-data" class="bg-red-600 text-white px-4 py-2 rounded-lg">Clear All Data</button></div></div>
                            </div>`,
                    settings: `
                        <div class="bg-white p-6 rounded-lg shadow space-y-8">
                            <form id="settings-form" class="space-y-8">
                                <div>
                                    <h2 class="text-xl font-semibold text-gray-700 mb-4">AI Integration (Gemini)</h2>
                                    <p class="mt-1 text-sm text-gray-600">Add one or more Google Gemini API keys. The app will automatically rotate to the next key if one exceeds its free quota.</p>
                                    
                                    <!-- API Model Selection -->
                                    <div class="mb-4 mt-4">
                                        <label class="block text-gray-700 text-sm font-bold mb-2" for="settings-api-model">
                                            Gemini API Model
                                        </label>
                                        <select id="settings-api-model" class="w-full border rounded-md shadow-sm p-2 bg-white text-sm">
                                            <!-- Recommended -->
                                            <optgroup label="Recommended (High Free Quota)">
                                                <option value="gemini-2.0-flash-exp">Gemini 2.0 Flash Experimental (1.5k RPD - Best)</option>
                                                <option value="gemini-2.0-flash-lite">Gemini 2.0 Flash-Lite (1k RPD - Legacy)</option>
                                            </optgroup>

                                            <!-- 3.0 Series (Newest) -->
                                            <optgroup label="Gemini 3.0 (Preview)">
                                                <option value="gemini-3-flash-preview">Gemini 3.0 Flash Preview</option>
                                                <option value="gemini-3-pro-preview">Gemini 3.0 Pro Preview</option>
                                            </optgroup>

                                            <!-- 2.5 Series -->
                                            <optgroup label="Gemini 2.5">
                                                <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
                                                <option value="gemini-2.5-pro">Gemini 2.5 Pro</option>
                                            </optgroup>

                                            <!-- 2.0 Series -->
                                            <optgroup label="Gemini 2.0">
                                                <option value="gemini-2.0-flash">Gemini 2.0 Flash</option>
                                                <option value="gemini-2.0-pro-exp-02-05">Gemini 2.0 Pro Experimental</option>
                                            </optgroup>

                                            <!-- Legacy / Fallback -->
                                            <optgroup label="Legacy / Standard">
                                                <option value="gemini-1.5-flash">Gemini 1.5 Flash</option>
                                                <option value="gemini-1.5-pro">Gemini 1.5 Pro</option>
                                                <option value="gemini-pro">Gemini 1.0 Pro</option>
                                            </optgroup>
                                        </select>
                                        <p class="text-xs text-gray-500 mt-1">Select <b>2.0 Flash-Exp</b> for best free limits (1,500 RPD). Change if needed.</p>
                                    </div>
                                    <div id="api-keys-container" class="mt-4 space-y-3">
                                        <!-- API key inputs will be rendered here -->
                                    </div>
                                    <div class="flex items-center gap-3 mt-3">
                                        <button type="button" data-action="add-api-key" class="text-sm text-teal-600 hover:text-teal-800 font-semibold flex items-center gap-1"><i data-lucide="plus-circle" class="h-4 w-4"></i> Add Another API Key</button>
                                        <button type="button" data-action="test-api-key" class="text-sm bg-blue-100 text-blue-700 border border-blue-200 px-3 py-1 rounded-md hover:bg-blue-200 font-semibold flex items-center gap-1"><i data-lucide="zap" class="h-4 w-4"></i> Test API Key</button>
                                    </div>
                                    
                                    <div class="mt-6 p-4 bg-amber-50 border border-amber-200 rounded-lg">
                                        <h4 class="text-sm font-semibold text-amber-800 mb-2">API Quota Saver</h4>
                                        <div class="flex items-center gap-3">
                                            <input type="checkbox" id="auto-analyze-photos" name="autoAnalyzePhotos" class="h-5 w-5 rounded border-gray-300 text-teal-600 focus:ring-teal-500">
                                            <div>
                                                <label for="auto-analyze-photos" class="text-sm font-medium text-gray-800">Auto-Analyze Photos for Efficacy</label>
                                                <p class="text-xs text-gray-500">When enabled, each photo upload uses 1 API call. Disable to save quota (weed identification still works).</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <div class="border-t pt-8">
                                    <h3 class="text-lg font-medium text-gray-900">Report Customization</h3>
                                    <p class="mt-1 text-sm text-gray-600">Configure how your trial cards and reports look.</p>
                                    <div class="mt-4 grid grid-cols-1 md:grid-cols-2 gap-6">
                                        <div>
                                            <label class="block text-sm font-medium text-gray-700">Logo</label>
                                            <div class="mt-2 flex items-center gap-4">
                                                <img id="settings-logo-preview" class="h-12 w-auto object-contain border p-1 rounded" src="" alt="Logo">
                                                <input type="file" id="settings-logo-input" accept="image/*" class="text-sm">
                                                <input type="hidden" name="logoBase64" id="settings-logo-hidden">
                                                <button type="button" onclick="document.getElementById('settings-logo-hidden').value = ''; document.getElementById('settings-logo-preview').src = '';" class="text-red-500 text-sm">Clear</button>
                                            </div>
                                        </div>
                                        <div>
                                            <label class="block text-sm font-medium text-gray-700">Card Print Size</label>
                                            <select name="cardSize" id="settings-card-size" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 form-input bg-white">
                                                <option value="ID">ID Card (Compact)</option>
                                                <option value="A6">A6 (4 per page)</option>
                                                <option value="A4">A4 (2 per page)</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>

                                <div class="border-t pt-8">
                                    <h3 class="text-lg font-medium text-gray-900">Data Source Settings</h3>
                                    <p class="mt-1 text-sm text-gray-600">Ensure these URLs match your deployed Google Apps Script, Google Sheet, and Drive Photo Folder.</p>
                                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mt-4">
                                        <div>
                                            <label class="block text-sm font-medium text-gray-700">Script URL</label>
                                            <input type="url" id="script-url" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 form-input" placeholder="https://script.google.com/macros/s/...">
                                        </div>
                                        <div>
                                            <label class="block text-sm font-medium text-gray-700">Google Sheet URL</label>
                                            <input type="url" id="sheet-url" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 form-input" placeholder="https://docs.google.com/spreadsheets/d/...">
                                        </div>
                                        <div class="md:col-span-2">
                                            <label class="block text-sm font-medium text-gray-700">Drive Photo Folder URL</label>
                                            <input type="url" id="folder-url" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 form-input" placeholder="https://drive.google.com/drive/folders/...">
                                        </div>
                                    </div>
                                </div>

                                <div class="border-t pt-8">
                                    <h3 class="text-lg font-medium text-gray-900">QR Code Content (Offline Mode)</h3>
                                    <p class="mt-1 text-sm text-amber-700 bg-amber-50 p-2 rounded-md"><strong>Warning:</strong> For stability, please select only essential fields (4-5) for offline QR codes.</p>
                                    <div id="qr-settings-grid" class="mt-4 grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
                                        <!-- Will be populated by JS -->
                                    </div>
                                </div>

                                <div class="border-t pt-8">
                                    <h3 class="text-lg font-medium text-gray-900">Global QR Content (Online Mode)</h3>
                                    <p class="mt-1 text-sm text-gray-600">Default settings for what shows up when a QR code is scanned in online mode.</p>
                                    <div id="qr-online-settings-grid" class="mt-4 grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
                                        <!-- Will be populated by JS -->
                                    </div>
                                </div>

                                <div class="border-t pt-8 flex items-center justify-between">
                                    <button type="submit" class="btn-primary text-white px-4 py-2 rounded-lg">Save All Settings</button>
                                    <button type="button" data-action="reset-data-sources" class="text-sm text-gray-500 hover:text-gray-700">Reset to Default</button>
                                </div>
                            </form>
                            
                            <div class="border-t pt-8">
                                <h3 class="text-lg font-medium text-gray-900">Troubleshooting</h3>
                                <p class="mt-1 text-sm text-gray-600">If you are experiencing issues, clear the application cache and perform a hard reload.</p>
                                <div class="mt-4"><button data-action="force-reload" class="bg-red-600 text-white px-4 py-2 rounded-lg">Clear Cache & Reload App</button></div>
                            </div>
                        </div>
                    `,
                })[pageId] || '',
                modal: (modalId, isEdit = false, data = {}) => {
                    const modalTemplates = {
                        ingredient: `<div id="ingredient-modal" class="modal"><div class="modal-content bg-white p-8 rounded-lg shadow-xl w-full max-w-md mx-auto mt-20"><h3 class="text-lg font-bold mb-4 text-slate-800">${isEdit ? 'Edit' : 'Add'} Ingredient</h3><form id="ingredient-form"><input type="hidden" name="id"><div class="mb-4"><label class="block text-sm font-medium text-gray-700">Ingredient Name</label><input type="text" name="name" required class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm form-input"></div><div class="grid grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-700">Cost</label><input type="number" name="cost" step="0.01" required class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm form-input"></div><div><label class="block text-sm font-medium text-gray-700">Base Unit</label><select name="unit" required class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm bg-white form-input"><option value="L">L</option><option value="kg">kg</option><option value="ml">ml</option><option value="gm">gm</option></select></div></div><div class="mt-6 flex justify-end space-x-3"><button type="button" data-action="close-modal" class="bg-slate-200 text-slate-800 px-4 py-2 rounded-lg transition hover:bg-slate-300">Cancel</button><button type="submit" class="btn-primary text-white px-4 py-2 rounded-lg">Save</button></div></form></div></div>`,
                        formulation: `<div id="formulation-modal" class="modal"><div class="modal-content bg-white p-8 rounded-lg shadow-xl w-full max-w-2xl mx-auto mt-10"><h3 class="text-lg font-bold mb-4 text-slate-800">${isEdit ? 'Edit' : 'Add'} Formulation</h3><form id="formulation-form"><input type="hidden" name="id"><div class="grid grid-cols-1 md:grid-cols-2 gap-6"><input type="text" name="name" required placeholder="Formulation Name" class="p-2 border rounded-md form-input"><input type="text" name="notes" placeholder="Notes" class="p-2 border rounded-md form-input"></div><div class="mt-6"><h4 class="text-md font-medium text-gray-800">Bulk Add Ingredients</h4><p class="text-sm text-gray-500 mb-2">Enter ingredients in the format: Name QuantityUnit, ...</p><div class="flex gap-2"><textarea id="bulk-ingredients-input" placeholder="Pelargonic Acid 50ML, Capric Acid 20ML" class="w-full p-2 border rounded-md form-input" rows="3"></textarea><button type="button" data-action="apply-bulk-add" class="bg-indigo-600 text-white px-4 py-2 rounded-lg self-start">Add</button></div></div><div class="mt-6"><h4 class="text-md font-medium text-gray-800">Ingredients</h4><div id="formulation-ingredients-container" class="mt-2 space-y-3"></div><button type="button" data-action="add-ingredient-row" class="mt-3 text-sm text-teal-600 hover:text-teal-800 font-semibold flex items-center gap-1"><i data-lucide="plus-circle" class="h-4 w-4"></i> Add Ingredient</button></div><div class="mt-6 border-t pt-4"><p class="font-semibold text-slate-700">Total Cost: <span id="formulation-total-cost" class="text-teal-700">${CURRENCY_SYMBOL}0.00</span></p></div><div class="mt-6 flex justify-end space-x-3"><button type="button" data-action="close-modal" class="bg-slate-200 text-slate-800 px-4 py-2 rounded-lg transition hover:bg-slate-300">Cancel</button><button type="submit" class="btn-primary text-white px-4 py-2 rounded-lg">Save</button></div></form></div></div>`,
                        trial: `<div id="trial-modal" class="modal"><div class="modal-content bg-white p-8 rounded-lg shadow-xl w-full max-w-4xl mx-auto mt-10 h-[90vh] flex flex-col"><h3 class="text-lg font-bold mb-4 text-slate-800 flex-shrink-0">${isEdit ? 'Edit' : 'Log'} Trial</h3><form id="trial-form" class="flex-grow overflow-y-auto pr-4 -mr-4"><input type="hidden" name="id"><div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                                <div class="md:col-span-2 grid grid-cols-1 md:grid-cols-2 gap-4 bg-teal-50/50 p-4 rounded-lg border border-teal-100 mb-2">
                                    <div>
                                        <label class="block text-xs font-bold text-teal-700 uppercase mb-1">Project (RCBD)</label>
                                        <select name="projectId" id="trial-project" class="w-full p-2 border rounded-md bg-white text-sm form-input">
                                            <option value="">No Project</option>
                                        </select>
                                    </div>
                                    <div>
                                        <label class="block text-xs font-bold text-teal-700 uppercase mb-1">Block / Replication</label>
                                        <select name="blockId" id="trial-block" class="w-full p-2 border rounded-md bg-white text-sm form-input">
                                            <option value="">No Block</option>
                                        </select>
                                    </div>
                                    <div class="flex items-center gap-4 mt-1">
                                        <label class="flex items-center gap-2 cursor-pointer">
                                            <input type="checkbox" name="isControl" class="h-4 w-4 rounded border-gray-300 text-teal-600">
                                            <span class="text-xs font-medium text-slate-700">Untreated Control</span>
                                        </label>
                                        <label class="flex items-center gap-2 cursor-pointer">
                                            <input type="checkbox" name="isStandardCheck" class="h-4 w-4 rounded border-gray-300 text-teal-600">
                                            <span class="text-xs font-medium text-slate-700">Standard Check</span>
                                        </label>
                                    </div>
                                </div>
                                <input type="text" name="investigatorName" required placeholder="Investigator Name" class="p-2 border rounded-md form-input" list="investigator-list"><datalist id="investigator-list"></datalist><select name="formulationId" id="trial-formulation" required class="p-2 border rounded-md bg-white form-input"></select><div class="grid grid-cols-2 gap-2"><input type="text" name="dosage" placeholder="Dosage (mL/ha)" class="p-2 border rounded-md form-input"><div class="relative"><input type="number" name="replication" id="trial-replication" placeholder="Replication #" class="p-2 border rounded-md form-input w-full"><span id="rep-lock-icon" class="hidden absolute right-2 top-1/2 -translate-y-1/2 text-slate-400" title="Locked by Block"><i data-lucide="lock" class="h-3 w-3"></i></span></div></div><div class="grid grid-cols-2 gap-2"><input type="text" name="weedSpecies" placeholder="Weed Species (comma-separated)" class="p-2 border rounded-md form-input"><input type="number" step="0.01" name="yield" placeholder="Yield (t/ha)" class="p-2 border rounded-md form-input"></div><input type="date" name="date" id="trial-date" required class="p-2 border rounded-md form-input"><select name="result" class="p-2 border rounded-md bg-white form-input"><option value="">Select Result</option><option value="Excellent">Excellent</option><option value="Good">Good</option><option value="Fair">Fair</option><option value="Poor">Poor</option></select></div>
                            <div class="md:col-span-2 mt-6 p-4 bg-slate-50 rounded-lg">
                                <h4 class="text-md font-medium text-gray-800 mb-2">Location & Weather on Trial Date</h4>
                                <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                                    <div class="md:col-span-2 flex items-center gap-2">
                                        <input type="text" name="location" placeholder="Location Name or Lat,Lon" class="p-2 border rounded-md w-full form-input">
                                        <button type="button" data-action="get-location" class="bg-slate-200 p-2 rounded-lg text-sm flex-shrink-0" title="Get Current Location"><i data-lucide="map-pin"></i></button>
                                    </div>
                                    <button type="button" data-action="fetch-trial-weather" class="btn-primary text-white px-4 py-2 rounded-lg text-sm w-full">Fetch Weather</button>
                                </div>
                                <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mt-4">
                                    <input type="text" name="temperature" placeholder="Temp (°C)" class="p-2 border rounded-md text-sm form-input">
                                    <input type="text" name="humidity" placeholder="Humidity (%)" class="p-2 border rounded-md text-sm form-input">
                                    <input type="text" name="windspeed" placeholder="Wind (km/h)" class="p-2 border rounded-md text-sm form-input">
                                    <input type="text" name="rain" placeholder="Rain (mm)" class="p-2 border rounded-md text-sm form-input">
                                </div>
                            </div>
                            <div class="md:col-span-2 p-4 bg-slate-50 rounded-lg space-y-3 mt-6">
                                <div class="flex items-center gap-2"><input type="checkbox" id="is-completed" name="isCompleted" class="h-4 w-4 rounded border-gray-300 text-teal-600 focus:ring-teal-500"><label for="is-completed" class="text-sm font-medium text-gray-800">Mark trial as Completed</label></div>
                                <div class="flex items-center gap-2"><input type="checkbox" id="control-finalized" name="controlFinalized" class="h-4 w-4 rounded border-gray-300 text-teal-600 focus:ring-teal-500"><label for="control-finalized" class="text-sm font-medium text-gray-800">Stop counting control days</label></div>
                                <div id="finalization-details" class="grid grid-cols-2 gap-4 hidden"><div><label for="finalization-date" class="block text-xs font-medium text-gray-600">Finalization Date</label><input type="date" name="finalizationDate" id="finalization-date" class="p-2 border rounded-md text-sm form-input w-full bg-slate-100"></div><div><label for="final-control-duration" class="block text-xs font-medium text-gray-600">Final Control Days</label><input type="number" name="finalControlDuration" id="final-control-duration" placeholder="Days" class="p-2 border rounded-md text-sm form-input w-full"></div></div>
                            </div>
                            <div class="mt-6 p-4 bg-slate-50 rounded-lg"><h4 class="text-md font-medium text-gray-800">Efficacy & Phyto Observations</h4><div id="efficacy-observations-container" class="mt-2 space-y-4"></div><button type="button" data-action="add-observation" class="mt-3 text-sm text-teal-600 hover:text-teal-800 font-semibold flex items-center gap-1"><i data-lucide="plus-circle" class="h-4 w-4"></i> Add Observation</button></div>
                            <div class="mt-6 grid grid-cols-1 gap-6"><textarea name="conclusion" rows="3" placeholder="Conclusion" class="p-2 border rounded-md form-input"></textarea><textarea name="notes" rows="2" placeholder="Trial Notes" class="p-2 border rounded-md form-input"></textarea></div>
                            <div class="mt-6"><h4 class="text-md font-medium text-gray-800">Add Photos with Dated Weather</h4><div class="flex items-end gap-4 mt-2"><div class="flex-grow"><label for="photo-date" class="block text-sm font-medium text-gray-700">Photo Date</label><input type="date" id="photo-date" class="mt-1 p-2 border rounded-md w-full form-input"></div><input type="file" id="trial-photos" multiple accept="image/*" class="hidden"><label for="trial-photos" class="cursor-pointer bg-white text-teal-700 px-4 py-2 rounded-lg border border-teal-700 hover:bg-teal-50 text-sm font-semibold">Choose Files</label><button type="button" data-action="open-camera" class="btn-primary text-white px-4 py-2 rounded-lg text-sm font-semibold">Camera</button></div><div id="photo-preview" class="mt-2 flex flex-wrap gap-4"></div></div>
                        </form><div class="mt-6 flex justify-end space-x-3 flex-shrink-0 border-t pt-4"><button type="button" data-action="close-modal" class="bg-slate-200 text-slate-800 px-4 py-2 rounded-lg transition hover:bg-slate-300">Cancel</button><button type="submit" form="trial-form" class="btn-primary text-white px-4 py-2 rounded-lg">Save</button></div></div></div>`,
                        confirm: `<div id="confirm-modal" class="modal"><div class="modal-content bg-white p-6 rounded-lg shadow-xl w-full max-sm mx-auto mt-20"><h3 id="confirm-title" class="text-lg font-bold mb-4">Are you sure?</h3><p id="confirm-message" class="text-gray-600 mb-6">This action cannot be undone.</p><div class="flex justify-end space-x-3"><button data-action="confirm-cancel" class="bg-slate-200 text-slate-800 px-4 py-2 rounded-lg transition hover:bg-slate-300">Cancel</button><button data-action="confirm-ok" class="bg-red-600 text-white px-4 py-2 rounded-lg">Confirm</button></div></div></div>`,
                        project: `<div id="project-modal" class="modal"><div class="modal-content bg-white p-8 rounded-lg shadow-xl w-full max-w-md mx-auto mt-20"><h3 class="text-lg font-bold mb-4 text-slate-800">${isEdit ? 'Edit' : 'New'} Project</h3><form id="project-form"><input type="hidden" name="id"><div class="space-y-4"><div><label class="block text-sm font-medium text-gray-700">Project Name</label><input type="text" name="name" required class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm form-input" placeholder="e.g. Rice Herbicide Trial 2026"></div><div><label class="block text-sm font-medium text-gray-700">Response Metric (Primary)</label><select name="metric" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm bg-white form-input" ${isEdit ? 'disabled' : ''}><option value="% Weed Cover">% Weed Cover</option><option value="Weed Dry Weight">Weed Dry Weight</option></select><p class="text-xs text-gray-500 mt-1">${isEdit ? 'Metric cannot be changed once project is created.' : 'This will be the standard response variable for all blocks.'}</p></div><div><label class="block text-sm font-medium text-gray-700">Notes (Optional)</label><textarea name="notes" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm form-input" rows="2"></textarea></div></div><div class="mt-6 flex justify-end space-x-3"><button type="button" data-action="close-modal" class="bg-slate-200 text-slate-800 px-4 py-2 rounded-lg transition hover:bg-slate-300">Cancel</button><button type="submit" class="btn-primary text-white px-4 py-2 rounded-lg">Save Project</button></div></form></div></div>`,
                        block: `<div id="block-modal" class="modal"><div class="modal-content bg-white p-8 rounded-lg shadow-xl w-full max-w-md mx-auto mt-20"><h3 class="text-lg font-bold mb-4 text-slate-800">${isEdit ? 'Edit' : 'Add'} Block</h3><form id="block-form"><input type="hidden" name="id"><input type="hidden" name="projectId" value="${data.projectId || ''}"><input type="hidden" name="replicationNum"><div class="space-y-4">
                                <div class="bg-slate-50 p-3 rounded-lg border border-slate-200 flex justify-between items-center">
                                    <span class="text-sm font-medium text-slate-600">Replication Designation</span>
                                    <span id="block-rep-display" class="font-bold text-teal-700 bg-teal-100 px-3 py-1 rounded-md">R?</span>
                                </div>
                                <div><label class="block text-sm font-medium text-gray-700">Block Name</label><input type="text" name="name" required class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm form-input" placeholder="e.g. Block A"></div></div><div class="mt-6 flex justify-end space-x-3"><button type="button" data-action="close-modal" class="bg-slate-200 text-slate-800 px-4 py-2 rounded-lg transition hover:bg-slate-300">Cancel</button><button type="submit" class="btn-primary text-white px-4 py-2 rounded-lg">Save Block</button></div></form></div></div>`,
                        randomize: `<div id="randomize-modal" class="modal"><div class="modal-content bg-white p-8 rounded-lg shadow-xl w-full max-w-2xl mx-auto mt-10"><h3 class="text-lg font-bold mb-2 text-slate-800">Randomize Plot Layout</h3>
                        <div class="mb-4 p-3 bg-teal-50 border border-teal-100 rounded-lg"><p class="text-xs font-bold text-teal-600 uppercase">Target Project</p><p class="text-lg font-bold text-teal-900">${(() => { const p = state.projects.find(x => x.ID === (data.projectId || '')); return p ? sanitizeHTML(p.Name) : '<span class="text-red-500">No Project Selected. Please navigate to a Project first.</span>'; })()}</p></div>
                        <p class="text-sm text-slate-500 mb-6">Select treatments to distribute across all blocks in this project.</p><form id="randomize-form"><input type="hidden" name="projectId" value="${data.projectId || ''}"><div class="grid grid-cols-1 md:grid-cols-2 gap-6"><div class="space-y-4"><div><label class="block text-sm font-medium text-gray-700 mb-2">Select Treatments</label><div id="randomize-formulations-list" class="max-h-60 overflow-y-auto border rounded-md p-2 space-y-1"></div></div></div><div class="space-y-4"><div><label class="block text-sm font-medium text-gray-700 mb-2">Default Plot Info</label><div class="space-y-3"><input type="text" name="investigatorName" placeholder="Investigator" class="w-full p-2 border rounded-md text-sm form-input" list="investigator-list"><input type="text" name="dosage" placeholder="Default Dosage (mL/ha)" class="w-full p-2 border rounded-md text-sm form-input"><input type="text" name="weedSpecies" placeholder="Weed Species" class="w-full p-2 border rounded-md text-sm form-input"><input type="date" name="date" class="w-full p-2 border rounded-md text-sm form-input" value="${new Date().toISOString().split('T')[0]}"></div></div></div></div><div class="mt-8 p-4 bg-teal-50 border border-teal-100 rounded-lg"><div class="flex items-start gap-3"><i data-lucide="info" class="h-5 w-5 text-teal-600 flex-shrink-0 mt-0.5"></i><div><p class="text-sm font-semibold text-teal-800">Randomization Strategy</p><p class="text-xs text-teal-700">Plots will be generated for every block. One treatment must be tagged as "Control" to enable WCE calculations later.</p></div></div></div><div class="mt-8 flex justify-end space-x-3"><button type="button" data-action="close-modal" class="bg-slate-200 text-slate-800 px-4 py-2 rounded-lg transition hover:bg-slate-300">Cancel</button><button type="submit" class="btn-primary text-white px-4 py-2 rounded-lg">Generate & Randomize</button></div></form></div></div>`,
                        photoEdit: `<div id="photo-edit-modal" class="modal"><div class="modal-content bg-white p-8 rounded-lg shadow-xl w-full max-w-lg mx-auto mt-20"><h3 class="text-lg font-bold mb-4 text-slate-800">Edit Photo Details</h3><form id="photo-edit-form"><input type="hidden" name="trialId"><input type="hidden" name="photoIndex"><div class="mb-4"><label class="block text-sm font-medium text-gray-700">Label</label><input type="text" name="label" class="mt-1 block w-full px-3 py-2 border rounded-md shadow-sm form-input"></div><div class="mb-4"><label class="block text-sm font-medium text-gray-700">Photo Date</label><input type="date" name="date" class="mt-1 block w-full px-3 py-2 border rounded-md shadow-sm form-input"></div><div class="mt-6 p-4 bg-gray-50 rounded-lg"><h4 class="text-md font-medium text-gray-800 mb-2">Weather Conditions</h4><div class="grid grid-cols-2 md:grid-cols-4 gap-4"><input type="text" name="temp" placeholder="Temp (°C)" class="p-2 border rounded-md text-sm form-input"><input type="text" name="humidity" placeholder="Humidity (%)" class="p-2 border rounded-md text-sm form-input"><input type="text" name="wind" placeholder="Wind (km/h)" class="p-2 border rounded-md text-sm form-input"><input type="text" name="rain" placeholder="Rain (mm)" class="p-2 border rounded-md text-sm form-input"></div></div><div class="mt-6 flex justify-end space-x-3"><button type="button" data-action="close-modal" class="bg-slate-200 text-slate-800 px-4 py-2 rounded-lg transition hover:bg-slate-300">Cancel</button><button type="submit" class="btn-primary text-white px-4 py-2 rounded-lg">Save Changes</button></div></form></div></div>`,
                        weedId: () => {
                            const { trial } = data;
                            if (!trial) return `<div id="weed-modal" class="modal"><div class="modal-content bg-white p-8 rounded-lg shadow-xl w-full max-w-4xl mx-auto mt-10"><p class="text-red-500">Error: Trial data could not be loaded.</p></div></div>`;
                            return `<div id="weed-modal" class="modal"><div class="modal-content bg-white p-8 rounded-lg shadow-xl w-full max-w-4xl mx-auto mt-10"><h3 class="text-xl font-bold mb-4 text-slate-800">Weed Identification for: ${sanitizeHTML(trial.FormulationName)}</h3><div class="flex items-center gap-4 mb-6"><input type="file" id="weed-photos-input" multiple accept="image/*" class="hidden" data-trial-id="${trial.ID}"><label for="weed-photos-input" class="cursor-pointer btn-primary text-white px-4 py-2 rounded-lg font-semibold">Choose Files</label><button type="button" data-action="open-weed-camera" data-trial-id="${trial.ID}" class="bg-gray-600 text-white px-4 py-2 rounded-lg hover:bg-gray-700 font-semibold">Camera</button></div><div id="weed-photo-grid" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4 h-96 overflow-y-auto bg-gray-50 p-4 rounded-lg">${safeJsonParse(trial.WeedPhotosJSON).map((p, index) => render.weedPhotoCard(p, trial.ID, index)).join('')}</div><div class="mt-6 flex justify-end"><button type="button" data-action="close-modal" class="bg-slate-200 text-slate-800 px-4 py-2 rounded-lg transition hover:bg-slate-300">Done</button></div></div></div>`;
                        },
                        reportPreview: `<div id="report-preview-modal" class="modal"><div class="modal-content bg-white p-8 rounded-lg shadow-xl w-full max-w-3xl mx-auto mt-10 h-[90vh] flex flex-col"><h3 class="text-xl font-bold mb-4 text-slate-800">Prepare Efficacy Report</h3><div id="report-content" class="space-y-6 flex-grow overflow-y-auto pr-4">
                            <div class="bg-teal-50 p-4 rounded-lg border border-teal-100 mb-4 flex gap-6 flex-wrap">
                                <div class="flex items-center gap-3">
                                    <input type="checkbox" id="show-photo-dates" data-action="toggle-photo-dates" class="h-4 w-4 text-teal-600 rounded" ${state.settings.showPhotoDates ? 'checked' : ''}>
                                    <label for="show-photo-dates" class="text-sm font-medium text-teal-900">Show photo dates</label>
                                </div>
                                <div class="flex items-center gap-3">
                                    <input type="checkbox" id="include-timeline" data-action="toggle-include-timeline" class="h-4 w-4 text-teal-600 rounded" ${state.settings.includeTimeline ? 'checked' : ''}>
                                    <label for="include-timeline" class="text-sm font-medium text-teal-900">Include Weed Status Timeline</label>
                                </div>
                            </div>
                            <div id="cover-report-section" class="hidden"><h4 class="text-md font-semibold text-slate-700">% Cover by Species</h4><div id="cover-chart-preview" class="relative h-[300px] w-full my-2 bg-slate-100 rounded-lg p-2"><canvas id="preview-cover-canvas"></canvas></div><div class="flex justify-between items-end mt-2"><label for="cover-summary-textarea" class="block text-sm font-medium text-gray-700">AI Generated Summary (Editable)</label><button id="regenerate-cover-summary" class="text-xs text-teal-600 hover:text-teal-800 font-semibold flex items-center gap-1"><i data-lucide="refresh-cw" class="h-3 w-3"></i> Regenerate</button></div><textarea id="cover-summary-textarea" class="w-full p-2 border rounded-md form-input mt-1" rows="4" placeholder="Generating summary..."></textarea></div><div id="phyto-report-section" class="hidden"><h4 class="text-md font-semibold text-slate-700">% Phytotoxicity</h4><div id="phyto-chart-preview" class="relative h-[300px] w-full my-2 bg-slate-100 rounded-lg p-2"><canvas id="preview-phyto-canvas"></canvas></div><div class="flex justify-between items-end mt-2"><label for="phyto-summary-textarea" class="block text-sm font-medium text-gray-700">AI Generated Summary (Editable)</label><button id="regenerate-phyto-summary" class="text-xs text-teal-600 hover:text-teal-800 font-semibold flex items-center gap-1"><i data-lucide="refresh-cw" class="h-3 w-3"></i> Regenerate</button></div><textarea id="phyto-summary-textarea" class="w-full p-2 border rounded-md form-input mt-1" rows="4" placeholder="Generating summary..."></textarea></div></div><div class="mt-6 flex justify-end gap-3 border-t pt-4"><button type="button" data-action="close-modal" class="bg-slate-200 text-slate-800 px-4 py-2 rounded-lg">Cancel</button><button id="generate-pdf-from-preview" class="btn-primary text-white px-4 py-2 rounded-lg flex items-center gap-2"><i data-lucide="download" class="h-4 w-4"></i> Generate & Download PDF</button></div></div></div>`,
                        qrLabel: () => {
                            const { trial, qrContent, mode } = data;
                            return `<div id="qr-label-modal" class="modal"><div class="modal-content bg-white p-6 rounded-lg shadow-xl w-full max-w-sm mx-auto mt-20 text-center"><h3 class="text-xl font-bold mb-1 text-slate-800">${sanitizeHTML(trial.FormulationName)}</h3><p class="text-xs text-slate-400 mb-4">${mode.toUpperCase()} MODE</p><div id="qr-code-canvas" class="flex justify-center mb-4 border p-2 bg-white rounded-lg shadow-inner"></div><div class="text-left bg-slate-50 p-3 rounded text-[10px] font-mono mb-4 break-all overflow-auto max-h-24 border border-slate-200">${sanitizeHTML(qrContent).replace(/\n/g, '<br>')}</div><p class="text-xs text-slate-500 mb-6 px-4">Scan this code with a phone camera to ${mode === 'online' ? 'open the live report' : 'view the plot data'}.</p><div class="flex gap-2 justify-center"><button onclick="window.print()" class="bg-slate-800 text-white px-4 py-2 rounded-lg text-sm flex items-center gap-2 font-medium"><i data-lucide="printer" class="h-3 w-3"></i> Print Label</button><button data-action="close-modal" class="bg-slate-100 text-slate-600 px-4 py-2 rounded-lg text-sm font-medium">Close</button></div></div></div>`;
                        },
                        trialDetail: () => {
                            const { trial } = data;
                            if (!trial) return '';
                            const photos = safeJsonParse(trial.PhotoURLs);
                            const photoTable = photos.length > 0 ? `<div class="mt-4"><h4 class="text-lg font-semibold mb-2 text-slate-700">Photo Log & Weather</h4><div class="overflow-x-auto rounded-lg border"><table class="min-w-full divide-y divide-gray-200 text-sm"><thead class="bg-slate-50"><tr><th class="px-4 py-2 text-left font-medium text-slate-500">Photo</th><th class="px-4 py-2 text-left font-medium text-slate-500">Label</th><th class="px-4 py-2 text-left font-medium text-slate-500">Date</th><th class="px-4 py-2 text-left font-medium text-slate-500">Weather</th><th class="px-4 py-2 text-left font-medium text-slate-500">Actions</th></tr></thead><tbody class="bg-white divide-y divide-gray-200">${photos.map((p, index) => { const photoUrl = p.url || p.fileData; if (!photoUrl) return ''; const proxiedUrl = photoUrl.startsWith('data:image') ? photoUrl : `https://images.weserv.nl/?url=${encodeURIComponent(photoUrl)}&w=100`; const fullSizeUrl = photoUrl.startsWith('data:image') ? '#' : photoUrl; const weather = p.weather || {}; return `<tr><td class="p-2"><a href="${fullSizeUrl}" target="_blank"><img src="${proxiedUrl}" class="h-16 w-16 object-cover rounded-md border"></a></td><td class="p-2">${sanitizeHTML(p.label) || '-'}</td><td class="p-2">${p.date ? new Date(p.date).toLocaleDateString() : 'N/A'}</td><td class="p-2">${weather.temp ? `${weather.temp}°C, ${weather.humidity}% H, ${weather.wind} km/h` : 'N/A'}</td><td class="p-2"><button data-action="open-photo-edit-modal" data-trial-id="${trial.ID}" data-photo-index="${index}" class="text-teal-600 hover:text-teal-800 font-semibold text-xs">Edit</button></td></tr>` }).join('')}</tbody></table></div></div>` : '<p class="mt-4 text-gray-500">No photos available.</p>';
                            const weedPhotos = safeJsonParse(trial.WeedPhotosJSON);
                            const weedTable = weedPhotos.length > 0 ? `<div class="mt-6"><h4 class="text-lg font-semibold mb-2 text-slate-700">Weed Identification</h4><div class="grid grid-cols-1 md:grid-cols-2 gap-4">${weedPhotos.map(p => { const bestMatch = p.identifications?.[0]; return `<div class="border rounded-lg p-3 bg-slate-50"><img src="https://images.weserv.nl/?url=${encodeURIComponent(p.url)}&w=300" class="rounded-md w-full h-48 object-cover mb-2"><p class="font-semibold text-sm">${sanitizeHTML(bestMatch?.name) || 'Unknown'} <em class="text-gray-500 font-normal">${sanitizeHTML(bestMatch?.commonNames?.[0]) || ''}</em></p><p class="text-xs text-gray-500">Confidence: ${bestMatch?.confidence ? (bestMatch.confidence * 100).toFixed(1) + '%' : 'N/A'}</p></div>` }).join('')}</div></div>` : '';
                            const efficacyData = safeJsonParse(trial.EfficacyDataJSON);
                            const hasEfficacyData = efficacyData.length > 0;
                            const efficacyCharts = hasEfficacyData ? `<div class="mt-6 col-span-1 md:col-span-2"><h4 class="text-lg font-semibold mb-2 text-slate-700">Efficacy Over Time</h4><p class="text-xs text-gray-500 -mt-2 mb-4">Each line in the '% Cover' chart represents a unique weed species identified across all trial observations.</p><div class="grid grid-cols-1 lg:grid-cols-2 gap-8"><div class="bg-slate-50 p-4 rounded-lg"><h5 class="text-md font-semibold mb-2 text-slate-700">% Cover by Species</h5><div class="h-64"><canvas id="single-cover-chart"></canvas></div></div><div class="bg-slate-50 p-4 rounded-lg"><h5 class="text-md font-semibold mb-2 text-slate-700">% Phytotoxicity</h5><div class="h-64"><canvas id="single-phyto-chart"></canvas></div></div></div></div>` : '<div class="mt-6 col-span-1 md:col-span-2"><p class="text-gray-500">No quantitative efficacy data logged for this trial.</p></div>';
                            const weedStatusTable = hasEfficacyData ? `<div class="mt-6 col-span-1 md:col-span-2"><h4 class="text-lg font-semibold mb-2 text-slate-700">Weed Status Timeline</h4><div class="overflow-x-auto rounded-lg border"><table class="min-w-full divide-y divide-gray-200 text-sm"><thead class="bg-slate-50"><tr><th class="px-4 py-2 text-left font-medium text-slate-500">DA-A</th><th class="px-4 py-2 text-left font-medium text-slate-500">Species</th><th class="px-4 py-2 text-left font-medium text-slate-500">Status</th><th class="px-4 py-2 text-left font-medium text-slate-500">Notes</th></tr></thead><tbody class="bg-white divide-y divide-gray-200">${efficacyData.flatMap(obs => (obs.weedDetails || []).map(wd => `<tr><td class="p-2 font-semibold">${obs.daa}</td><td class="p-2">${sanitizeHTML(wd.species)}</td><td class="p-2">${sanitizeHTML(wd.status)}</td><td class="p-2">${sanitizeHTML(wd.notes)}</td></tr>`)).join('')}</tbody></table></div></div>` : '';

                            // Statistics Rendering Logic
                            let statsContent = `<div class="p-10 flex flex-col items-center justify-center text-gray-500 gap-4">
                                <p>No statistical data available yet.</p>
                                <button onclick="calculateAndSaveTrialStats('${trial.ID}')" class="bg-teal-600 text-white px-4 py-2 rounded-lg hover:bg-teal-700 transition shadow-sm font-semibold flex items-center gap-2">
                                    <i data-lucide="calculator" class="h-4 w-4"></i> Calculate Statistics
                                </button>
                            </div>`;
                            const stats = safeJsonParse(trial.StatisticsJSON);
                            if (stats && (stats.wce || stats.anovaResults)) {
                                let wceTable = '';
                                if (stats.wce && stats.wce.length > 0) {
                                    wceTable = `<div class="mb-6"><h4 class="text-md font-bold text-slate-800 mb-2">Weed Control Efficiency (WCE)</h4><div class="overflow-x-auto border rounded-lg"><table class="min-w-full divide-y divide-gray-200 text-sm"><thead class="bg-slate-50"><tr><th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase">Species</th><th class="px-3 py-2 text-right text-xs font-medium text-gray-500 uppercase">Init Cover</th><th class="px-3 py-2 text-right text-xs font-medium text-gray-500 uppercase">Final Cover</th><th class="px-3 py-2 text-right text-xs font-medium text-gray-500 uppercase">WCE %</th><th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase">Rating</th></tr></thead><tbody class="divide-y divide-gray-200 bg-white">${stats.wce.map(w => `<tr><td class="px-3 py-2 font-medium">${sanitizeHTML(w.species)}</td><td class="px-3 py-2 text-right text-gray-500">${w.initialCover}%</td><td class="px-3 py-2 text-right text-gray-500">${w.finalCover}%</td><td class="px-3 py-2 text-right font-bold ${w.wce >= 80 ? 'text-green-600' : 'text-amber-600'}">${w.wce.toFixed(1)}%</td><td class="px-3 py-2"><span class="px-2 py-0.5 rounded text-xs ${w.controlRating === 'Excellent' ? 'bg-green-100 text-green-800' : 'bg-gray-100 text-gray-800'}">${w.controlRating}</span></td></tr>`).join('')}</tbody></table></div></div>`;
                                }

                                let anovaContent = '';
                                if (stats.anovaResults && stats.anovaResults.anovaTable) {
                                    const at = stats.anovaResults.anovaTable;
                                    anovaContent = `<div class="mb-6"><h4 class="text-md font-bold text-slate-800 mb-2 flex items-center gap-2">ANOVA Results (WCE) <span class="bg-teal-100 text-teal-800 text-[10px] px-2 py-0.5 rounded-full uppercase">Computed: ${new Date(stats.calculatedAt).toLocaleDateString()}</span></h4><div class="overflow-x-auto border rounded-lg mb-4"><table class="min-w-full divide-y divide-gray-200 text-sm"><thead class="bg-slate-50"><tr><th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase">Source</th><th class="px-3 py-2 text-right text-xs font-medium text-gray-500 uppercase">DF</th><th class="px-3 py-2 text-right text-xs font-medium text-gray-500 uppercase">SS</th><th class="px-3 py-2 text-right text-xs font-medium text-gray-500 uppercase">MS</th><th class="px-3 py-2 text-right text-xs font-medium text-gray-500 uppercase">F</th><th class="px-3 py-2 text-right text-xs font-medium text-gray-500 uppercase">P > F</th><th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase">Sig</th></tr></thead><tbody class="divide-y divide-gray-200 bg-white">
                                    ${[at.treatment, at.block, at.error, at.total].map(row => `<tr><td class="px-3 py-2 font-medium">${row.source}</td><td class="px-3 py-2 text-right text-gray-500">${row.df}</td><td class="px-3 py-2 text-right text-gray-500">${row.ss.toFixed(2)}</td><td class="px-3 py-2 text-right text-gray-500">${row.ms ? row.ms.toFixed(2) : ''}</td><td class="px-3 py-2 text-right text-gray-500">${row.f ? row.f.toFixed(2) : ''}</td><td class="px-3 py-2 text-right text-gray-500">${row.p ? row.p.toFixed(4) : ''}</td><td class="px-3 py-2 font-bold">${row.sig || ''}</td></tr>`).join('')}
                                    </tbody></table></div><div class="grid grid-cols-2 gap-4 text-xs text-gray-600 mb-4"><div class="p-2 bg-slate-50 rounded"><strong>CV:</strong> ${stats.anovaResults.diagnostics.cv.toFixed(2)}%</div><div class="p-2 bg-slate-50 rounded"><strong>R²:</strong> ${stats.anovaResults.diagnostics.r_squared.toFixed(4)}</div></div>`;
                                }

                                let lsdContent = '';
                                if (stats.lsdResults && stats.lsdResults.groupings) {
                                    lsdContent = `<div class="mb-6"><h4 class="text-md font-bold text-slate-800 mb-2">Detailed Groupings (Fisher's LSD)</h4><p class="text-xs text-gray-500 mb-2">Alpha = ${stats.lsdResults.alpha}, LSD = ${stats.lsdResults.lsd.toFixed(2)}</p><div class="overflow-x-auto border rounded-lg"><table class="min-w-full divide-y divide-gray-200 text-sm"><thead class="bg-slate-50"><tr><th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase">Treatment</th><th class="px-3 py-2 text-right text-xs font-medium text-gray-500 uppercase">Mean WCE</th><th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase">Group</th></tr></thead><tbody class="divide-y divide-gray-200 bg-white">${stats.lsdResults.groupings.map(g => `<tr><td class="px-3 py-2 font-medium">${sanitizeHTML(g.name)}</td><td class="px-3 py-2 text-right">${g.mean.toFixed(2)}%</td><td class="px-3 py-2 font-bold text-teal-700">${g.grouping}</td></tr>`).join('')}</tbody></table></div></div>`;
                                }

                                statsContent = `<div class="p-4">${wceTable}${anovaContent}${lsdContent}</div>`;
                            }

                            return `<div id="trial-detail-modal" class="modal"><div class="modal-content bg-white p-8 rounded-lg shadow-xl w-full max-w-6xl mx-auto mt-10 h-[90vh] flex flex-col">
                                <canvas id="single-cover-chart" class="hidden"></canvas><canvas id="single-phyto-chart" class="hidden"></canvas> <!-- Hidden canvases to prevent JS error on loop, actual charts in report tab -->
                                <div class="flex justify-between items-center mb-4 border-b pb-4">
                                    <h3 class="text-2xl font-bold text-slate-800 truncate">${sanitizeHTML(trial.FormulationName)}</h3>
                                    <div class="flex space-x-4">
                                        <button onclick="window.switchTrialDetailTab('report')" data-tab="report" class="trial-detail-tab-btn text-teal-600 border-b-2 border-teal-600 font-bold pb-1 text-sm transition">Report View</button>
                                        <button onclick="window.switchTrialDetailTab('stats')" data-tab="stats" class="trial-detail-tab-btn text-gray-500 pb-1 text-sm hover:text-gray-700 transition">Statistics</button>
                                    </div>
                                </div>
                                <div class="flex-grow overflow-y-auto pr-4">
                                    
                                    <!-- REPORT TAB -->
                                    <div id="trial-detail-report" class="trial-detail-content">
                                        <div class="grid grid-cols-1 md:grid-cols-2 gap-8"><div class="space-y-2 text-gray-800"><p><strong>Investigator:</strong> ${sanitizeHTML(trial.InvestigatorName) || 'N/A'}</p><p><strong>Location:</strong> ${sanitizeHTML(trial.Location) || 'N/A'}</p><p><strong>Dosage:</strong> ${sanitizeHTML(trial.Dosage) || 'N/A'}</p><p><strong>Weed Species:</strong> ${sanitizeHTML(trial.WeedSpecies) || 'N/A'}</p><p><strong>Date:</strong> ${new Date(trial.Date).toLocaleDateString()}</p><p><strong>Result:</strong> ${sanitizeHTML(trial.Result) || 'N/A'}</p>${trial.Temperature ? `<div class="mt-4 pt-4 border-t"><p class="font-semibold text-gray-500 text-sm">Weather on Trial Date</p><p><strong>Temperature:</strong> ${trial.Temperature}°C</p><p><strong>Humidity:</strong> ${trial.Humidity}%</p><p><strong>Wind:</strong> ${trial.Windspeed} km/h</p><p><strong>Rain:</strong> ${trial.Rain} mm</p></div>` : ''}<div class="mt-4 pt-4 border-t"><p><strong>Conclusion:</strong> ${sanitizeHTML(trial.Conclusion) || 'N/A'}</p><p><strong>Notes:</strong> ${sanitizeHTML(trial.Notes) || 'N/A'}</p></div></div><div>${photoTable} ${weedTable}</div>${efficacyCharts} ${weedStatusTable}</div>
                                    </div>

                                    <!-- STATISTICS TAB -->
                                    <div id="trial-detail-stats" class="trial-detail-content hidden">
                                        ${statsContent}
                                    </div>

                                </div>
                                <div class="mt-8 border-t pt-6">
                                <div class="bg-teal-50 p-4 rounded-lg mb-6 flex flex-wrap gap-6 items-center border border-teal-100">
                                    <div class="flex items-center gap-2">
                                        <input type="checkbox" id="show-photo-dates-detail" data-action="toggle-photo-dates" class="h-4 w-4 text-teal-600 rounded" ${state.settings.showPhotoDates ? 'checked' : ''}>
                                        <label for="show-photo-dates-detail" class="text-sm font-medium text-teal-900">Show photo dates</label>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <input type="checkbox" id="include-timeline-detail" data-action="toggle-include-timeline" class="h-4 w-4 text-teal-600 rounded" ${state.settings.includeTimeline ? 'checked' : ''}>
                                        <label for="include-timeline-detail" class="text-sm font-medium text-teal-900">Include Weed Status Timeline</label>
                                    </div>
                                </div>
                                <div class="flex flex-wrap justify-center gap-3 flex-shrink-0">
                                    <button data-action="export-pdf-ingredients" data-id="${trial.ID}" class="bg-gray-200 text-gray-800 px-4 py-2 rounded-lg text-sm transition hover:bg-gray-300">PDF (Ingredients)</button>
                                    <button data-action="export-pdf-no-ingredients" data-id="${trial.ID}" class="bg-gray-200 text-gray-800 px-4 py-2 rounded-lg text-sm transition hover:bg-gray-300">PDF (No Ing.)</button>
                                    <button data-action="export-pdf-weeds-ingredients" data-id="${trial.ID}" class="bg-blue-100 text-blue-800 px-4 py-2 rounded-lg text-sm font-semibold transition hover:bg-blue-200">PDF (Weeds + Ing.)</button>
                                    <button data-action="export-pdf-weeds" data-id="${trial.ID}" class="bg-blue-100 text-blue-800 px-4 py-2 rounded-lg text-sm font-semibold transition hover:bg-blue-200">PDF (Weeds)</button>
                                    ${hasEfficacyData ? `<button data-action="export-pdf-efficacy-no-ingredients" data-id="${trial.ID}" class="bg-teal-100 text-teal-800 px-4 py-2 rounded-lg text-sm font-semibold transition hover:bg-teal-200">Full Report (No Ing.)</button>` : ''}
                                    ${hasEfficacyData ? `<button data-action="export-pdf-with-report" data-id="${trial.ID}" class="bg-teal-100 text-teal-800 px-4 py-2 rounded-lg text-sm font-semibold transition hover:bg-teal-200">Full Report (w/ Ing.)</button>` : ''}
                                    <button data-action="export-ppt" data-id="${trial.ID}" class="bg-orange-100 text-orange-800 px-4 py-2 rounded-lg text-sm font-semibold transition hover:bg-orange-200">Export PPT</button>
                                    <button data-action="close-modal" class="btn-primary text-white px-4 py-2 rounded-lg text-sm">Go Back</button>
                            </div></div></div>`;
                        },
                        organise: `<div id="organise-modal" class="modal"><div class="modal-content bg-white p-8 rounded-lg shadow-xl w-full max-w-md mx-auto mt-20"><h3 class="text-lg font-bold mb-4 text-slate-800">Add to Organisation</h3><form id="organise-form"><div class="mb-4"><label class="block text-sm font-medium text-gray-700">Select Existing Organisation</label><select name="organisationId" id="existing-organisations" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm form-input"><option value="">-- Choose existing --</option>${state.organisations.map(o => `<option value="${o.ID}">${sanitizeHTML(o.Name)}</option>`).join('')}</select></div><div class="text-center my-2 text-gray-500">OR</div><div class="mb-4"><label class="block text-sm font-medium text-gray-700">Create New Organisation</label><input type="text" name="newOrganisationName" placeholder="e.g., Summer 2025 Variants" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm form-input"></div><div class="mt-6 flex justify-end space-x-3"><button type="button" data-action="close-modal" class="bg-slate-200 text-slate-800 px-4 py-2 rounded-lg transition hover:bg-slate-300">Cancel</button><button type="submit" class="btn-primary text-white px-4 py-2 rounded-lg">Save</button></div></form></div></div>`,
                        qrModeChoice: () => {
                            const { trial } = data;
                            return `<div id="qr-mode-modal" class="modal"><div class="modal-content bg-white p-8 rounded-lg shadow-xl w-full max-w-md mx-auto mt-20"><h3 class="text-lg font-bold mb-4 text-slate-800">Choose QR Code Type</h3><p class="text-sm text-gray-600 mb-6">Select how you want to generate the QR code for: <strong>${sanitizeHTML(trial.FormulationName)}</strong></p><div class="flex flex-col space-y-4"><button data-action="generate-qr-final" data-id="${trial.ID}" data-mode="offline" class="w-full text-left p-4 rounded-lg bg-slate-50 border border-slate-200 hover:bg-teal-50 hover:border-teal-200 transition"><p class="font-bold text-slate-800">Offline Mode</p><p class="text-xs text-slate-500 mt-1">Encodes data directly in the QR. No internet needed to scan, but content is limited.</p></button><button data-action="generate-qr-final" data-id="${trial.ID}" data-mode="online" class="w-full text-left p-4 rounded-lg bg-slate-50 border border-slate-200 hover:bg-teal-50 hover:border-teal-200 transition"><p class="font-bold text-slate-800">Online Mode (Live)</p><p class="text-xs text-slate-500 mt-1">Links to a live web page. Allows photos, ingredients, and updates without re-printing.</p></button></div><div class="mt-6 flex justify-end"><button type="button" data-action="close-modal" class="bg-slate-200 text-slate-800 px-4 py-2 rounded-lg transition hover:bg-slate-300">Cancel</button></div></div></div>`;
                        },
                        liveQrSettings: () => {
                            const { trial } = data;
                            let currentSettings = {};
                            try {
                                currentSettings = safeJsonParse(trial.LiveQRSettings, state.settings.qrOnlineFields);
                            } catch (e) {
                                currentSettings = state.settings.qrOnlineFields;
                            }
                            const fieldsHtml = Object.keys(state.settings.qrOnlineFields).map(key => {
                                const label = key.replace('show', '').replace(/([A-Z])/g, ' $1');
                                return `<label class="flex items-center gap-2"><input type="checkbox" name="${key}" ${currentSettings[key] ? 'checked' : ''} class="h-4 w-4 rounded border-gray-300 text-teal-600 focus:ring-teal-500"> ${label}</label>`;
                            }).join('');

                            return `<div id="live-qr-modal" class="modal"><div class="modal-content bg-white p-8 rounded-lg shadow-xl w-full max-w-lg mx-auto mt-10"><h3 class="text-xl font-bold mb-2 text-slate-800">Live QR Settings</h3><p class="text-sm text-gray-500 mb-6 border-b pb-2">Individual content control for: <strong>${sanitizeHTML(trial.FormulationName)}</strong></p><form id="live-qr-settings-form" data-id="${trial.ID}" class="grid grid-cols-2 md:grid-cols-3 gap-4 text-sm">${fieldsHtml}</form><div class="mt-8 flex justify-end gap-3 border-t pt-4"><button type="button" data-action="close-modal" class="bg-slate-200 text-slate-800 px-4 py-2 rounded-lg">Cancel</button><button type="button" data-action="save-live-qr-settings-final" class="btn-primary text-white px-5 py-2 rounded-lg">Save Settings</button></div></div></div>`;
                        }
                    };
                    const template = modalTemplates[modalId];
                    return typeof template === 'function' ? template() : (template || '');
                }
            };

            const render = {
                apiKeyInput: (key = '', index) => {
                    return `
                        <div class="flex items-center gap-2 api-key-row">
                            <input type="password" value="${sanitizeHTML(key)}" class="api-key-input mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 form-input" placeholder="Enter Gemini API Key">
                            <button type="button" data-action="remove-api-key" data-index="${index}" class="text-red-500 hover:text-red-700 font-bold p-1">&times;</button>
                        </div>
                    `;
                },
                dashboard: () => {
                    Object.values(state.charts).forEach(chart => { if (chart) chart.destroy() });
                    state.charts = {};
                    const trials = state.trials || [];
                    const formulations = state.formulations || [];
                    document.getElementById('total-trials').textContent = String(trials.length);
                    document.getElementById('completed-trials').textContent = String(trials.filter(t => String(t.IsCompleted).toLowerCase() === 'true').length);
                    document.getElementById('active-trials').textContent = String(trials.length - trials.filter(t => String(t.IsCompleted).toLowerCase() === 'true').length);
                    const weatherTrials = trials.filter(t => t.Temperature && t.Humidity && t.Windspeed);
                    let avgTemp = 0, avgHumidity = 0, avgWind = 0, avgRain = 0;
                    if (weatherTrials.length > 0) {
                        avgTemp = weatherTrials.reduce((sum, t) => sum + parseFloat(t.Temperature), 0) / weatherTrials.length;
                        avgHumidity = weatherTrials.reduce((sum, t) => sum + parseFloat(t.Humidity), 0) / weatherTrials.length;
                        avgWind = weatherTrials.reduce((sum, t) => sum + parseFloat(t.Windspeed), 0) / weatherTrials.length;
                        avgRain = weatherTrials.reduce((sum, t) => sum + parseFloat(t.Rain || 0), 0) / weatherTrials.length;
                    }
                    const weatherEl = document.getElementById('avg-weather-conditions');
                    if (weatherEl) {
                        weatherEl.innerHTML = `<div class="flex items-center gap-3"><div class="bg-blue-100 p-2 rounded-full"><i data-lucide="thermometer" class="h-5 w-5 text-blue-600"></i></div><div><p class="font-bold text-slate-700">${avgTemp.toFixed(1)}°C</p><p class="text-xs text-slate-500">Avg. Temp</p></div></div><div class="flex items-center gap-3"><div class="bg-sky-100 p-2 rounded-full"><i data-lucide="droplets" class="h-5 w-5 text-sky-600"></i></div><div><p class="font-bold text-slate-700">${avgHumidity.toFixed(1)}%</p><p class="text-xs text-slate-500">Avg. Humidity</p></div></div><div class="flex items-center gap-3"><div class="bg-slate-100 p-2 rounded-full"><i data-lucide="wind" class="h-5 w-5 text-slate-600"></i></div><div><p class="font-bold text-slate-700">${avgWind.toFixed(1)} km/h</p><p class="text-xs text-slate-500">Avg. Wind</p></div></div><div class="flex items-center gap-3"><div class="bg-indigo-100 p-2 rounded-full"><i data-lucide="cloud-rain" class="h-5 w-5 text-indigo-600"></i></div><div><p class="font-bold text-slate-700">${avgRain.toFixed(1)} mm</p><p class="text-xs text-slate-500">Avg. Rain</p></div></div>`;
                        lucide.createIcons();
                    }

                    // Top Control Days Calculation
                    const trialsWithDuration = trials.map(t => {
                        let duration = 0;
                        if (String(t.ControlFinalized).toLowerCase() === 'true' && t.FinalControlDuration != null) {
                            duration = parseInt(t.FinalControlDuration, 10);
                        } else if (t.Date) {
                            duration = Math.floor((new Date() - new Date(t.Date)) / (1000 * 60 * 60 * 24));
                            if (duration < 0) duration = 0;
                        }
                        return { ...t, computedDuration: duration };
                    });
                    trialsWithDuration.sort((a, b) => b.computedDuration - a.computedDuration);
                    const topControlList = document.getElementById('top-control-days-list');
                    if (topControlList) {
                        topControlList.innerHTML = trialsWithDuration.slice(0, 10).map(t =>
                            `<li class="flex justify-between items-center"><span class="text-slate-600 truncate w-2/3">${sanitizeHTML(t.FormulationName)}</span><span class="font-bold text-teal-700">${t.computedDuration} Days</span></li>`
                        ).join('') || '<p class="text-slate-500">No trials active.</p>';
                    }

                    // Trials over time chart
                    const trialsByDate = trials.reduce((acc, trial) => {
                        const date = new Date(trial.Date);
                        date.setHours(0, 0, 0, 0);
                        const dateStr = date.toISOString().split('T')[0];
                        acc[dateStr] = (acc[dateStr] || 0) + 1;
                        return acc;
                    }, {});
                    const sortedDates = Object.keys(trialsByDate).sort((a, b) => new Date(a).getTime() - new Date(b).getTime());
                    const recentSortedDates = sortedDates.slice(-30);
                    const trialsCtx = document.getElementById('trials-over-time-chart')?.getContext('2d');
                    if (trialsCtx) {
                        const gradient = trialsCtx.createLinearGradient(0, 0, 0, trialsCtx.canvas.height);
                        gradient.addColorStop(0, 'rgba(13, 148, 136, 0.4)');
                        gradient.addColorStop(1, 'rgba(13, 148, 136, 0)');
                        const chartDefaults = getChartDefaults();
                        state.charts.trialsOverTime = new Chart(trialsCtx, {
                            type: 'line',
                            data: {
                                labels: recentSortedDates.map(d => new Date(d + 'T00:00:00').toLocaleDateString('en-US', { month: 'short', day: 'numeric' })),
                                datasets: [{
                                    label: 'Trials Conducted',
                                    data: recentSortedDates.map(d => trialsByDate[d]),
                                    borderColor: '#0d9488',
                                    backgroundColor: gradient,
                                    fill: true,
                                }]
                            },
                            options: {
                                ...chartDefaults,
                                plugins: { ...chartDefaults.plugins, legend: { position: 'top', align: 'end' } },
                            }
                        });
                    }

                    // Results breakdown chart
                    const resultsCount = trials.reduce((acc, trial) => {
                        const result = trial.Result || 'None';
                        acc[result] = (acc[result] || 0) + 1;
                        return acc;
                    }, {});
                    const resultLabels = ['Excellent', 'Poor', 'Fair', 'Good', 'None'];
                    const resultData = resultLabels.map(label => resultsCount[label] || 0);
                    const resultColors = { 'Excellent': '#22c55e', 'Poor': '#ef4444', 'Fair': '#f59e0b', 'Good': '#3b82f6', 'None': '#a1a1aa' };
                    const resultsCtx = document.getElementById('results-breakdown-chart');
                    if (resultsCtx) {
                        const chartDefaults = getChartDefaults();
                        state.charts.resultsBreakdown = new Chart(resultsCtx, {
                            type: 'doughnut',
                            data: {
                                labels: resultLabels,
                                datasets: [{ data: resultData, backgroundColor: resultLabels.map(l => resultColors[l]), borderColor: '#fff', borderWidth: 4 }]
                            },
                            options: {
                                ...chartDefaults,
                                cutout: '70%',
                                plugins: { ...chartDefaults.plugins, legend: { ...chartDefaults.plugins.legend, position: 'bottom' } }
                            }
                        });
                    }
                },
                trialCard: (trial, showCheckbox = true) => {
                    const formulation = state.formulations.find(f => f.ID === trial.FormulationID);
                    const cost = formulation ? parseFloat(formulation.EstimatedCost || 0).toFixed(2) : '0.00';
                    const isFinal = String(trial.ControlFinalized).toLowerCase() === 'true';
                    let controlDuration;
                    if (isFinal) {
                        if (trial.FinalControlDuration != null && trial.FinalControlDuration !== '') {
                            controlDuration = `${trial.FinalControlDuration} Days (Final)`;
                        } else if (trial.FinalizationDate && trial.Date) {
                            const days = Math.floor((new Date(trial.FinalizationDate) - new Date(trial.Date)) / (1000 * 60 * 60 * 24));
                            controlDuration = `${days < 0 ? 0 : days} Days (Final)`;
                        } else {
                            controlDuration = 'Finalized';
                        }
                    } else if (trial.Date) {
                        const days = Math.floor((new Date() - new Date(trial.Date)) / (1000 * 60 * 60 * 24));
                        controlDuration = `${days < 0 ? 0 : days} Days`;
                    } else {
                        controlDuration = 'N/A';
                    }
                    const formulationName = trial.FormulationName || formulation?.Name || 'Unknown Formulation';
                    const photoURLs = safeJsonParse(trial.PhotoURLs);
                    const allPhotos = [...photoURLs]; // Only show general photos on home screen card
                    const photos = allPhotos.slice(0, 4).map(p => {
                        const photoUrl = p.url || p.fileData;
                        if (typeof photoUrl !== 'string' || !photoUrl) return '';
                        const proxiedUrl = photoUrl.startsWith('data:image') ? photoUrl : `https://images.weserv.nl/?url=${encodeURIComponent(photoUrl)}&w=100&h=100&fit=cover`;
                        return `<img src="${proxiedUrl}" class="h-16 w-16 object-cover rounded-md border ${p.isWeed ? 'border-teal-400' : ''}" alt="${sanitizeHTML(p.label) || 'Trial photo'}">`;
                    }).join('');
                    const resultValue = String(trial.Result || '');
                    const resultClasses = `py-1 px-2 rounded-full text-xs font-semibold result-${resultValue.toLowerCase() || 'none'}`;
                    const resultSelect = `<select data-action="update-result" data-id="${trial.ID}" class="text-xs font-semibold bg-transparent border-none focus:ring-0 focus:outline-none result-${resultValue.toLowerCase() || 'none'}" onchange="this.className = 'text-xs font-semibold bg-transparent border-none focus:ring-0 focus:outline-none result-' + (this.value.toLowerCase() || 'none')"><option value="" ${resultValue === '' ? 'selected' : ''}>Set Result</option><option value="Excellent" ${resultValue === 'Excellent' ? 'selected' : ''}>Excellent</option><option value="Good" ${resultValue === 'Good' ? 'selected' : ''}>Good</option><option value="Fair" ${resultValue === 'Fair' ? 'selected' : ''}>Fair</option><option value="Poor" ${resultValue === 'Poor' ? 'selected' : ''}>Poor</option></select>`;
                    const isChecked = state.selectedTrials.includes(trial.ID);
                    const hasAiData = trial.EfficacyDataJSON && trial.EfficacyDataJSON !== '[]' && trial.AISummariesJSON && trial.AISummariesJSON !== '{}';

                    // Find Project Name if exists
                    const project = trial.ProjectID ? state.projects.find(p => p.ID === trial.ProjectID) : null;
                    const projectNameHtml = project ? `<div class="text-xs text-teal-600 font-bold mb-1 uppercase tracking-wide flex items-center gap-1"><i data-lucide="layers" class="h-3 w-3"></i> ${sanitizeHTML(project.Name)}</div>` : '';

                    return `<div class="bg-white rounded-xl shadow-lg flex flex-col h-full transition-all duration-300 hover:shadow-xl hover:-translate-y-1 border border-transparent hover:border-teal-500/50">
                                <div class="p-5 flex-grow">
                                    <div class="flex items-start justify-between">
                                        <div class="flex items-start gap-3">
                                            ${showCheckbox ? `<input type="checkbox" data-action="select-trial" data-id="${trial.ID}" class="mt-1 h-4 w-4 rounded border-gray-300 text-teal-600 focus:ring-teal-500" ${isChecked ? 'checked' : ''}>` : ''}
                                            <div class="cursor-pointer" data-action="view-trial" data-id="${trial.ID}">
                                                ${projectNameHtml}
                                                <h3 class="font-bold text-lg text-slate-800">${sanitizeHTML(formulationName)}</h3>
                                                <p class="text-xs text-slate-500">${new Date(trial.Date).toLocaleDateString()}</p>
                                                <p class="text-sm text-slate-600 truncate mt-1">Investigator: ${sanitizeHTML(trial.InvestigatorName) || 'N/A'}</p>
                                            </div>
                                        </div>
                                        <div class="flex items-center gap-2">
                                            <button data-action="generate-qr-label" data-id="${trial.ID}" class="p-1 rounded-full hover:bg-teal-50 text-teal-600" title="Plot Label QR"><i data-lucide="qr-code" class="h-4 w-4"></i></button>
                                            <div class="${resultClasses} p-0">${resultSelect}</div>
                                            <div class="relative">
                                                <button class="p-1 rounded-full hover:bg-slate-100" data-action="toggle-card-menu" data-id="${trial.ID}"><i data-lucide="more-vertical" class="h-4 w-4"></i></button>
                                                <div id="card-menu-${trial.ID}" class="card-menu absolute top-full right-0 mt-1 bg-white rounded-md shadow-lg p-1 w-40 hidden z-20 text-sm border">
                                                    ${!hasAiData ? `<button data-action="generate-single-ai" data-id="${trial.ID}" class="w-full text-left px-3 py-1 rounded hover:bg-indigo-50 text-indigo-600">Generate AI Report</button>` : ''}
                                                    <button data-action="edit" data-type="trial" data-id="${trial.ID}" class="w-full text-left px-3 py-1 rounded hover:bg-slate-100">Edit</button>
                                                    <button data-action="duplicate" data-type="trial" data-id="${trial.ID}" class="w-full text-left px-3 py-1 rounded hover:bg-slate-100">Duplicate</button>
                                                    <button data-action="delete" data-type="trial" data-id="${trial.ID}" class="w-full text-left px-3 py-1 rounded text-red-600 hover:bg-red-50">Delete</button>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="flex items-center gap-2 mt-2">
                                        <input type="checkbox" data-action="toggle-completed" data-id="${trial.ID}" id="completed-${trial.ID}" class="h-4 w-4 rounded border-gray-300 text-teal-600 focus:ring-teal-500" ${String(trial.IsCompleted).toLowerCase() === 'true' ? 'checked' : ''}>
                                        <label for="completed-${trial.ID}" class="text-xs font-medium text-gray-700">Mark as Completed</label>
                                    </div>
                                    <div class="mt-4 grid grid-cols-2 gap-x-4 text-sm text-gray-600">
                                        <p><strong>Dosage:</strong> ${sanitizeHTML(trial.Dosage) || 'N/A'}</p>
                                        <button type="button" class="bg-slate-100 border border-slate-300 rounded px-2 py-1 text-slate-700 hover:bg-slate-200 transition text-xs flex items-center gap-1 w-fit relative z-10 cursor-pointer" data-action="edit-control-days" data-id="${trial.ID}" title="Click to edit control days"><strong>Control:</strong> ${controlDuration} <i data-lucide="edit-2" class="h-3 w-3"></i></button>
                                        <p class="font-semibold text-slate-700 mt-2"><strong>Cost:</strong> ${CURRENCY_SYMBOL}${cost}</p>
                                    </div>
                                    <div class="mt-4 flex items-center justify-between">
                                        <div class="flex items-center gap-2">
                                            <div class="w-2 h-2 rounded-full ${String(trial.IsLive).toLowerCase() !== 'false' ? 'bg-green-500' : 'bg-slate-400'}"></div>
                                            <span class="text-[10px] font-bold ${String(trial.IsLive).toLowerCase() !== 'false' ? 'text-green-700' : 'text-slate-500'}">${String(trial.IsLive).toLowerCase() !== 'false' ? 'LIVE' : 'INACTIVE'}</span>
                                            <button data-action="manage-live-qr" data-id="${trial.ID}" class="text-teal-600 hover:text-teal-800" title="Manage Live QR Content"><i data-lucide="settings-2" class="h-3 w-3"></i></button>
                                        </div>
                                        <button data-action="toggle-live-status" data-id="${trial.ID}" class="text-[10px] ${String(trial.IsLive).toLowerCase() !== 'false' ? 'bg-amber-50 text-amber-700 border-amber-200' : 'bg-green-50 text-green-700 border-green-200'} px-2 py-0.5 border rounded font-bold hover:opacity-80 transition">${String(trial.IsLive).toLowerCase() !== 'false' ? 'Deactivate' : 'Activate'}</button>
                                    </div>
                                    ${photos ? `<div class="mt-4 cursor-pointer" data-action="view-trial" data-id="${trial.ID}"><div class="flex flex-wrap gap-2">${photos}</div></div>` : ''}
                                </div>
                                <div class="mt-auto p-3 border-t bg-slate-50/50 rounded-b-xl flex items-center justify-between gap-2">
                                    <div class="flex items-center gap-2">
                                        <button class="text-xs bg-white border rounded-md px-2 py-1 hover:bg-slate-100 transition" data-action="open-weed-modal" data-id="${trial.ID}">Identify Weeds</button>
                                        <input type="file" id="quick-photo-input-${trial.ID}" class="hidden" data-action="quick-add-photo" data-id="${trial.ID}" accept="image/*" multiple>
                                        <label for="quick-photo-input-${trial.ID}" class="text-xs bg-white border rounded-md px-2 py-1 hover:bg-slate-100 transition cursor-pointer">Add Photo</label>
                                        <button class="text-xs bg-white border rounded-md px-2 py-1 hover:bg-slate-100 transition" data-action="quick-open-camera" data-id="${trial.ID}">Camera</button>
                                        <button class="text-xs bg-purple-100 text-purple-800 border border-purple-200 rounded-md px-2 py-1 hover:bg-purple-200 transition font-semibold" data-action="analyze-trial-efficacy" data-id="${trial.ID}" title="Run AI analysis on this trial's photos">Analyze</button>
                                    </div>
                                    <div>
                                        ${!isFinal ? `<button class="text-xs bg-green-100 text-green-800 border border-green-200 rounded-md px-2 py-1 hover:bg-green-200 transition font-semibold" data-action="finalize-trial" data-id="${trial.ID}">Stop Counting</button>` : `<button class="text-xs bg-amber-100 text-amber-800 border border-amber-200 rounded-md px-2 py-1 hover:bg-amber-200 transition font-semibold" data-action="restart-trial" data-id="${trial.ID}">Restart Count</button>`}
                                    </div>
                                </div>
                            </div>`;
                },
                weedPhotoCard: (p, trialId, index) => {
                    const proxiedUrl = (p.url || p.fileData) ? ((p.url || p.fileData).startsWith('data:image') ? (p.url || p.fileData) : `https://images.weserv.nl/?url=${encodeURIComponent(p.url)}&w=300`) : '';
                    let identificationHTML = '<div class="flex flex-col items-center justify-center gap-2"><div class="spinner h-6 w-6 border-2"></div><p class="text-xs text-slate-500 animate-pulse">Syncing & Analyzing...</p></div>';

                    const syncItem = state.syncQueue.find(s => s.photo.tempId === p.tempId);
                    if (syncItem && syncItem.status === 'error') {
                        identificationHTML = `<div class="text-red-500 text-xs font-semibold flex flex-col items-center gap-1">
                            <i data-lucide="alert-circle" class="h-4 w-4"></i>
                            Sync Failed (Offline?)
                            <button data-action="retry-sync" data-id="${syncItem.id}" class="mt-1 text-teal-600 underline">Retry</button>
                        </div>`;
                    }

                    if (p.identifications) {
                        if (p.identifications.length > 0) {
                            // Show ALL identified weeds, not just the first one
                            identificationHTML = p.identifications.map((weed, i) => `
                                <div class="text-left border-b border-gray-100 pb-1 mb-1 ${i > 0 ? 'mt-2' : ''}">
                                    <p class="font-semibold text-sm text-gray-800">${sanitizeHTML(weed.name)} 
                                        <em class="text-gray-500 font-normal text-xs">${sanitizeHTML(weed?.commonNames?.[0]) || ''}</em>
                                    </p>
                                    <p class="text-xs text-gray-500">Confidence: ${((weed.confidence || 0) * 100).toFixed(1)}%${weed.growthStage ? ` • ${sanitizeHTML(weed.growthStage)}` : ''}</p>
                                </div>
                            `).join('');
                        } else {
                            identificationHTML = '<p class="text-sm text-red-500">No weeds identified.</p>';
                        }
                    }
                    return `<div class="border rounded-lg p-2 bg-white flex flex-col text-center relative"><img src="${proxiedUrl}" class="rounded-md w-full h-40 object-cover mb-2"><div class="mt-auto max-h-32 overflow-y-auto">${identificationHTML}</div><button data-action="delete-weed-photo" data-trial-id="${trialId}" data-index="${index}" class="absolute top-1 right-1 bg-red-500 text-white rounded-full h-5 w-5 flex items-center justify-center text-xs font-bold">&times;</button></div>`;
                },
                ingredients: (data = state.ingredients) => { const el = document.getElementById('ingredients-list'); if (el) el.innerHTML = `<ul class="divide-y divide-gray-200">${[...(data || [])].filter(ing => ing && ing.Name).sort((a, b) => String(b.ID).localeCompare(String(a.ID), undefined, { numeric: true })).map(ing => `<li class="py-3 flex justify-between items-center"><div><p class="font-medium">${sanitizeHTML(ing.Name)}</p><p class="text-sm text-gray-500">${CURRENCY_SYMBOL}${(parseFloat(ing.Cost) || 0).toFixed(2)} / ${sanitizeHTML(ing.Unit)}</p></div><div class="flex gap-4"><button data-action="edit" data-type="ingredient" data-id="${ing.ID}" class="text-teal-600 hover:text-teal-800 font-bold">Edit</button><button data-action="delete" data-type="ingredient" data-id="${ing.ID}" class="text-red-500 hover:text-red-700 font-bold">&times;</button></div></li>`).join('') || '<p class="text-gray-500">No ingredients.</p>'}</ul>`; },
                formulations: (data = state.formulations) => { const el = document.getElementById('formulations-list'); if (el) el.innerHTML = [...(data || [])].sort((a, b) => String(b.ID).localeCompare(String(a.ID), undefined, { numeric: true })).map(form => `<div class="bg-white p-6 rounded-xl shadow-lg relative transition-all duration-300 hover:shadow-xl hover:-translate-y-1 border border-transparent hover:border-teal-500/50"><div class="absolute top-4 right-4 flex gap-2"><button data-action="duplicate" data-type="formulation" data-id="${form.ID}" class="bg-slate-200 text-slate-700 px-3 py-1 rounded-md text-sm hover:bg-slate-300">Duplicate</button><button data-action="edit" data-type="formulation" data-id="${form.ID}" class="bg-teal-100 text-teal-700 px-3 py-1 rounded-md text-sm hover:bg-teal-200">Edit</button><button data-action="delete" data-type="formulation" data-id="${form.ID}" class="text-red-500 hover:text-red-700 font-bold text-xl">&times;</button></div><h3 class="font-bold text-lg text-slate-800">${sanitizeHTML(form.Name)}</h3><div class="mt-2 text-sm text-gray-600"><ul class="list-disc list-inside">${safeJsonParse(form.IngredientsJSON).map(ing => `<li>${sanitizeHTML(ing.name)} (${ing.quantity} ${ing.unit})</li>`).join('')}</ul>${form.Notes ? `<p class="mt-2"><strong>Notes:</strong> ${sanitizeHTML(form.Notes)}</p>` : ''}</div><p class="mt-4 font-semibold text-teal-700">Cost: ${CURRENCY_SYMBOL}${parseFloat(form.EstimatedCost || 0).toFixed(2)}</p></div>`).join('') || '<p class="text-gray-500 col-span-full">No formulations found.</p>'; },
                trials: (data = state.trials) => {
                    // Separate trials
                    const standardTrials = (data || []).filter(t => !t.ProjectID);
                    const rcbdTrials = (data || []).filter(t => t.ProjectID);

                    // Render Standard Trials
                    const elStandard = document.getElementById('trials-list-standard');
                    if (elStandard) {
                        elStandard.innerHTML = standardTrials.map(trial => render.trialCard(trial, true)).join('') || '<div class="col-span-full text-center py-8 text-gray-500 bg-gray-50 rounded-lg">No standard trials found.</div>';
                    }

                    // Render RCBD Trials Grouped by Project (Accordion Style)
                    const elRcbd = document.getElementById('trials-list-rcbd');
                    if (elRcbd) {
                        if (rcbdTrials.length === 0) {
                            elRcbd.innerHTML = '<div class="text-center py-8 text-gray-500 bg-gray-50 rounded-lg">No project plots found. Create a Project first.</div>';
                        } else {
                            // Group by Project
                            const groups = {};
                            rcbdTrials.forEach(t => {
                                groups[t.ProjectID] = groups[t.ProjectID] || [];
                                groups[t.ProjectID].push(t);
                            });

                            elRcbd.innerHTML = Object.keys(groups).map(pid => {
                                const project = state.projects.find(p => p.ID === pid) || { Name: 'Unknown Project' };
                                const trialsHtml = groups[pid].map(t => render.trialCard(t, true)).join('');
                                const isDraft = project.Status === 'Draft';
                                const statusColor = isDraft ? 'bg-amber-100 text-amber-700' : 'bg-teal-100 text-teal-700';

                                return `
                                    <div class="border border-slate-200 rounded-xl overflow-hidden shadow-sm hover:shadow-md transition-shadow bg-white mb-4">
                                        <!-- Accordion Header / Project Card -->
                                        <div class="p-4 bg-slate-50 cursor-pointer flex justify-between items-center group" onclick="toggleProjectAccordion('${pid}')">
                                            <div class="flex items-center gap-4">
                                                <div class="bg-white p-2 rounded-lg border border-slate-200 shadow-sm text-teal-600">
                                                    <i data-lucide="layers" class="h-6 w-6"></i>
                                                </div>
                                                <div>
                                                    <h3 class="text-lg font-bold text-slate-800 group-hover:text-teal-700 transition-colors">${sanitizeHTML(project.Name)}</h3>
                                                    <div class="flex items-center gap-3 text-sm text-slate-500 mt-1">
                                                        <span class="px-2 py-0.5 rounded-full text-xs font-semibold ${statusColor}">${project.Status || 'Active'}</span>
                                                        <span>${groups[pid].length} Plots</span>
                                                        <span>•</span>
                                                        <span>Created: ${new Date(project.CreatedAt || Date.now()).toLocaleDateString()}</span>
                                                    </div>
                                                </div>
                                            </div>
                                            <div class="text-slate-400 group-hover:text-teal-600 transition-colors">
                                                <i id="icon-${pid}" data-lucide="chevron-down" class="h-6 w-6 transition-transform duration-300"></i>
                                            </div>
                                        </div>
                                        
                                        <!-- Accordion Body / Plots Grid -->
                                        <div id="content-${pid}" class="hidden border-t border-slate-100 bg-slate-50/50 p-6">
                                            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 items-stretch">
                                                ${trialsHtml}
                                            </div>
                                        </div>
                                    </div>
                                `;
                            }).join('');
                        }
                    }

                    // Window function for Accordion Toggling (exposed for onclick)
                    window.toggleProjectAccordion = (pid) => {
                        const content = document.getElementById(`content-${pid}`);
                        const icon = document.getElementById(`icon-${pid}`);
                        if (content && icon) {
                            const isHidden = content.classList.contains('hidden');
                            if (isHidden) {
                                content.classList.remove('hidden');
                                icon.classList.add('rotate-180');
                            } else {
                                content.classList.add('hidden');
                                icon.classList.remove('rotate-180');
                            }
                        }
                    };

                    // Reactivate Tabs Logic (ensure listeners are attached)
                    const tabs = document.querySelectorAll('[data-action="switch-trials-tab"]');
                    const standardContainer = document.getElementById('trials-list-standard');
                    const rcbdContainer = document.getElementById('trials-list-rcbd');

                    // Remove old listeners to prevent duplicates (not strictly necessary with replace, but good practice)
                    // Actually, simpler to just re-query and re-attach or check if attached. 
                    // Since this function runs on every render, adding listeners repeatedly is bad.
                    // Better to delegate or attach once. 
                    // BUT: tabs are in the template, so they are re-rendered? 
                    // Wait, templates.trials is rendered ONCE when switching TO the page.
                    // render.trials is called to populate data.
                    // The tabs are in the TEMPLATE. The template is rendered in `switchPage`.
                    // So `render.trials` should NOT be attaching listeners to `tabs` if `tabs` are static in the page.
                    // However, `render.trials` is called by `switchPage` AFTER `innerHTML = templates.page(...)`.
                    // So attaching here is correct for the initial render.
                    // But if `render.trials` is called again (e.g. after sort), it will re-attach listeners.
                    // To be safe, we can use `onclick` in HTML or ensure we don't duplicate.
                    // For now, let's keep it here but we should be aware.

                    tabs.forEach(tab => {
                        // clear previous listeners? hard to do without reference.
                        // Clone node to clear listeners
                        const newTab = tab.cloneNode(true);
                        tab.parentNode.replaceChild(newTab, tab);

                        newTab.addEventListener('click', () => {
                            const target = newTab.dataset.tab;

                            // Update Tab Styles
                            document.querySelectorAll('[data-action="switch-trials-tab"]').forEach(t => {
                                if (t.dataset.tab === target) {
                                    t.classList.remove('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300');
                                    t.classList.add('border-teal-500', 'text-teal-600');
                                } else {
                                    t.classList.add('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300');
                                    t.classList.remove('border-teal-500', 'text-teal-600');
                                }
                            });

                            // Toggle Visibility
                            if (target === 'standard') {
                                standardContainer.classList.remove('hidden');
                                standardContainer.classList.add('grid');
                                rcbdContainer.classList.add('hidden');
                            } else {
                                standardContainer.classList.add('hidden');
                                standardContainer.classList.remove('grid');
                                rcbdContainer.classList.remove('hidden');
                            }
                        });
                    });

                    // Reinitialize Lucide icons
                    lucide.createIcons();
                },
                organisations: (data = state.organisations) => {
                    const el = document.getElementById('organisations-list'); if (!el) return;
                    el.innerHTML = [...(data || [])].sort((a, b) => String(b.ID).localeCompare(String(a.ID), undefined, { numeric: true })).map(org => { const trialDetails = safeJsonParse(org.TrialIDs).map(trialId => state.trials.find(t => t.ID === trialId)).filter(Boolean).sort((a, b) => new Date(b.Date) - new Date(a.Date)); return `<div class="bg-white p-6 rounded-lg shadow-md"><div class="flex justify-between items-start mb-4"><h3 class="font-bold text-xl text-gray-800">${sanitizeHTML(org.Name)}</h3><button data-action="delete" data-type="organisation" data-id="${org.ID}" class="text-red-500 hover:text-red-700 font-semibold text-sm">Delete</button></div><div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 items-stretch">${trialDetails.length > 0 ? trialDetails.map(t => render.trialCard(t, false)).join('') : '<p class="text-gray-500 col-span-full">No trials in this organisation.</p>'}</div></div>`; }).join('') || '<p class="text-gray-500">No organisations created yet. Go to the Trials page to group some together.</p>';
                },
                projects: () => {
                    const el = document.getElementById('projects-list');
                    if (!el) return;
                    const projects = state.projects || [];
                    el.innerHTML = projects.length > 0
                        ? projects.map(p => render.projectCard(p)).join('')
                        : `<div class="col-span-full text-center py-12 bg-white rounded-xl border-2 border-dashed border-slate-200">
                               <p class="text-slate-500 mb-4">No RCBD Projects yet.</p>
                               <button data-action="open-project-modal" class="text-teal-600 font-bold hover:underline">Create your first project</button>
                           </div>`;
                    lucide.createIcons();
                },
                projectCard: (p) => {
                    const projectBlocks = (state.blocks || []).filter(b => b.ProjectID === p.ID);
                    const projectTrials = (state.trials || []).filter(t => t.ProjectID === p.ID);
                    const statusClass = p.Status === 'Draft' ? 'bg-amber-100 text-amber-700' : p.Status === 'Finalized' ? 'bg-teal-100 text-teal-700' : 'bg-slate-100 text-slate-700';

                    return `
                        <div class="bg-white p-6 rounded-xl shadow-md border border-slate-100 hover:shadow-lg transition-shadow cursor-pointer" onclick="if(!event.target.closest('button')) openProjectDashboard('${p.ID}')">
                            <div class="flex justify-between items-start mb-4">
                                <div>
                                    <h3 class="font-bold text-lg text-slate-800">${sanitizeHTML(p.Name)}</h3>
                                    <span class="text-xs px-2 py-0.5 rounded-full font-semibold ${statusClass}">${p.Status}</span>
                                </div>
                                <button data-action="delete-project" data-id="${p.ID}" class="text-slate-300 hover:text-red-500 transition-colors p-1">
                                    <i data-lucide="trash-2" class="h-4 w-4"></i>
                                </button>
                            </div>
                            <div class="space-y-3 mb-4">
                                <div class="flex items-center gap-2 text-sm text-slate-500">
                                    <i data-lucide="layers" class="h-4 w-4"></i>
                                    <span>${projectBlocks.length} Blocks</span>
                                </div>
                                <div class="flex items-center gap-2 text-sm text-slate-500">
                                    <i data-lucide="beaker" class="h-4 w-4"></i>
                                    <span>${projectTrials.length} Plots</span>
                                </div>
                                <div class="flex items-center gap-2 text-sm text-slate-500">
                                    <i data-lucide="activity" class="h-4 w-4"></i>
                                    <span>Metric: ${p.Metric}</span>
                                </div>
                            </div>
                            <div class="pt-4 border-t border-slate-50 flex justify-between items-center">
                                <span class="text-[10px] text-slate-400">Created: ${new Date(p.CreatedAt).toLocaleDateString()}</span>
                                <span class="text-teal-600 font-bold text-sm">View Dashboard <i data-lucide="chevron-right" class="h-4 w-4 inline"></i></span>
                            </div>
                        </div>
                    `;
                },
                projectDashboard: () => {
                    const projectId = state.activeProjectId;
                    const project = state.projects.find(p => p.ID === projectId);
                    if (!project) {
                        switchPage('projects');
                        return;
                    }

                    // Auto-Run Analysis if missing (avoids empty dashboard on refresh)
                    // Only auto-run if we actually have data to analyze!
                    const hasDataForProAnalysis = state.blocks.some(b => b.ProjectID === projectId) &&
                        state.trials.some(t => t.ProjectID === projectId);

                    if (hasDataForProAnalysis && (!project.AnalysisResults || Object.keys(project.AnalysisResults).length === 0) && !project.isAnalyzing) {
                        console.log("Auto-triggering analysis for project:", projectId);
                        project.isAnalyzing = true; // Prevent multiple triggers
                        // Small delay to ensure render completes first if needed
                        setTimeout(() => runProjectAnalysis(projectId), 50);
                    }
                    // REMOVED: project.isAnalyzing = false; here. It must be handled by the async function.

                    // Update Header
                    const headerEl = document.getElementById('project-dashboard-header');
                    headerEl.innerHTML = `
                        <div class="flex items-center gap-4 mb-2">
                            <button onclick="switchPage('projects')" class="p-2 hover:bg-slate-100 rounded-full transition-colors">
                                <i data-lucide="arrow-left"></i>
                            </button>
                            <h2 class="text-3xl font-bold text-slate-800">${sanitizeHTML(project.Name)}</h2>
                            <span class="px-3 py-1 ${project.Status === 'Locked' ? 'bg-slate-800 text-white' : 'bg-amber-100 text-amber-700'} rounded-full text-xs font-bold uppercase tracking-wider">${project.Status}</span>
                        </div>
                        <p class="text-slate-500 ml-12">Response Variable: <span class="font-semibold text-slate-700">${project.Metric}</span></p>
                    `;

                    // Render Stats
                    const statsContent = document.getElementById('project-stats-content');
                    const blocks = (state.blocks || []).filter(b => b.ProjectID === project.ID);
                    const trials = (state.trials || []).filter(t => t.ProjectID === project.ID);
                    const treatments = [...new Set(trials.map(t => t.FormulationName))];

                    statsContent.innerHTML = `
                        <div class="flex justify-between text-sm">
                            <span class="text-slate-500">Blocks:</span>
                            <span class="font-bold text-slate-800">${blocks.length}</span>
                        </div>
                        <div class="flex justify-between text-sm">
                            <span class="text-slate-500">Treatments:</span>
                            <span class="font-bold text-slate-800">${treatments.length}</span>
                        </div>
                        <div class="flex justify-between text-sm">
                            <span class="text-slate-500">Total Plots:</span>
                            <span class="font-bold text-slate-800">${trials.length}</span>
                        </div>
                        <hr class="my-3 border-slate-200">
                        <button onclick="openScientificReport('${projectId}'); return false;" class="w-full bg-gradient-to-r from-teal-600 to-cyan-600 hover:from-teal-700 hover:to-cyan-700 text-white px-4 py-3 rounded-lg font-bold shadow-lg hover:shadow-xl transition-all flex items-center justify-center gap-2">
                            <i data-lucide="bar-chart-4" class="h-5 w-5"></i>
                            <span>📊 Scientific Report (New!)</span>
                        </button>
                    `;

                    // Update Actions Card based on Lock status
                    const actionsCard = document.getElementById('project-actions-card');
                    if (actionsCard) {
                        const isLocked = project.Status === 'Locked';
                        actionsCard.innerHTML = `
                            <h3 class="font-bold text-slate-800 mb-4">Actions</h3>
                            <div class="flex flex-col gap-2">
                                <button data-action="add-block" class="w-full text-left px-4 py-2 rounded-lg hover:bg-slate-50 flex items-center gap-2 text-slate-700 ${isLocked ? 'opacity-50 cursor-not-allowed' : ''}" ${isLocked ? 'disabled' : ''}>
                                    <i data-lucide="plus" class="h-4 w-4"></i> Add Block
                                </button>
                                <button data-action="open-randomize-modal" class="w-full text-left px-4 py-2 rounded-lg hover:bg-teal-50 text-teal-700 font-semibold flex items-center gap-2 ${isLocked ? 'opacity-50 cursor-not-allowed' : ''}" ${isLocked ? 'disabled' : ''}>
                                    <i data-lucide="shuffle" class="h-4 w-4"></i> Randomize Layout
                                </button>
                                <button data-action="open-protocol-modal" class="w-full text-left px-4 py-2 rounded-lg hover:bg-blue-50 text-blue-700 font-semibold flex items-center gap-2 ${isLocked ? 'opacity-50 cursor-not-allowed' : ''}" ${isLocked ? 'disabled' : ''}>
                                    <i data-lucide="clipboard-list" class="h-4 w-4"></i> Protocol Settings
                                </button>
                                <button data-action="run-analysis" data-id="${projectId}" class="w-full text-left px-4 py-2 rounded-lg hover:bg-teal-50 text-teal-700 font-semibold flex items-center gap-2">
                                    <i data-lucide="bar-chart-2" class="h-4 w-4"></i> ${isLocked ? 'Refresh Report' : 'Run Analysis'}
                                </button>
                                <button data-action="recalculate-daa" data-id="${projectId}" class="w-full text-left px-4 py-2 rounded-lg hover:bg-amber-50 text-amber-700 font-semibold flex items-center gap-2">
                                    <i data-lucide="refresh-cw" class="h-4 w-4"></i> Recalculate DAA
                                </button>
                                <button data-action="generate-regulatory-report" class="w-full text-left px-4 py-2 rounded-lg hover:bg-purple-50 text-purple-700 font-semibold flex items-center gap-2">
                                    <i data-lucide="file-text" class="h-4 w-4"></i> Regulatory Report (PDF)
                                </button>
                                ${!isLocked ? `
                                <button data-action="lock-project" class="w-full text-left px-4 py-2 rounded-lg hover:bg-red-50 text-red-700 flex items-center gap-2">
                                    <i data-lucide="lock" class="h-4 w-4"></i> Lock Project
                                </button>` : `
                                <button data-action="unlock-project" class="w-full text-left px-4 py-2 rounded-lg hover:bg-amber-50 text-amber-700 flex items-center gap-2">
                                    <i data-lucide="unlock" class="h-4 w-4"></i> Unlock Project
                                </button>`}
                            </div>
                        `;
                    }
                    lucide.createIcons();

                    // Render Blocks
                    const blocksContainer = document.getElementById('project-blocks-container');
                    blocksContainer.innerHTML = blocks.length > 0
                        ? blocks.map(b => render.projectBlock(b, trials.filter(t => t.BlockID === b.ID))).join('')
                        : `<div class="text-center py-10 bg-white rounded-xl border border-slate-100">
                        <p class="text-slate-400">No blocks added yet.</p>
                           </div>`;

                    // Render Analysis Results
                    if (project.AnalysisResults && Object.keys(project.AnalysisResults).length > 0) {
                        const analysisSection = document.createElement('div');
                        analysisSection.className = 'mt-12 space-y-8';
                        analysisSection.innerHTML = `
                            <div class="flex flex-col gap-6">
                                <h3 class="text-2xl font-bold text-slate-800 border-b pb-4">Statistical Analysis Results</h3>
                                
                                <div class="grid grid-cols-1 xl:grid-cols-2 gap-6">
                                    <div class="bg-white p-6 rounded-2xl shadow-sm border border-slate-100">
                                        <h4 class="font-bold text-slate-700 mb-4 flex items-center gap-2">
                                            <i data-lucide="line-chart" class="h-4 w-4 text-teal-500"></i>
                                            WCE (%) Over Time
                                        </h4>
                                        <div class="h-[300px]">
                                            <canvas id="project-wce-chart"></canvas>
                                        </div>
                                    </div>
                                    <div class="bg-white p-6 rounded-2xl shadow-sm border border-slate-100">
                                        <h4 class="font-bold text-slate-700 mb-4 flex items-center gap-2">
                                            <i data-lucide="bar-chart-2" class="h-4 w-4 text-teal-500"></i>
                                            Treatment Performance (Final DAT)
                                        </h4>
                                        <div class="h-[300px]">
                                            <canvas id="project-performance-chart"></canvas>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        `;

                        Object.entries(project.AnalysisResults).forEach(([dat, result]) => {
                            const datCard = document.createElement('div');
                            datCard.className = 'bg-white rounded-xl shadow-lg border border-slate-100 overflow-hidden';

                            const isPartial = result.isPartial;
                            const headerClass = isPartial ? 'bg-amber-600' : 'bg-slate-800';
                            const headerTitle = `Results at ${dat} DAT ${isPartial ? '<span class="text-[10px] bg-white text-amber-700 px-2 py-0.5 rounded-full ml-2 uppercase">Preliminary (Partial Data)</span>' : ''}`;

                            const statsDisplay = isPartial
                                ? `<span class="text-amber-100 font-bold text-xs uppercase tracking-wide flex items-center gap-1"><i data-lucide="alert-triangle" class="h-3 w-3"></i> LSD/ANOVA requires full block data</span>`
                                : `<span>F-ratio: ${result.f.toFixed(2)}</span>
                                   <span>LSD (0.05): ${result.lsd.toFixed(3)}</span>
                                   <span>MSE: ${result.ms.error.toFixed(4)}</span>`;

                            let rows = result.treatmentStats.map(ts => {
                                const tr = state.formulations.find(f => f.ID === ts.treatmentId) || { Name: 'Unknown' };
                                let rankClass = ts.rank === 'Superior' ? 'bg-teal-100 text-teal-700' : ts.rank === 'Inferior' ? 'bg-red-100 text-red-700' : ts.rank === 'Control' ? 'bg-slate-100 text-slate-700' : 'bg-amber-100 text-amber-700';

                                return `
                                    <tr class="border-b last:border-0 hover:bg-slate-50 transition-colors">
                                        <td class="p-4 font-semibold text-slate-800">${sanitizeHTML(tr.Name)}</td>
                                        <td class="p-4 text-center">${ts.mean.toFixed(2)} ± ${ts.sd.toFixed(2)}</td>
                                        <td class="p-4 text-center text-slate-500">${ts.cv ? ts.cv.toFixed(1) + '%' : '-'}</td>
                                        <td class="p-4 text-center font-bold text-teal-600">${ts.wce.toFixed(1)}%</td>
                                        <td class="p-4 text-right">
                                            <span class="px-2.5 py-1 rounded-full text-[10px] font-extrabold uppercase ${rankClass}">${ts.rank}</span>
                                        </td>
                                    </tr>
                                `;
                            }).join('');

                            datCard.innerHTML = `
                                <div class="${headerClass} p-4 flex justify-between items-center transition-colors">
                                    <h4 class="text-white font-bold flex items-center">${headerTitle}</h4>
                                    <div class="flex gap-4 text-[10px] text-slate-300 font-mono items-center">
                                        ${statsDisplay}
                                    </div>
                                </div>
                                <div class="overflow-x-auto">
                                    <table class="w-full text-sm text-left">
                                        <thead class="bg-slate-50 text-slate-500 uppercase text-[10px] font-bold">
                                            <tr>
                                                <th class="p-4">Treatment</th>
                                                <th class="p-4 text-center">Mean ± SD (${project.Metric})</th>
                                                <th class="p-4 text-center">CV (%)</th>
                                                <th class="p-4 text-center">WCE (%)</th>
                                                <th class="p-4 text-right">Ranking</th>
                                            </tr>
                                        </thead>
                                        <tbody>${rows}</tbody>
                                    </table>
                                </div>
                            `;
                            analysisSection.appendChild(datCard);
                        });
                        blocksContainer.appendChild(analysisSection);

                        // Initialize Project Charts
                        setTimeout(() => renderProjectAnalysisCharts(project), 100);
                    }
                    lucide.createIcons();
                },
                scientificReport: async (projectId = state.activeProjectId) => {
                    try {
                        alert('🔬 Scientific Report Started! Project ID: ' + projectId);
                        console.log('=== SCIENTIFIC REPORT DEBUG ===');
                        console.log('1. Project ID:', projectId);

                        const project = state.projects.find(p => p.ID === projectId);
                        if (!project) {
                            console.error('Project not found!');
                            alert('❌ Project not found: ' + projectId);
                            return;
                        }
                        console.log('2. Project Found:', project.Name);

                        state.currentPage = 'scientificReport';
                        // updateNavigation(); // Commented out - function not defined

                        const engine = new AnalysisEngine(projectId, state);
                        console.log('3. AnalysisEngine created');
                        console.log('   - Treatments:', engine.treatments);
                        console.log('   - Trials count:', engine.trials.length);

                        const yieldData = engine.getData('yield');
                        console.log('4. Yield Data:', yieldData);
                        const hasYield = Object.values(yieldData).some(arr => arr.some(v => v > 0));
                        console.log('   - Has Yield?', hasYield);

                        const primaryMetric = hasYield ? 'yield' : 'cover';
                        console.log('5. Primary Metric:', primaryMetric);

                        const results = engine.analyze(primaryMetric);
                        console.log('6. Analysis Results:', results);
                        console.log('   - Grouping:', results.grouping);
                        console.log('   - ANOVA:', results.anova);
                        console.log('   - LSD Results:', results.lsdResults);

                        const mainContent = document.getElementById('main-content');
                        mainContent.innerHTML = `
                      <div class="max-w-7xl mx-auto p-4 md:p-8">
                         <div class="flex items-center gap-4 mb-8">
                            <button onclick="render.projectDashboard('${projectId}')" class="p-2 rounded-full hover:bg-slate-100"><i data-lucide="arrow-left" class="h-6 w-6 text-slate-600"></i></button>
                            <div>
                                 <h1 class="text-3xl font-bold text-slate-800">Scientific Trial Report</h1>
                                 <p class="text-slate-500">${sanitizeHTML(project.Name)} • Metric: ${primaryMetric === 'yield' ? 'Yield (t/ha)' : 'Weed Control (%)'}</p>
                            </div>
                            <div class="flex-grow"></div>
                             <button data-action="generate-narrative" class="bg-indigo-600 text-white px-4 py-2 rounded-lg flex items-center gap-2 shadow-lg hover:bg-indigo-700 transition">
                                <i data-lucide="sparkles" class="h-4 w-4"></i> Generate AI Narrative
                             </button>
                         </div>

                         <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
                             <!-- Left Col: Stats -->
                             <div class="lg:col-span-2 space-y-8">
                                <!-- Means Table -->
                                <div class="bg-white p-6 rounded-xl shadow-sm border border-slate-200">
                                    <h3 class="text-xl font-bold text-slate-800 mb-4">Treatment Means & Significance</h3>
                                    <div class="overflow-x-auto">
                                        <table class="w-full text-sm text-left">
                                            <thead class="bg-slate-50 text-slate-500 font-bold uppercase text-xs">
                                                <tr>
                                                    <th class="p-3">Treatment</th>
                                                    <th class="p-3 text-center">Mean</th>
                                                    <th class="p-3 text-center">Group (LSD)</th>
                                                </tr>
                                            </thead>
                                            <tbody class="divide-y divide-slate-100">
                                                ${results.grouping.map(g => `
                                                    <tr class="hover:bg-slate-50">
                                                        <td class="p-3 font-medium text-slate-700">${g.name}</td>
                                                        <td class="p-3 text-center">${g.mean.toFixed(2)}</td>
                                                        <td class="p-3 text-center font-bold text-teal-700">${g.grouping}</td>
                                                    </tr>
                                                `).join('')}
                                            </tbody>
                                        </table>
                                    </div>
                                    <p class="mt-4 text-xs text-slate-400">Means sharing the same letter are not significantly different (LSD, alpha=0.05).</p>
                                </div>

                                <!-- ANOVA Table -->
                                <div class="bg-white p-6 rounded-xl shadow-sm border border-slate-200">
                                    <h3 class="text-xl font-bold text-slate-800 mb-4">ANOVA Results</h3>
                                    <div class="overflow-x-auto">
                                        <table class="w-full text-sm text-left">
                                            <thead class="bg-slate-50 text-slate-500 font-bold uppercase text-xs">
                                                <tr>
                                                    <th class="p-3">Source</th>
                                                    <th class="p-3 text-right">DF</th>
                                                    <th class="p-3 text-right">SS</th>
                                                    <th class="p-3 text-right">MS</th>
                                                    <th class="p-3 text-right">F</th>
                                                    <th class="p-3 text-right">P</th>
                                                </tr>
                                            </thead>
                                            <tbody class="divide-y divide-slate-100">
                                                <tr>
                                                    <td class="p-3 font-medium">Treatment</td>
                                                    <td class="p-3 text-right">${results.anova.dfTreat}</td>
                                                    <td class="p-3 text-right">${results.anova.ssTreat.toFixed(2)}</td>
                                                    <td class="p-3 text-right">${results.anova.msTreat.toFixed(2)}</td>
                                                    <td class="p-3 text-right font-bold">${results.anova.fVal.toFixed(2)}</td>
                                                    <td class="p-3 text-right ${results.anova.pVal < 0.05 ? 'text-green-600 font-bold' : ''}">${results.anova.pVal.toFixed(4)}</td>
                                                </tr>
                                                <tr>
                                                    <td class="p-3 font-medium">Error</td>
                                                    <td class="p-3 text-right">${results.anova.dfError}</td>
                                                    <td class="p-3 text-right">${results.anova.ssError.toFixed(2)}</td>
                                                    <td class="p-3 text-right">${results.anova.msError.toFixed(2)}</td>
                                                    <td class="p-3 text-right"></td>
                                                    <td class="p-3 text-right"></td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </div>
                                </div>
                             </div>

                             <!-- Right Col: Narrative & Meta -->
                             <div class="space-y-8">
                                 <div class="bg-gradient-to-br from-indigo-50 to-purple-50 p-6 rounded-xl border border-indigo-100">
                                    <h3 class="text-lg font-bold text-indigo-900 mb-2 flex items-center gap-2"><i data-lucide="file-text" class="h-5 w-5"></i> Agronomist Narrative</h3>
                                    <p class="text-xs text-indigo-700 mb-4">AI-generated summary of findings.</p>
                                    <textarea id="narrative-text" class="w-full h-96 p-4 rounded-lg border-0 shadow-inner bg-white/80 text-sm leading-relaxed" placeholder="Click 'Generate AI Narrative' to create a report..."></textarea>
                                 </div>
                                 
                                 <div class="bg-white p-6 rounded-xl shadow-sm border border-slate-200">
                                    <h3 class="text-sm font-bold text-slate-500 uppercase mb-4">Trial Statistics</h3>
                                    <div class="space-y-4">
                                        <div class="flex justify-between items-center">
                                            <span class="text-slate-600">CV (%)</span>
                                            <span class="font-bold text-slate-800">${(Math.sqrt(results.anova.msError) / jStat.mean(Object.values(results.means)) * 100).toFixed(2)}%</span>
                                        </div>
                                         <div class="flex justify-between items-center">
                                            <span class="text-slate-600">LSD (0.05)</span>
                                            <span class="font-bold text-slate-800">${results.lsdResults ? results.lsdResults.lsd.toFixed(2) : '-'}</span> 
                                        </div>
                                    </div>
                                 </div>
                             </div>
                         </div>
                      </div>
                    `;
                        lucide.createIcons();

                        document.querySelector('[data-action="generate-narrative"]').addEventListener('click', async () => {
                            const btn = document.querySelector('[data-action="generate-narrative"]');
                            const txt = document.getElementById('narrative-text');
                            btn.disabled = true;
                            btn.textContent = 'Generating...';

                            const prompt = `Act as an Agronomist. Analyze this trial data for '${project.Name}'.
Metric: ${primaryMetric}

Treatments & Means:
${results.grouping.map(g => `- ${g.name}: ${g.mean.toFixed(2)} (Group ${g.grouping})`).join('\n')}

ANOVA P-Value: ${results.anova.pVal.toFixed(5)}
CV: ${(Math.sqrt(results.anova.msError) / jStat.mean(Object.values(results.means)) * 100).toFixed(2)}%

Write a 3-paragraph Narrative covering Methodology, Results and Conclusions. Focus on key significant differences and trend analysis (e.g. dose response).`;

                            try {
                                // Assuming MultiProviderAI is accessible
                                const ai = new MultiProviderAI(state);
                                ai.loadUsageStats();

                                const narrative = await ai.generateText(prompt);
                                txt.value = narrative;
                            } catch (e) {
                                alert(e.message);
                            } finally {
                                btn.disabled = false;
                                btn.textContent = 'Generate AI Narrative';
                                lucide.createIcons();
                            }
                        });
                    } catch (err) {
                        console.error('❌ SCIENTIFIC REPORT ERROR:', err);
                        alert('Error in Scientific Report: ' + err.message);
                        showToast('Failed to generate scientific report. Check console for details.', 'error');
                    }
                },
                projectBlock: (block, trials) => {
                    const controls = trials.filter(t => String(t.IsControl).toLowerCase() === 'true');
                    const hasControl = controls.length > 0;
                    const tooManyControls = controls.length > 1;

                    let readinessIcon = '';
                    if (tooManyControls) {
                        readinessIcon = '<i data-lucide="alert-circle" class="h-5 w-5 text-red-500 animate-pulse" title="Error: Multiple Untreated Controls detected!"></i>';
                    } else if (hasControl) {
                        readinessIcon = '<i data-lucide="check-circle-2" class="h-4 w-4 text-teal-500" title="Control Present"></i>';
                    } else {
                        readinessIcon = '<i data-lucide="alert-triangle" class="h-4 w-4 text-amber-500" title="Untreated Control Missing!"></i>';
                    }

                    return `
                <div class="bg-white rounded-xl shadow-md border border-slate-100 overflow-hidden">
                            <div class="bg-slate-50 p-4 flex justify-between items-center border-b">
                                <div class="flex items-center gap-3">
                                    <div class="bg-teal-600 text-white w-8 h-8 rounded-lg flex items-center justify-center font-bold text-sm">
                                        R${block.ReplicationNum || '?'}
                                    </div>
                                    <h3 class="font-bold text-slate-800">${sanitizeHTML(block.Name)}</h3>
                                    ${readinessIcon}
                                </div>
                                <div class="flex gap-2">
                                    <button data-action="add-plot" data-block-id="${block.ID}" class="btn-primary text-white px-3 py-1.5 rounded-lg text-xs flex items-center gap-1">
                                        <i data-lucide="plus" class="h-3 w-3"></i> Add Plot
                                    </button>
                                    <button data-action="delete-block" data-id="${block.ID}" class="text-slate-400 hover:text-red-500 p-1">
                                        <i data-lucide="trash-2" class="h-4 w-4"></i>
                                    </button>
                                </div>
                            </div>
                            <div class="p-4 overflow-x-auto">
                                <div class="flex gap-4 min-w-max pb-2">
                                    ${trials.length > 0
                            ? trials.sort((a, b) => {
                                const getOrder = (t) => parseInt(t.RandomizationOrder) || parseInt(t.PlotNumber) || (safeJsonParse(t.AISummariesJSON)?.plotNum) || 999;
                                return getOrder(a) - getOrder(b);
                            }).map(t => render.projectTrialMiniCard(t)).join('')
                            : '<p class="text-xs text-slate-400 italic py-4">No plots in this block.</p>'
                        }
                                </div>
                            </div>
                        </div >
                `;
                },
                projectTrialMiniCard: (t) => {
                    const isControl = String(t.IsControl).toLowerCase() === 'true';
                    const isCheck = String(t.IsStandardCheck).toLowerCase() === 'true';
                    const bgColor = isControl ? 'bg-orange-50 border-orange-100' : isCheck ? 'bg-purple-50 border-purple-100' : 'bg-white border-slate-100';
                    const ribbonColor = isControl ? 'bg-orange-500' : isCheck ? 'bg-purple-500' : 'bg-teal-500';

                    return `
                <div class="w-48 flex-shrink-0 ${bgColor} border rounded-lg p-3 shadow-sm hover:shadow-md transition-shadow cursor-pointer relative overflow-hidden" onclick="openTrialDetail('${t.ID}')">
                            <div class="absolute top-0 left-0 w-1 h-full ${ribbonColor}"></div>
                            <div class="flex justify-between items-start mb-1">
                                <span class="text-[10px] font-bold text-slate-400">PLOT ${t.RandomizationOrder || t.PlotNumber || (safeJsonParse(t.AISummariesJSON)?.plotNum) || '?'}</span>
                                ${isControl ? '<span class="px-1.5 py-0.5 bg-orange-100 text-orange-700 text-[8px] font-extrabold rounded">CONTROL</span>' : ''}
                            </div>
                            <p class="font-bold text-sm text-slate-800 truncate mb-1" title="${sanitizeHTML(t.FormulationName)}">${sanitizeHTML(t.FormulationName)}</p>
                            <p class="text-[10px] text-slate-500 truncate">${sanitizeHTML(t.Dosage) || '-'}</p>
                            <div class="mt-2 flex justify-between items-center">
                                <div class="flex -space-x-1">
                                    ${(safeJsonParse(t.PhotoURLs) || []).slice(0, 3).map(p => {
                        const url = p.url || p.fileData;
                        const proxied = url.startsWith('data') ? url : `https://images.weserv.nl/?url=${encodeURIComponent(url)}&w=20&h=20&fit=cover`;
                        return `<img src="${proxied}" class="w-4 h-4 rounded-full border border-white">`;
                    }).join('')}
                                </div>
                                <span class="text-[10px] font-bold ${String(t.IsCompleted).toLowerCase() === 'true' ? 'text-teal-600' : 'text-amber-500'}">
                                    ${String(t.IsCompleted).toLowerCase() === 'true' ? 'DONE' : 'ACTIVE'}
                                </span>
                            </div>
                        </div >
                `;
                },
                compareTrials: () => {
                    const warningEl = document.getElementById('compare-selection-warning');
                    const contentEl = document.getElementById('compare-content');

                    if (state.selectedTrials.length < 1) {
                        if (warningEl) warningEl.classList.remove('hidden');
                        if (warningEl) warningEl.classList.add('flex');
                        if (contentEl) contentEl.classList.add('hidden');
                        return;
                    }

                    if (warningEl) warningEl.classList.add('hidden');
                    if (warningEl) warningEl.classList.remove('flex');
                    if (contentEl) contentEl.classList.remove('hidden');

                    // Populate selected list
                    const listEl = document.getElementById('compare-selected-list');
                    if (listEl) {
                        listEl.innerHTML = state.selectedTrials.map(id => {
                            const t = state.trials.find(tr => tr.ID === id);
                            if (!t) return '';
                            return `<li class="flex justify-between items-center bg-gray-50 p-2 rounded border"><span>${sanitizeHTML(t.FormulationName)}</span><button data-action="remove-compare-trial" data-id="${id}" class="text-red-500 hover:text-red-700">&times;</button></li>`;
                        }).join('');
                    }

                    const trialsToCompare = state.selectedTrials.map(id => state.trials.find(t => t.ID === id)).filter(Boolean);
                    const allWeeds = [...new Set(trialsToCompare.flatMap(t => (t.WeedSpecies || '').split(',').map(w => w.trim()).filter(Boolean)))].sort();

                    const weedFilterEl = document.getElementById('compare-weed-filter');
                    if (weedFilterEl && weedFilterEl.options.length === 0) { // Only populate if empty to preserve selection
                        weedFilterEl.innerHTML = allWeeds.map(w => `<option value="${sanitizeHTML(w)}">${sanitizeHTML(w)}</option>`).join('');
                    }

                    // Run initial comparison if weed selected or select first available
                    if (weedFilterEl && !weedFilterEl.value && allWeeds.length > 0) {
                        weedFilterEl.value = allWeeds[0];
                    }

                    // --- DETAILED TABLE GENERATION ---
                    const tableContainer = document.getElementById('compare-table-container');
                    if (tableContainer) {
                        let tableHTML = `
                <table class="min-w-full divide-y divide-gray-200 border text-sm">
                                <thead class="bg-gray-50">
                                    <tr>
                                        <th class="px-4 py-3 text-left font-medium text-gray-500 uppercase tracking-wider w-32 sticky left-0 bg-gray-50 border-r">Parameter</th>
                                        ${trialsToCompare.map(t => `<th class="px-4 py-3 text-left font-medium text-gray-700 tracking-wider border-r bg-white min-w-[200px]">${sanitizeHTML(t.FormulationName)}</th>`).join('')}
                                    </tr>
                                </thead>
                                <tbody class="bg-white divide-y divide-gray-200">
                                    <tr><td class="px-4 py-2 font-semibold text-gray-600 sticky left-0 bg-gray-50 border-r">Investigator</td>${trialsToCompare.map(t => `<td class="px-4 py-2 border-r">${sanitizeHTML(t.InvestigatorName) || '-'}</td>`).join('')}</tr>
                                    <tr><td class="px-4 py-2 font-semibold text-gray-600 sticky left-0 bg-gray-50 border-r">Trial Date</td>${trialsToCompare.map(t => `<td class="px-4 py-2 border-r">${new Date(t.Date).toLocaleDateString()}</td>`).join('')}</tr>
                                    <tr><td class="px-4 py-2 font-semibold text-gray-600 sticky left-0 bg-gray-50 border-r">Location</td>${trialsToCompare.map(t => `<td class="px-4 py-2 border-r">${sanitizeHTML(t.Location) || '-'}</td>`).join('')}</tr>
                                    <tr><td class="px-4 py-2 font-semibold text-gray-600 sticky left-0 bg-gray-50 border-r">Dosage</td>${trialsToCompare.map(t => `<td class="px-4 py-2 border-r">${sanitizeHTML(t.Dosage) || '-'}</td>`).join('')}</tr>
                                    <tr><td class="px-4 py-2 font-semibold text-gray-600 sticky left-0 bg-gray-50 border-r">Control Days</td>
                                        ${trialsToCompare.map(t => {
                            let duration = 'Active';
                            if (String(t.ControlFinalized).toLowerCase() === 'true') {
                                duration = (t.FinalControlDuration || '0') + ' (Final)';
                            } else if (t.Date) {
                                const days = Math.floor((new Date() - new Date(t.Date)) / (1000 * 60 * 60 * 24));
                                duration = (days < 0 ? 0 : days) + ' (Ongoing)';
                            }
                            return `<td class="px-4 py-2 border-r font-medium text-teal-600">${duration}</td>`;
                        }).join('')}
                                    </tr>
                                    <tr><td class="px-4 py-2 font-semibold text-gray-600 sticky left-0 bg-gray-50 border-r">Cost</td>
                                        ${trialsToCompare.map(t => {
                            const form = state.formulations.find(f => f.ID === t.FormulationID);
                            const cost = form ? parseFloat(form.EstimatedCost || 0).toFixed(2) : '0.00';
                            return `<td class="px-4 py-2 border-r">${CURRENCY_SYMBOL}${cost}</td>`;
                        }).join('')}
                                    </tr>
                                    <tr><td class="px-4 py-2 font-semibold text-gray-600 sticky left-0 bg-gray-50 border-r">Weather</td>
                                        ${trialsToCompare.map(t => {
                            if (!t.Temperature) return `<td class="px-4 py-2 border-r">-</td>`;
                            return `<td class="px-4 py-2 border-r text-xs">Temp: ${t.Temperature}°C<br>Hum: ${t.Humidity}%<br>Rain: ${t.Rain}mm</td>`;
                        }).join('')}
                                    </tr>
                                    <tr><td class="px-4 py-2 font-semibold text-gray-600 sticky left-0 bg-gray-50 border-r">Result</td>
                                        ${trialsToCompare.map(t => {
                            const resultValue = t.Result || 'None';
                            const colorClass = `result-${resultValue.toLowerCase()}`;
                            return `<td class="px-4 py-2 border-r"><span class="px-2 py-1 rounded-full text-xs font-bold ${colorClass}">${resultValue}</span></td>`;
                        }).join('')}
                                    </tr>
                                    <tr><td class="px-4 py-2 font-semibold text-gray-600 sticky left-0 bg-gray-50 border-r">Conclusion</td>${trialsToCompare.map(t => `<td class="px-4 py-2 border-r text-xs text-gray-500 max-w-[200px]">${sanitizeHTML(t.Conclusion) || '-'}</td>`).join('')}</tr>
                                    <tr><td class="px-4 py-2 font-semibold text-gray-600 sticky left-0 bg-gray-50 border-r">AI Cover Analysis</td>
                                        ${trialsToCompare.map(t => {
                            const summaries = safeJsonParse(t.AISummariesJSON, {});
                            const text = summaries.cover || '-';
                            return `<td class="px-4 py-2 border-r text-xs text-gray-600 min-w-[250px] whitespace-pre-wrap">${sanitizeHTML(text)}</td>`;
                        }).join('')}
                                    </tr>
                                    <tr><td class="px-4 py-2 font-semibold text-gray-600 sticky left-0 bg-gray-50 border-r">AI Phyto Analysis</td>
                                        ${trialsToCompare.map(t => {
                            const summaries = safeJsonParse(t.AISummariesJSON, {});
                            const text = summaries.phyto || '-';
                            return `<td class="px-4 py-2 border-r text-xs text-gray-600 min-w-[250px] whitespace-pre-wrap">${sanitizeHTML(text)}</td>`;
                        }).join('')}
                                    </tr>
                                </tbody>
                            </table >
                `;
                        tableContainer.innerHTML = tableHTML;
                    }

                    runComparison();
                },
                efficacyData: (efficacyData) => {
                    const listEl = document.getElementById('efficacy-data-list');
                    if (!listEl) return;
                    listEl.innerHTML = efficacyData.map((obs, index) => {
                        const obsDate = obs.date ? new Date(obs.date).toLocaleDateString() : 'N/A';
                        return `<div class="flex items-center justify-between bg-white p-2 rounded-md border text-gray-700">
                            <div><strong>${obsDate}</strong> - ${sanitizeHTML(obs.label)}</div>
                            <div class="flex items-center gap-4">
                                <span><strong>C:</strong> ${obs.cover}%</span>
                                <span><strong>P:</strong> ${obs.phyto}%</span>
                                <button data-action="delete-efficacy" data-index="${index}" class="text-red-500 font-bold">&times;</button>
                            </div>
                        </div>`;
                    }).join('');
                }
            };

            // --- API & DATA HANDLING ---
            async function apiCall(action, payload = {}, showOverlay = true) {
                if (showOverlay) loadingOverlay.classList.remove('hidden');
                try {
                    const fullPayload = { ...payload, spreadsheetId: state.settings.sheetId, folderId: state.settings.folderId };
                    const res = await fetch(state.settings.scriptUrl, {
                        method: 'POST',
                        headers: { "Content-Type": "text/plain;charset=utf-8" },
                        body: JSON.stringify({ action, payload: fullPayload }),
                    });

                    if (!res.ok) {
                        return { _errType: 'network', message: `HTTP ${res.status}: ${res.statusText} ` };
                    }

                    const text = await res.text();
                    let result;
                    try {
                        result = JSON.parse(text);
                    } catch (e) {
                        return { _errType: 'parse', message: "Invalid JSON from server" };
                    }

                    const errorMsg = result.message || (result.data && result.data.message);
                    const isError = result.status === 'error' || (result.data && result.data.status === 'error') || result.success === false || (result.data && result.data.success === false);

                    if (isError) {
                        return { _errType: 'server', message: errorMsg || 'Unknown server error' };
                    }

                    // Backend returns result.data for success, or the object itself
                    return result.data !== undefined ? result.data : result;
                } catch (error) {
                    console.error('API Call Error:', action, error);
                    return { _errType: 'fetch', message: error.message };
                } finally {
                    if (showOverlay) loadingOverlay.classList.add('hidden');
                }
            }

            function showToast(message, type = 'success') {
                toast.textContent = message;
                toast.className = `toast show ${type} `;
                setTimeout(() => { toast.className = toast.className.replace('show', ''); }, 5000);
            }

            function openProjectDashboard(id) {
                state.activeProjectId = id; // IMPORTANT: Set activeProjectId instead of currentProjectId for Dashboard logic
                // state.currentProjectId = id; // This might be used elsewhere, keeping for safety or checking if needed
                state.currentProjectId = id;
                switchPage('projectDashboard');
            }
            window.openProjectDashboard = openProjectDashboard;

            // --- PAGE NAVIGATION & RENDERING ---
            function switchPage(pageId) {
                state.currentPage = pageId;
                const pageTitles = { dashboard: 'Dashboard', formulations: 'My Formulations', trials: 'Trials', projects: 'Projects (RCBD)', projectDashboard: 'Project Dashboard', compareTrials: 'Compare Trials', organisations: 'Trial Organisations', ingredients: 'Ingredient Costs', aiAssistant: 'AI Assistant', dataMgmt: 'Data Management', settings: 'Settings' };

                document.querySelectorAll('#sidebar-nav a').forEach(link => {
                    link.classList.toggle('bg-teal-50', link.dataset.page === pageId);
                    link.classList.toggle('text-teal-700', link.dataset.page === pageId);
                    link.classList.toggle('font-semibold', link.dataset.page === pageId);
                    link.classList.toggle('text-slate-600', link.dataset.page !== pageId);
                });

                document.getElementById('page-title').textContent = pageTitles[pageId] || 'Dashboard';
                mainContent.style.animation = 'none';
                mainContent.offsetHeight;
                mainContent.style.animation = 'contentFadeIn 0.5s';
                mainContent.innerHTML = templates.page(pageId);

                // Use a short timeout to ensure the DOM is updated before we try to manipulate it.
                setTimeout(() => {
                    switch (pageId) {
                        case 'dashboard':
                            render.dashboard();
                            break;
                        case 'formulations':
                            render.formulations(state.formulations);
                            break;
                        case 'trials':
                            const filterSelect = mainContent.querySelector('[data-type="trial-formulation"]');
                            if (filterSelect) {
                                const formulationNames = [...new Set((state.trials || []).map(t => t.FormulationName).filter(Boolean))].sort();
                                filterSelect.innerHTML = `< option value = "" > Filter by Formulation(List)</option > ${formulationNames.map(name => `<option value="${name}">${sanitizeHTML(name)}</option>`).join('')} `;
                            }
                            // Restore filters from state
                            document.querySelector('[data-type="trial-search"]').value = state.filterState.search;
                            document.querySelector('[data-type="trial-formulation-text"]').value = state.filterState.formulationText;
                            document.querySelector('[data-type="trial-formulation"]').value = state.filterState.formulation;
                            document.querySelector('[data-type="trial-start-date"]').value = state.filterState.startDate;
                            document.querySelector('[data-type="trial-end-date"]').value = state.filterState.endDate;

                            applyFilters(); // Render with filters
                            updateSelectionBar();
                            break;
                        case 'compareTrials':
                            render.compareTrials();
                            break;
                        case 'organisations':
                            render.organisations(state.organisations);
                            break;
                        case 'ingredients':
                            render.ingredients(state.ingredients);
                            break;
                        case 'settings':
                            const apiKeyContainer = document.getElementById('api-keys-container');
                            if (apiKeyContainer) {
                                apiKeyContainer.innerHTML = state.settings.apiKeys.map((key, i) => render.apiKeyInput(key, i)).join('') || render.apiKeyInput('', 0);
                            }

                            // Report Settings
                            document.getElementById('settings-logo-preview').src = state.settings.logoBase64 || '';
                            document.getElementById('settings-logo-hidden').value = state.settings.logoBase64 || '';
                            document.getElementById('settings-card-size').value = state.settings.cardSize || 'ID';

                            // Setup Logo Input Listener
                            document.getElementById('settings-logo-input').addEventListener('change', function (e) {
                                const file = e.target.files[0];
                                if (file) {
                                    const reader = new FileReader();
                                    reader.onload = function (evt) {
                                        document.getElementById('settings-logo-preview').src = evt.target.result;
                                        document.getElementById('settings-logo-hidden').value = evt.target.result;
                                    };
                                    reader.readAsDataURL(file);
                                }
                            });

                            document.getElementById('script-url').value = state.settings.scriptUrl || '';
                            document.getElementById('sheet-url').value = state.settings.sheetId ? `https://docs.google.com/spreadsheets/d/${state.settings.sheetId}/` : '';
                            document.getElementById('folder-url').value = state.settings.folderId ? `https://drive.google.com/drive/folders/${state.settings.folderId}` : '';

                            // API Model Selection
                            const modelSelect = document.getElementById('settings-api-model');
                            if (modelSelect) {
                                modelSelect.value = state.settings.apiModel || 'gemini-2.0-flash-exp';
                            }

                            // API Quota Saver toggle
                            const autoAnalyzeCheckbox = document.getElementById('auto-analyze-photos');
                            if (autoAnalyzeCheckbox) {
                                autoAnalyzeCheckbox.checked = state.settings.autoAnalyzePhotos || false;
                            }

                            // QR Settings
                            const qrGrid = document.getElementById('qr-settings-grid');
                            if (qrGrid) {
                                const fields = state.settings.qrCodeFields || {};
                                qrGrid.innerHTML = Object.keys(fields).map(key => `
                                    <label class="flex items-center gap-2">
                                        <input type="checkbox" name="qr-${key}" ${fields[key] ? 'checked' : ''} class="h-4 w-4 rounded border-gray-300 text-teal-600">
                                        ${key.replace(/([A-Z])/g, ' $1')}
                                    </label>
                                `).join('');
                            }

                            const qrOnlineGrid = document.getElementById('qr-online-settings-grid');
                            if (qrOnlineGrid) {
                                const fields = state.settings.qrOnlineFields || {};
                                qrOnlineGrid.innerHTML = Object.keys(fields).map(key => `
                                    <label class="flex items-center gap-2">
                                        <input type="checkbox" name="qro-${key}" ${fields[key] ? 'checked' : ''} class="h-4 w-4 rounded border-gray-300 text-teal-600">
                                        ${key.replace('show', '').replace(/([A-Z])/g, ' $1')}
                                    </label>
                                `).join('');
                            }
                            break;
                        case 'aiAssistant':
                            const chatBox = document.getElementById('ai-chat-box');
                            if (!chatBox) return;
                            chatBox.innerHTML = '';
                            if (state.aiChatHistory.length === 0) {
                                appendMessageToChat('Hello! Ask me about your trial data.', 'ai', false);
                            } else {
                                state.aiChatHistory.forEach(msg => appendMessageToChat(msg.text, msg.sender, false, msg.image, msg.mimeType));
                            }
                            break;
                        case 'dataMgmt':
                            renderBulkAnalysisControls();
                            break;
                        case 'projects':
                            render.projects();
                            break;
                        case 'projectDashboard':
                            render.projectDashboard();
                            break;
                    }
                    lucide.createIcons();
                }, 50);
            }

            // Expose globally for HTML onclick
            window.switchPage = switchPage;
            window.switchTrialDetailTab = (tab) => {
                document.querySelectorAll('.trial-detail-tab-btn').forEach(b => {
                    b.classList.remove('text-teal-600', 'border-b-2', 'border-teal-600', 'font-bold');
                    b.classList.add('text-gray-500', 'hover:text-gray-700');
                });
                document.querySelector(`[data-tab="${tab}"]`).classList.add('text-teal-600', 'border-b-2', 'border-teal-600', 'font-bold');
                document.querySelector(`[data-tab="${tab}"]`).classList.remove('text-gray-500', 'hover:text-gray-700');

                document.querySelectorAll('.trial-detail-content').forEach(c => c.classList.add('hidden'));
                document.getElementById(`trial-detail-${tab}`).classList.remove('hidden');
            };

            // --- MODAL HANDLING ---
            function openModal(id, isEdit = false, data = {}) {
                modalContainer.innerHTML = templates.modal(id, isEdit, data);
                modalContainer.classList.remove('hidden');
                if (id === 'trial') setupTrialModalLogic();
                lucide.createIcons();
            }
            function closeModal() {
                // Close main modal container
                modalContainer.innerHTML = '';
                modalContainer.classList.add('hidden');

                // Close protocol modal if it's open
                const protocolModal = document.getElementById('protocol-settings-modal');
                if (protocolModal) {
                    protocolModal.classList.add('hidden');
                }
            }

            function setupTrialModalLogic() {
                // This function sets up chart rendering and other logic for trial detail modals
                setTimeout(() => {
                    // Render trial detail charts if canvas elements exist
                    const coverCtx = document.getElementById('single-cover-chart');
                    const phytoCtx = document.getElementById('single-phyto-chart');

                    if (coverCtx || phytoCtx) {
                        // Get the trial ID from the modal
                        const trialIdInput = document.querySelector('[name="trialId"]');
                        if (!trialIdInput) return;

                        const trialId = trialIdInput.value;
                        const trial = state.trials.find(t => t.ID === trialId);
                        if (!trial) return;

                        const efficacyData = safeJsonParse(trial.EfficacyDataJSON, []);
                        if (efficacyData.length === 0) return;

                        // Render Cover Chart
                        if (coverCtx) {
                            const allSpecies = [...new Set(efficacyData.flatMap(obs =>
                                (obs.weedDetails || []).map(wd => wd.species)
                            ))];

                            const datasets = allSpecies.map((species, idx) => {
                                const dataPoints = efficacyData.map(obs => {
                                    const detail = (obs.weedDetails || []).find(wd => wd.species === species);
                                    return detail ? { x: parseFloat(obs.daa), y: parseFloat(detail.cover) } : null;
                                }).filter(Boolean);

                                const colors = ['#0d9488', '#d97706', '#2563eb', '#dc2626', '#7c3aed', '#db2777'];
                                return {
                                    label: species,
                                    data: dataPoints,
                                    borderColor: colors[idx % colors.length],
                                    backgroundColor: colors[idx % colors.length],
                                    fill: false,
                                    tension: 0.3
                                };
                            });

                            new Chart(coverCtx, {
                                type: 'line',
                                data: { datasets },
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    scales: {
                                        x: { type: 'linear', title: { display: true, text: 'Days After Application (DA-A)' } },
                                        y: { beginAtZero: true, max: 100, title: { display: true, text: '% Cover' } }
                                    },
                                    plugins: {
                                        legend: { position: 'bottom' },
                                        tooltip: { mode: 'index', intersect: false }
                                    }
                                }
                            });
                        }

                        // Render Phytotoxicity Chart
                        if (phytoCtx) {
                            const dataPoints = efficacyData.map(obs => ({
                                x: parseFloat(obs.daa),
                                y: parseFloat(obs.phyto || 0)
                            })).filter(p => p.x != null);

                            new Chart(phytoCtx, {
                                type: 'line',
                                data: {
                                    datasets: [{
                                        label: '% Phytotoxicity',
                                        data: dataPoints,
                                        borderColor: '#dc2626',
                                        backgroundColor: '#dc2626',
                                        fill: false,
                                        tension: 0.3
                                    }]
                                },
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    scales: {
                                        x: { type: 'linear', title: { display: true, text: 'Days After Application (DA-A)' } },
                                        y: { beginAtZero: true, max: 100, title: { display: true, text: '% Phytotoxicity' } }
                                    },
                                    plugins: {
                                        legend: { display: false },
                                        tooltip: { mode: 'index', intersect: false }
                                    }
                                }
                            });
                        }
                    }
                }, 100);
            }

            function showConfirmation(title, message, onConfirm) {
                openModal('confirm');
                const okBtn = document.querySelector('[data-action="confirm-ok"]');
                const cancelBtn = document.querySelector('[data-action="confirm-cancel"]');
                document.getElementById('confirm-title').textContent = title;
                document.getElementById('confirm-message').textContent = message;
                const cleanup = () => { okBtn.removeEventListener('click', confirmHandler); cancelBtn.removeEventListener('click', cleanup); closeModal(); };
                const confirmHandler = () => { onConfirm(); cleanup(); };
                okBtn.addEventListener('click', confirmHandler, { once: true });
                cancelBtn.addEventListener('click', cleanup, { once: true });
            }

            // --- EVENT HANDLERS & BUSINESS LOGIC ---
            function handleOpenModal(type, id = null, data = {}) {
                if (type === 'weedId') {
                    const trial = state.trials.find(t => t.ID === id);
                    if (trial) openModal('weedId', false, { trial });
                    return;
                }
                state.croppedPhotosData = [];
                state.currentTrialIdForCamera = null;
                const isEditMode = (id && typeof id === 'string');
                openModal(type, isEditMode, data);
                setTimeout(() => {
                    if (type === 'trial') {
                        const form = document.getElementById('trial-form');
                        form.querySelector('#trial-formulation').innerHTML = `<option value="">Select formulation</option>${state.formulations.map(f => `<option value="${f.ID}">${sanitizeHTML(f.Name)}</option>`).join('')}`;
                        const today = new Date().toISOString().split('T')[0];
                        form.querySelector('#trial-date').value = today;
                        form.querySelector('#photo-date').value = today;
                        const investigatorList = document.getElementById('investigator-list');
                        const uniqueInvestigators = [...new Set(state.trials.map(t => t.InvestigatorName).filter(Boolean))];
                        investigatorList.innerHTML = uniqueInvestigators.map(name => `<option value="${sanitizeHTML(name)}"></option>`).join('');

                        // RCBD Project/Block population
                        const projectSelect = form.querySelector('#trial-project');
                        const blockSelect = form.querySelector('#trial-block');
                        if (projectSelect && blockSelect) {
                            projectSelect.innerHTML = '<option value="">No Project</option>' +
                                state.projects.map(p => `<option value="${p.ID}">${sanitizeHTML(p.Name)}</option>`).join('');

                            // Use passed data OR state
                            const targetProjectId = data.projectId || data.ProjectID || state.currentProjectId;
                            const targetBlockId = data.blockId || data.BlockID;

                            if (targetProjectId) {
                                projectSelect.value = targetProjectId;
                                blockSelect.innerHTML = '<option value="">No Block</option>' +
                                    state.blocks.filter(b => b.ProjectID === targetProjectId).map(b => `<option value="${b.ID}">${sanitizeHTML(b.Name)}</option>`).join('');

                                if (targetBlockId) {
                                    blockSelect.value = targetBlockId;
                                }
                            }
                        }

                        addObservation(); // Add initial baseline observation
                    } else if (type === 'formulation') {
                        addFormulationIngredientRow();
                    } else if (type === 'project') {
                        // Project modal initialization
                        if (id) {
                            const project = state.projects.find(p => p.ID === id);
                            populateForm(document.getElementById('project-form'), project);
                        }
                    } else if (type === 'block') {
                        // Block modal initialization
                        // Prioritize data.projectId. Handle legacy case where id might be an object (though we discouraged that).
                        // CHECK: id can be null, string (ID), or object (legacy cfg).
                        let projectId = state.currentProjectId;
                        if (data && data.projectId) projectId = data.projectId;
                        else if (id && typeof id === 'object' && id.projectId) projectId = id.projectId;

                        const projectBlocks = state.blocks.filter(b => b.ProjectID === projectId);

                        // isEditMode is already calculated at top of function based on id being a string
                        const nextRep = isEditMode ? (data.ReplicationNum || 1) : (projectBlocks.length + 1);

                        const form = document.getElementById('block-form');
                        if (form) {
                            form.querySelector('[name="replicationNum"]').value = nextRep;
                            const display = form.querySelector('#block-rep-display');
                            if (display) display.textContent = `R${nextRep}`;
                            if (!isEditMode) {
                                form.querySelector('[name="name"]').value = `Block ${String.fromCharCode(64 + nextRep)}`;
                            }
                        }
                    } else if (type === 'randomize') {
                        const modalForm = document.getElementById('randomize-form');
                        const container = document.getElementById('randomize-formulations-list');
                        if (container) {
                            container.innerHTML = state.formulations.map(f => `
                                <div class="flex items-center gap-2 p-2 hover:bg-slate-50 rounded border-b border-slate-100">
                                    <input type="checkbox" name="fids" value="${f.ID}" id="cb_${f.ID}" class="h-5 w-5 rounded text-teal-600">
                                    <div class="flex-grow pl-2">
                                        <label for="cb_${f.ID}" class="text-sm font-medium cursor-pointer block text-slate-700">${sanitizeHTML(f.Name)}</label>
                                    </div>
                                    <select name="role_${f.ID}" class="text-xs border border-slate-300 rounded p-1.5 bg-white text-slate-700 focus:border-teal-500 focus:ring-1 focus:ring-teal-500" onchange="document.getElementById('cb_${f.ID}').checked = true">
                                        <option value="experimental">Experimental</option>
                                        <option value="standard">Standard Check</option>
                                        <option value="control">Untreated Control</option>
                                    </select>
                                </div>
                            `).join('');
                        }
                    }
                }, 50);
            }

            function handleEdit(type, id) {
                state.currentTrialIdForCamera = null;
                const data = state[type + 's'].find(item => item.ID === id);
                if (data) {
                    openModal(type, true);
                    setTimeout(() => populateForm(document.getElementById(`${type}-form`), data), 50);
                }
            }

            // Expose for usage in HTML strings associated with Trial Cards
            window.openTrialDetail = (id) => handleEdit('trial', id);

            function handleDuplicateItem(type, id) {
                const collection = type + 's';
                const originalItem = state[collection].find(item => item.ID === id);
                if (!originalItem) return;

                let clone = { ...originalItem };
                delete clone.ID;

                if (type === 'formulation') {
                    clone.Name = `${originalItem.Name} (Copy)`;
                } else if (type === 'trial') {
                    // For trials, duplicate setup but clear execution data
                    clone.Date = new Date().toISOString().split('T')[0]; // Reset to today
                    clone.PhotoURLs = '[]';
                    clone.WeedPhotosJSON = '[]';
                    clone.EfficacyDataJSON = '[]';
                    clone.AISummariesJSON = '{}';
                    clone.Result = '';
                    clone.Conclusion = '';
                    clone.Notes = '';
                    clone.IsCompleted = false;
                    clone.ControlFinalized = false;
                    clone.FinalControlDuration = null;
                    clone.FinalizationDate = null;
                    // Keep formulation, dosage, investigator, weed species, location
                }

                openModal(type, false); // Open in "Add" mode (not edit) but populated
                setTimeout(() => { populateForm(document.getElementById(`${type}-form`), clone) }, 50);
            }

            async function handleDelete(type, id) {
                let message = `This will permanently remove the ${type}.`;
                let associatedTrials = [];
                let associatedBlocks = [];

                if (type === 'formulation' && state.trials.some(trial => trial.FormulationID === id)) {
                    return showToast('Cannot delete: formulation is in use.', 'error');
                }

                if (type === 'project') {
                    associatedBlocks = state.blocks.filter(b => b.ProjectID === id);
                    associatedTrials = state.trials.filter(t => t.ProjectID === id);
                    if (associatedBlocks.length > 0 || associatedTrials.length > 0) {
                        message = `Warning: Deleting this Project will also delete ${associatedBlocks.length} Block(s) and ${associatedTrials.length} Trial(s). This cannot be undone.`;
                    }
                } else if (type === 'block') {
                    associatedTrials = state.trials.filter(t => t.BlockID === id);
                    if (associatedTrials.length > 0) {
                        message = `Warning: Deleting this Block will also delete ${associatedTrials.length} Trial(s).`;
                    }
                }

                showConfirmation(`Delete ${type}?`, message, async () => {
                    const collection = type + 's';
                    // Snapshot for rollback (shallow clone of arrays)
                    const originalState = {
                        [collection]: [...state[collection]],
                        blocks: [...state.blocks],
                        trials: [...state.trials]
                    };

                    try {
                        // 1. Optimistic Local Update
                        state[collection] = state[collection].filter(item => item.ID !== id);

                        // Cascade local deletes
                        if (type === 'project') {
                            state.blocks = state.blocks.filter(b => b.ProjectID !== id);
                            state.trials = state.trials.filter(t => t.ProjectID !== id);
                        } else if (type === 'block') {
                            state.trials = state.trials.filter(t => t.BlockID !== id);
                        }

                        showToast(`Deleting ${type}...`, 'info');

                        // 2. Perform Backend Deletes (SEQUENTIAL to avoid race conditions/locking issues in Sheets)
                        const totalItems = associatedTrials.length + associatedBlocks.length;
                        let processedCount = 0;

                        // Delete Trials
                        for (const t of associatedTrials) {
                            await apiCall('deleteTrial', { id: t.ID }, false);
                            processedCount++;
                            if (processedCount % 3 === 0) showToast(`Deleting items... (${processedCount}/${totalItems})`, 'info');
                        }

                        // Delete Blocks
                        for (const b of associatedBlocks) {
                            await apiCall('deleteBlock', { id: b.ID }, false);
                            processedCount++;
                            if (processedCount % 3 === 0) showToast(`Deleting items... (${processedCount}/${totalItems})`, 'info');
                        }

                        // Delete the main item
                        const result = await apiCall(`delete${type.charAt(0).toUpperCase() + type.slice(1)}`, { id }, false);

                        if (!result || !result.success) {
                            throw new Error('Main delete failed');
                        }

                        showToast(`${type.charAt(0).toUpperCase() + type.slice(1)} deleted.`, 'success');

                    } catch (error) {
                        console.error('Delete failed:', error);
                        showToast(`Sync failed. Reverting changes.`, 'error');
                        // Revert
                        state[collection] = originalState[collection];
                        state.blocks = originalState.blocks;
                        state.trials = originalState.trials;
                    }

                    switchPage(state.currentPage);
                });
            }



            async function handleToggleLiveStatus(trialId) {
                const trial = state.trials.find(t => t.ID === trialId);
                if (!trial) return;

                const newStatus = String(trial.IsLive).toLowerCase() === 'false' || !trial.IsLive;
                trial.IsLive = newStatus;

                showToast(`Plot ${newStatus ? 'activated' : 'deactivated'}.`, 'success');
                applyFilters(); // Instant UI update

                await apiCall('updateTrialRecord', { ID: trialId, IsLive: newStatus }, false);
            }

            async function handleSaveLiveQrSettingsFinal() {
                const form = document.getElementById('live-qr-settings-form');
                if (!form) return;
                const trialId = form.dataset.id;
                const trial = state.trials.find(t => t.ID === trialId);
                if (!trial) return;

                const formData = new FormData(form);
                const settings = {};
                Object.keys(state.settings.qrOnlineFields).forEach(key => {
                    settings[key] = formData.get(key) !== null;
                });

                trial.LiveQRSettings = JSON.stringify(settings);
                showToast('Live QR Content updated.', 'success');
                closeModal();

                await apiCall('updateTrialRecord', { ID: trialId, LiveQRSettings: trial.LiveQRSettings }, false);
            }

            async function generateTrialCardsCombined(trialId, mode) {
                const trial = state.trials.find(t => t.ID === trialId);
                if (!trial) return;

                closeModal();
                showToast(`Generating ${mode} QR Label...`, 'info');

                // If online, check if it's live
                if (mode === 'online' && (String(trial.IsLive).toLowerCase() === 'false' || !trial.IsLive)) {
                    showToast('This plot is INACTIVE. QR will say "Plot Inactive" until activated.', 'warning');
                }

                const qrContent = generateQrContent(trial, mode);

                // Now open the label modal and render
                openModal('qrLabel', false, { trial, qrContent, mode });

                setTimeout(() => {
                    const canvasContainer = document.getElementById("qr-code-canvas");
                    if (canvasContainer) {
                        canvasContainer.innerHTML = '';
                        new QRCode(canvasContainer, {
                            text: qrContent,
                            width: 256,
                            height: 256,
                            colorDark: "#000000",
                            colorLight: "#ffffff",
                            correctLevel: QRCode.CorrectLevel.H
                        });
                    }
                }, 100);
            }

            function generateQrContent(trial, mode) {
                // IMPORTANT: Reload settings from localStorage to ensure latest QR preferences are used
                const savedSettings = localStorage.getItem('appSettings');
                if (savedSettings) {
                    try {
                        const parsed = JSON.parse(savedSettings);
                        if (parsed.qrCodeFields) state.settings.qrCodeFields = parsed.qrCodeFields;
                        if (parsed.qrOnlineFields) state.settings.qrOnlineFields = parsed.qrOnlineFields;
                    } catch (e) {
                        console.warn('Could not reload QR settings:', e);
                    }
                }

                if (mode === 'online') {
                    // Standard online URL: scriptUrl?trialId=...&spreadsheetId=...
                    const params = new URLSearchParams({
                        trialId: trial.ID,
                        spreadsheetId: state.settings.sheetId
                    });
                    return `${state.settings.scriptUrl}?${params.toString()}`;
                } else {
                    // Offline data encoding
                    const fields = state.settings.qrCodeFields;
                    const lines = [];
                    lines.push(`H-APP: ${trial.FormulationName}`);
                    if (fields.InvestigatorName && trial.InvestigatorName) lines.push(`Inv: ${trial.InvestigatorName}`);
                    if (fields.Date && trial.Date) lines.push(`D: ${new Date(trial.Date).toLocaleDateString()}`);
                    if (fields.Dosage && trial.Dosage) lines.push(`Dos: ${trial.Dosage}`);
                    if (fields.Location && trial.Location) lines.push(`Loc: ${trial.Location}`);
                    if (fields.WeedSpecies && trial.WeedSpecies) lines.push(`W: ${trial.WeedSpecies}`);
                    if (fields.Weather) {
                        const weather = `T:${trial.Temperature || '-'}C H:${trial.Humidity || '-'}%`;
                        lines.push(`Wth: ${weather}`);
                    }
                    if (fields.Result && trial.Result) lines.push(`Res: ${trial.Result}`);

                    return lines.join('\n');
                }
            }

            async function handleFormSubmit(form) {
                if (!form) return;
                const formId = form.getAttribute('id');
                const type = formId.replace('-form', '');

                if (formId === 'settings-form') { handleSettingsSave(form); return; }
                if (formId === 'ai-form') { handleAiQuery(document.getElementById('ai-input').value); return; }
                if (formId === 'organise-form') { handleOrganiseSubmit(form); return; }
                if (formId === 'photo-edit-form') { handlePhotoEditSubmit(form); return; }

                const id = form.querySelector('input[name="id"]')?.value || null;
                const isUpdate = !!id;
                const action = isUpdate ? `update${type.charAt(0).toUpperCase() + type.slice(1)}` : `add${type.charAt(0).toUpperCase() + type.slice(1)}`;
                const formData = Object.fromEntries(new FormData(form));

                try {
                    let recordForApi;
                    if (type === 'formulation') {
                        const ingredients = [...document.querySelectorAll('.formulation-ingredient-row')].map(r => ({ id: r.querySelector('.ingredient-selector').value, name: r.querySelector('.ingredient-selector').selectedOptions[0].text, quantity: r.querySelector('.ingredient-quantity').value, unit: r.querySelector('.ingredient-unit-selector').value })).filter(r => r.id);
                        if (ingredients.length === 0) throw new Error('A formulation must have at least one ingredient.');
                        recordForApi = { ID: id, Name: formData.name, Notes: formData.notes, IngredientsJSON: JSON.stringify(ingredients), EstimatedCost: calculateFormulationCost(ingredients) };
                    } else if (type === 'trial') {
                        const formulation = state.formulations.find(f => f.ID === formData.formulationId);
                        if (!formulation) throw new Error('Please select a valid formulation.');

                        const isControl = form.querySelector('[name="isControl"]')?.checked;
                        if (isControl && formData.blockId) {
                            const existingControl = state.trials.find(t => t.BlockID === formData.blockId && String(t.IsControl).toLowerCase() === 'true' && t.ID !== id);
                            if (existingControl) {
                                if (!confirm('Warning: This block already has an Untreated Control. Adding another will invalidate WCE and ANOVA calculations. Do you want to proceed anyway?')) {
                                    return;
                                }
                            }
                        }
                        showToast('Uploading photos...', 'success');
                        const photosToUpload = isUpdate ? state.croppedPhotosData.filter(p => !p.isExisting) : state.croppedPhotosData;
                        const existingPhotos = isUpdate ? state.croppedPhotosData.filter(p => p.isExisting) : [];
                        const uploadedNewPhotos = await uploadPhotos(photosToUpload);
                        const photoURLsForPayload = [...existingPhotos, ...uploadedNewPhotos];
                        const controlFinalized = form.querySelector('#control-finalized').checked;
                        const isCompleted = form.querySelector('#is-completed').checked;
                        let finalizationDate = formData.finalizationDate || null;
                        let finalControlDuration = formData.finalControlDuration !== '' ? parseInt(formData.finalControlDuration, 10) : null;
                        if (controlFinalized && (finalControlDuration == null || !finalizationDate)) {
                            finalizationDate = finalizationDate || new Date().toISOString().split('T')[0];
                            const trialDate = formData.date;
                            if (finalControlDuration == null && trialDate) {
                                const days = Math.floor((new Date(finalizationDate) - new Date(trialDate)) / (1000 * 60 * 60 * 24));
                                finalControlDuration = days < 0 ? 0 : days;
                            }
                        }
                        const efficacyData = collectEfficacyDataFromModal();

                        // VALIDATION
                        const validationError = validateEfficacyObservation(efficacyData);
                        if (validationError) throw new Error(validationError);

                        const efficacyDataJSON = JSON.stringify(efficacyData);
                        let aiSummariesJSON = isUpdate ? state.trials.find(t => t.ID === id)?.AISummariesJSON || '{}' : '{}';
                        if (isUpdate) {
                            const originalTrial = state.trials.find(t => t.ID === id);
                            if (originalTrial && originalTrial.EfficacyDataJSON !== efficacyDataJSON) {
                                aiSummariesJSON = '{}'; // Invalidate summaries if efficacy data changed
                            }
                        }

                        recordForApi = {
                            ID: id, InvestigatorName: formData.investigatorName, Location: formData.location, FormulationID: formData.formulationId, FormulationName: formulation.Name, Dosage: formData.dosage,
                            Replication: formData.replication,
                            WeedSpecies: formData.weedSpecies || '', Date: formData.date, Result: formData.result, Conclusion: formData.conclusion, Notes: formData.notes,
                            Yield: formData.yield || null,
                            Temperature: formData.temperature, Humidity: formData.humidity, Windspeed: formData.windspeed, Rain: formData.rain,
                            PhotoURLs: JSON.stringify(photoURLsForPayload.map(({ fileData, ...rest }) => rest)),
                            ControlFinalized: controlFinalized,
                            FinalControlDuration: controlFinalized ? finalControlDuration : null,
                            FinalizationDate: controlFinalized ? finalizationDate : null,
                            IsCompleted: isCompleted,
                            ProjectID: formData.projectId || null,
                            BlockID: formData.blockId || null,
                            IsControl: isControl || false,
                            IsStandardCheck: form.querySelector('[name="isStandardCheck"]')?.checked || false,
                            RandomizationOrder: (state.trials.find(x => x.ID === id)?.RandomizationOrder) || (safeJsonParse(aiSummariesJSON)?.plotNum) || null,
                            EfficacyDataJSON: efficacyDataJSON,
                            AISummariesJSON: aiSummariesJSON
                        };
                    } else if (type === 'ingredient') {
                        // Explicitly get values to ensure correctness and redundant payload
                        const name = form.querySelector('[name="name"]').value.trim();
                        const cost = parseFloat(form.querySelector('[name="cost"]').value);
                        const unit = form.querySelector('[name="unit"]').value;
                        recordForApi = {
                            ID: id,
                            Name: name, name: name, // Send both cases to ensure backend compatibility
                            Cost: cost, cost: cost,
                            Unit: unit, unit: unit
                        };
                    } else if (type === 'project') {
                        recordForApi = {
                            ID: id,
                            Name: formData.name,
                            Metric: formData.metric,
                            Notes: formData.notes,
                            Status: isUpdate ? (state.projects.find(p => p.ID === id)?.Status || 'Draft') : 'Draft',
                            CreatedAt: isUpdate ? (state.projects.find(p => p.ID === id)?.CreatedAt || new Date().toISOString()) : new Date().toISOString()
                        };
                    } else if (type === 'block') {
                        recordForApi = {
                            ID: id,
                            ProjectID: formData.projectId || state.currentProjectId,
                            Name: formData.name,
                            ReplicationNum: formData.replicationNum || 0,
                            RandomizationOrder: formData.randomizationOrder || ''
                        };
                    } else if (type === 'randomize') {
                        const projectId = formData.projectId;
                        // Get all checked IDs
                        const selectedFids = Array.from(form.querySelectorAll('input[name="fids"]:checked')).map(cb => cb.value);

                        if (selectedFids.length === 0) throw new Error('Select at least one treatment.');

                        // Map IDs to Roles
                        const treatmentRoles = selectedFids.map(fid => {
                            const roleSelect = form.querySelector(`select[name="role_${fid}"]`);
                            const role = roleSelect ? roleSelect.value : 'experimental';
                            return { fid, role };
                        });

                        // Validate Control
                        const controls = treatmentRoles.filter(t => t.role === 'control');
                        if (controls.length !== 1) throw new Error('You must select exactly ONE Untreated Control.');

                        const projectBlocks = state.blocks.filter(b => String(b.ProjectID) === String(projectId));
                        if (projectBlocks.length === 0) throw new Error('Create at least one block before randomizing.');

                        const trialsToSave = [];
                        projectBlocks.forEach(block => {
                            // Create pool of treatments for this block
                            const treatments = treatmentRoles.map(t => {
                                const f = state.formulations.find(form => form.ID === t.fid);
                                return {
                                    FormulationID: t.fid,
                                    FormulationName: f.Name,
                                    IsControl: t.role === 'control',
                                    IsStandardCheck: t.role === 'standard'
                                };
                            });

                            // Fisher-Yates Shuffle
                            for (let i = treatments.length - 1; i > 0; i--) {
                                const j = Math.floor(Math.random() * (i + 1));
                                [treatments[i], treatments[j]] = [treatments[j], treatments[i]];
                            }

                            // Create Trial objects
                            treatments.forEach((t, index) => {
                                trialsToSave.push({
                                    ID: (window.crypto && window.crypto.randomUUID) ? window.crypto.randomUUID() : Math.random().toString(36).substring(2, 15),
                                    ProjectID: projectId,
                                    BlockID: block.ID,
                                    FormulationID: t.FormulationID,
                                    FormulationName: t.FormulationName,
                                    InvestigatorName: formData.investigatorName || '',
                                    Dosage: formData.dosage || '',
                                    WeedSpecies: formData.weedSpecies || '',
                                    Date: formData.date || new Date().toISOString().split('T')[0],
                                    Replication: block.ReplicationNum,
                                    RandomizationOrder: index + 1,
                                    IsControl: t.IsControl,
                                    IsStandardCheck: t.IsStandardCheck,
                                    Status: 'Draft',
                                    IsLive: true,
                                    EfficacyDataJSON: '[]',
                                    PhotoURLs: '[]',
                                    WeedPhotosJSON: '[]',
                                    PlotNumber: index + 1,
                                    AISummariesJSON: JSON.stringify({ plotNum: index + 1 })
                                });
                            });
                        });

                        closeModal();
                        showToast(`Randomizing ${trialsToSave.length} plots...`);

                        // Optimistic Update for Batch
                        state.trials.push(...trialsToSave);
                        render.projectDashboard(); // Render immediately

                        await apiCall('addBatchTrials', { items: trialsToSave }, false);
                        // await initializeApp(false); // REMOVED

                        showToast('Randomized layout generated!', 'success');
                        return; // Exit handleFormSubmit early
                    } else {
                        throw new Error(`Unknown form type: ${type}`);
                    }

                    closeModal();
                    showToast(`${type.charAt(0).toUpperCase() + type.slice(1)} saved! Syncing...`);
                    const result = await apiCall(action, recordForApi, false);

                    // Unified response check
                    if (result && result._errType) {
                        throw new Error(result.message || `Server error (${result._errType})`);
                    }

                    // Use the result record if available, otherwise use our local record for optimistic consistency
                    // but prefer backend response if it has ID (for new items)
                    const backendRecord = (result && result.record) ? result.record : result;

                    if (!backendRecord || !backendRecord.ID) {
                        // Fallback to local record if backend doesn't return ID (shouldn't happen for adds)
                        console.error('Raw Server Result:', result);
                        // If it was an update, we might be fine, but for add we need ID
                        if (!isUpdate) throw new Error('Server sync failed. Response was invalid.');
                    }

                    const savedRecord = backendRecord || recordForApi;

                    // Manual State Update (Optimistic-ish, after server confirmation)
                    const collection = type + 's';
                    if (state[collection]) {
                        if (isUpdate) {
                            const index = state[collection].findIndex(item => item.ID === id);
                            if (index !== -1) {
                                state[collection][index] = { ...state[collection][index], ...savedRecord };
                            }
                        } else {
                            state[collection].push(savedRecord);
                        }
                    }

                    // await initializeApp(false); // REMOVED
                    showToast(`${type.charAt(0).toUpperCase() + type.slice(1)} saved successfully!`, 'success');

                    // TRIGGER STATS UPDATE
                    if (type === 'trial' && savedRecord && savedRecord.ID) {
                        // Non-blocking call to update statistics
                        // Ensure we use the correct async function
                        if (typeof window.calculateAndSaveTrialStats === 'function') {
                            window.calculateAndSaveTrialStats(savedRecord.ID).catch(err => console.error("Stats Auto-Save Failed:", err));
                        } else {
                            console.warn("calculateAndSaveTrialStats function not found.");
                        }
                    }

                    // Use switchPage to ensure we land on the right page, but for trials we need to maintain filters
                    if (type === 'trial') {
                        applyFilters(); // Refresh filtered list without resetting state
                    } else if (state.currentPage === 'projectDashboard') {
                        render.projectDashboard(); // Re-render dashboard if we are there
                    } else {
                        switchPage(state.currentPage);
                    }

                } catch (error) {
                    console.error(`Save failed for ${type}:`, error);
                    showToast(`Save failed: ${error.message}`, 'error');
                    // await initializeApp(false); // Removed, but maybe consider re-fetch on error if state is desynced?
                    // For now, keep it simple.
                    switchPage(state.currentPage);
                }
            }

            function populateForm(form, data) {
                if (!form) return;
                const formId = form.getAttribute('id');
                if (form.querySelector('input[name="id"]') && data.ID) {
                    form.querySelector('input[name="id"]').value = data.ID;
                }
                if (formId === 'trial-form') {
                    // RCBD Project/Block population and selection
                    const projectSelect = form.querySelector('#trial-project');
                    const blockSelect = form.querySelector('#trial-block');
                    if (projectSelect && blockSelect) {
                        projectSelect.innerHTML = '<option value="">No Project</option>' +
                            state.projects.map(p => `<option value="${p.ID}">${sanitizeHTML(p.Name)}</option>`).join('');
                        projectSelect.value = data.ProjectID || '';

                        const pid = data.ProjectID || '';
                        const filtered = state.blocks.filter(b => b.ProjectID === pid);
                        blockSelect.innerHTML = '<option value="">No Block</option>' +
                            filtered.map(b => `<option value="${b.ID}">${sanitizeHTML(b.Name)}</option>`).join('');
                        blockSelect.value = data.BlockID || '';
                    }
                    form.querySelector('[name="isControl"]').checked = String(data.IsControl).toLowerCase() === 'true';
                    form.querySelector('[name="isStandardCheck"]').checked = String(data.IsStandardCheck).toLowerCase() === 'true';

                    form.querySelector('[name="investigatorName"]').value = data.InvestigatorName || '';
                    const formulationSelect = form.querySelector('[name="formulationId"]');
                    formulationSelect.innerHTML = state.formulations.map(f => `<option value="${f.ID}">${sanitizeHTML(f.Name)}</option>`).join('');
                    formulationSelect.value = data.FormulationID || '';
                    form.querySelector('[name="location"]').value = data.Location || '';
                    form.querySelector('[name="dosage"]').value = data.Dosage || '';
                    form.querySelector('[name="yield"]').value = data.Yield || '';
                    form.querySelector('[name="replication"]').value = data.Replication || '';
                    form.querySelector('[name="weedSpecies"]').value = data.WeedSpecies || '';
                    const trialDate = new Date(data.Date).toISOString().split('T')[0];
                    form.querySelector('[name="date"]').value = trialDate;
                    form.querySelector('#photo-date').value = trialDate;
                    form.querySelector('[name="result"]').value = data.Result || '';
                    form.querySelector('[name="conclusion"]').value = data.Conclusion || '';
                    form.querySelector('[name="notes"]').value = data.Notes || '';
                    form.querySelector('[name="temperature"]').value = data.Temperature || '';
                    form.querySelector('[name="humidity"]').value = data.Humidity || '';
                    form.querySelector('[name="windspeed"]').value = data.Windspeed || '';
                    form.querySelector('[name="rain"]').value = data.Rain || '';
                    form.querySelector('#is-completed').checked = String(data.IsCompleted).toLowerCase() === 'true';
                    const controlCheckbox = form.querySelector('#control-finalized');
                    const isFinalized = String(data.ControlFinalized).toLowerCase() === 'true';
                    controlCheckbox.checked = isFinalized;
                    if (isFinalized) {
                        form.querySelector('#finalization-details').classList.remove('hidden');
                        form.querySelector('#finalization-date').value = data.FinalizationDate ? new Date(data.FinalizationDate).toISOString().split('T')[0] : '';
                        form.querySelector('#final-control-duration').value = data.FinalControlDuration != null ? data.FinalControlDuration : '';
                    } else {
                        form.querySelector('#finalization-details').classList.add('hidden');
                    }

                    let efficacyData = safeJsonParse(data.EfficacyDataJSON);
                    // Backwards compatibility for old data format
                    if (efficacyData.length > 0 && efficacyData.some(d => d.cover !== undefined && d.weedDetails === undefined)) {
                        efficacyData.forEach(obs => {
                            obs.weedDetails = [{ species: data.WeedSpecies || 'Unknown', cover: obs.cover, status: '', notes: '' }];
                            delete obs.cover;
                        });
                    }
                    renderEfficacyObservations(efficacyData);

                    state.croppedPhotosData = safeJsonParse(data.PhotoURLs).map(p => ({ ...p, fileData: p.url, isExisting: true }));
                    updatePhotoPreview();
                } else if (formId === 'formulation-form') {
                    form.querySelector('[name="name"]').value = data.Name;
                    form.querySelector('[name="notes"]').value = data.Notes || '';
                    const ingredients = safeJsonParse(data.IngredientsJSON);
                    document.getElementById('formulation-ingredients-container').innerHTML = '';
                    ingredients.forEach(ing => addFormulationIngredientRow(ing));
                    updateFormulationCost();
                } else if (formId === 'ingredient-form') {
                    form.querySelector('[name="name"]').value = data.Name;
                    form.querySelector('[name="cost"]').value = data.Cost;
                    form.querySelector('[name="unit"]').value = data.Unit;
                } else if (formId === 'project-form') {
                    form.querySelector('[name="name"]').value = data.Name || '';
                    form.querySelector('[name="metric"]').value = data.Metric || '';
                    form.querySelector('[name="notes"]').value = data.Notes || '';
                } else if (formId === 'block-form') {
                    form.querySelector('[name="name"]').value = data.Name || '';
                    form.querySelector('[name="projectId"]').value = data.ProjectID || data.projectId || '';
                }
            }

            // --- EFFICACY & OBSERVATION LOGIC ---
            function addWeedCoverRow(observationCard, data = {}) {
                const container = observationCard.querySelector('.weed-details-container');
                if (!container) return;
                const row = document.createElement('div');
                row.className = 'weed-details-row grid grid-cols-1 md:grid-cols-4 gap-2 items-center';
                row.innerHTML = `
                    <input type="text" class="p-1 border rounded-md text-xs form-input weed-species" placeholder="Weed Species" value="${sanitizeHTML(data.species || '')}">
                    <input type="number" step="any" min="0" max="100" class="p-1 border rounded-md text-xs form-input weed-cover" placeholder="% Cover" value="${sanitizeHTML(data.cover || '')}">
                    <select class="p-1 border rounded-md text-xs form-input bg-white weed-status">
                        <option value="">Status...</option>
                        <option ${data.status === 'Controlled' ? 'selected' : ''}>Controlled</option>
                        <option ${data.status === 'Burndown' ? 'selected' : ''}>Burndown</option>
                        <option ${data.status === 'Re-emerged' ? 'selected' : ''}>Re-emerged</option>
                        <option ${data.status === 'Resistant' ? 'selected' : ''}>Resistant</option>
                        <option ${data.status === 'Unaffected' ? 'selected' : ''}>Unaffected</option>
                    </select>
                    <div class="flex items-center gap-1">
                        <input type="text" class="p-1 border rounded-md text-xs form-input weed-notes flex-grow" placeholder="Notes" value="${sanitizeHTML(data.notes || '')}">
                        <button type="button" data-action="remove-weed-cover" class="text-red-500 font-semibold p-1">&times;</button>
                    </div>
                `;
                container.appendChild(row);
                row.querySelector('.weed-status').value = data.status || '';
            }

            function addObservation(data = {}) {
                const container = document.getElementById('efficacy-observations-container');
                if (!container) return;
                const index = container.querySelectorAll('.observation-card').length;
                const card = document.createElement('div');
                card.className = 'observation-card border p-4 rounded-lg bg-white space-y-3';
                card.dataset.obsIndex = String(index);
                card.innerHTML = `
                    <div class="flex justify-between items-center">
                        <h5 class="font-semibold text-gray-700">Observation</h5>
                        <button type="button" data-action="remove-observation" class="text-red-500 hover:text-red-700 font-bold">&times;</button>
                    </div>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                        <div>
                            <label class="block text-xs font-medium text-gray-600">Observation Date</label>
                            <input type="date" class="p-2 border rounded-md text-sm w-full form-input obs-date">
                        </div>
                        <div>
                            <label class="block text-xs font-medium text-gray-600">DA-A (auto)</label>
                            <input type="number" class="p-2 border rounded-md text-sm w-full form-input obs-daa bg-slate-100" placeholder="Days After App." readonly>
                        </div>
                        <div>
                            <label class="block text-xs font-medium text-gray-600">% Phytotoxicity</label>
                            <input type="number" step="any" min="0" max="100" class="p-2 border rounded-md text-sm w-full form-input obs-phyto" placeholder="0-100">
                        </div>
                    </div>
                    <div>
                        <h6 class="text-sm font-medium text-gray-700 mt-2">Weed Status Details</h6>
                        <div class="weed-details-container space-y-2 mt-1">
                            <!-- Weed cover rows will be added here -->
                        </div>
                        <button type="button" data-action="add-weed-cover" class="mt-2 text-xs text-teal-600 hover:text-teal-800 font-semibold flex items-center gap-1"><i data-lucide="plus" class="h-3 w-3"></i> Add Weed Detail</button>
                    </div>
                    <div>
                        <label class="block text-xs font-medium text-gray-600">General Notes</label>
                        <textarea rows="2" class="p-2 border rounded-md text-sm w-full form-input obs-notes" placeholder="General observation notes..."></textarea>
                    </div>
                `;
                container.appendChild(card);

                // Populate card with data if provided
                card.querySelector('.obs-date').value = data.date ? new Date(data.date).toISOString().split('T')[0] : '';
                card.querySelector('.obs-daa').value = data.daa || '';
                card.querySelector('.obs-phyto').value = data.phyto || '';
                card.querySelector('.obs-notes').value = data.notes || '';
                if (data.weedDetails && data.weedDetails.length > 0) {
                    data.weedDetails.forEach(detail => addWeedCoverRow(card, detail));
                } else {
                    addWeedCoverRow(card); // Add one default empty row
                }

                lucide.createIcons();

                const dateInput = card.querySelector('.obs-date');
                const daaInput = card.querySelector('.obs-daa');
                const trialDateInput = document.getElementById('trial-date');

                const calculateDaa = () => {
                    if (dateInput.value && trialDateInput.value) {
                        const obsDate = new Date(dateInput.value);
                        const trialDate = new Date(trialDateInput.value);
                        const diffTime = obsDate.getTime() - trialDate.getTime();
                        const diffDays = Math.round(diffTime / (1000 * 60 * 60 * 24));
                        daaInput.value = String(diffDays >= 0 ? diffDays : 0);
                    } else {
                        daaInput.value = '';
                    }
                };

                const rebindTrialDateListener = () => {
                    const allTrialDateInputs = document.querySelectorAll('#trial-date');
                    allTrialDateInputs.forEach(input => {
                        input.removeEventListener('change', updateAllDaa);
                        input.addEventListener('change', updateAllDaa);
                    });
                };

                const updateAllDaa = () => {
                    document.querySelectorAll('.observation-card').forEach(c => {
                        const odi = c.querySelector('.obs-date');
                        const tdi = document.getElementById('trial-date');
                        const dai = c.querySelector('.obs-daa');
                        if (odi.value && tdi.value) {
                            const obsDate = new Date(odi.value);
                            const trialDate = new Date(tdi.value);
                            const diffTime = obsDate.getTime() - trialDate.getTime();
                            const diffDays = Math.round(diffTime / (1000 * 60 * 60 * 24));
                            dai.value = String(diffDays >= 0 ? diffDays : 0);
                        }
                    });
                };

                dateInput.addEventListener('change', calculateDaa);
                rebindTrialDateListener();

                if (index === 0 && !data.date) {
                    dateInput.value = trialDateInput.value;
                }
                calculateDaa(); // Calculate on creation
            }

            function validateEfficacyObservation(data) {
                if (!data || data.length === 0) return null; // Empty is valid (just no data)

                for (let i = 0; i < data.length; i++) {
                    const obs = data[i];
                    if (obs.daa < 0) return `Observation ${i + 1}: DA-A cannot be negative. check dates.`;

                    if (obs.phyto !== null && (obs.phyto < 0 || obs.phyto > 100)) {
                        return `Observation ${i + 1}: Phytotoxicity must be between 0 and 100.`;
                    }

                    if (obs.weedDetails) {
                        for (const weed of obs.weedDetails) {
                            if (weed.cover !== null && (weed.cover < 0 || weed.cover > 100)) {
                                return `Observation ${i + 1}: Weed cover for ${weed.species} must be between 0 and 100.`;
                            }
                        }
                    }
                }
                return null;
            }

            function renderEfficacyObservations(observations) {
                const container = document.getElementById('efficacy-observations-container');
                if (!container) return;
                container.innerHTML = '';
                if (observations && observations.length > 0) {
                    observations.forEach(obs => addObservation(obs));
                } else {
                    addObservation(); // Add one empty observation if none exist
                }
            }

            function collectEfficacyDataFromModal() {
                const data = [];
                document.querySelectorAll('#trial-modal .observation-card').forEach(card => {
                    const date = card.querySelector('.obs-date').value;
                    const daa = card.querySelector('.obs-daa').value;
                    const phyto = card.querySelector('.obs-phyto').value;
                    const notes = card.querySelector('.obs-notes').value;

                    const weedDetails = [];
                    card.querySelectorAll('.weed-details-row').forEach(row => {
                        const species = row.querySelector('.weed-species').value;
                        const cover = row.querySelector('.weed-cover').value;
                        const status = row.querySelector('.weed-status').value;
                        const detailNotes = row.querySelector('.weed-notes').value;

                        if (species || cover || status || detailNotes) {
                            weedDetails.push({
                                species: species.trim(),
                                cover: cover ? parseFloat(cover) : null,
                                status,
                                notes: detailNotes.trim()
                            });
                        }
                    });

                    // Only add the observation if it has any meaningful data
                    if (date || daa || phyto || notes || weedDetails.some(wd => wd.species || wd.cover != null)) {
                        data.push({
                            date,
                            daa: daa ? parseInt(daa, 10) : null,
                            phyto: phyto ? parseFloat(phyto) : null,
                            notes: notes.trim(),
                            weedDetails
                        });
                    }
                });
                return data;
            }

            // --- PHOTO & CAMERA HANDLING ---
            function handlePhotoSelection(event, trialId = null) {
                state.photoQueue = [...event.target.files];
                if (state.photoQueue.length > 0) processPhotoQueue(trialId);
            }

            function processPhotoQueue(trialId) {
                if (state.photoQueue.length === 0) return;
                const file = state.photoQueue.shift();
                const reader = new FileReader();
                reader.onload = e => openCropper(e.target.result, trialId);
                reader.readAsDataURL(file);
            }

            function openCropper(imageData, trialId) {
                state.currentTrialIdForCamera = trialId;
                imageToCrop.src = imageData;
                cropperModal.classList.remove('hidden');
                cropperModal.style.display = 'flex'; // FORCE FLEX
                if (cropper) cropper.destroy();
                cropper = new Cropper(imageToCrop, { viewMode: 0, autoCrop: false, background: false, movable: true, zoomable: true, scalable: true, rotatable: true });
            }

            function closeCropper() {
                if (cropper) cropper.destroy();
                cropper = null;
                cropperModal.classList.add('hidden');
                cropperModal.style.display = 'none';
                if (state.photoQueue.length > 0) processPhotoQueue(state.currentTrialIdForCamera);
                else state.currentTrialIdForCamera = null;
            }

            async function cropAndSaveImage() {
                let canvas = cropper.getCroppedCanvas();

                // 1. DIMENSION SCALING: If photo is massive, shrink it to a reasonable high-res limit (2000px)
                // This reduces the pixel count and makes compression MUCH more effective.
                const MAX_DIM = 2000;
                if (canvas.width > MAX_DIM || canvas.height > MAX_DIM) {
                    const scale = MAX_DIM / Math.max(canvas.width, canvas.height);
                    const scaledCanvas = document.createElement('canvas');
                    scaledCanvas.width = canvas.width * scale;
                    scaledCanvas.height = canvas.height * scale;
                    const ctx = scaledCanvas.getContext('2d');
                    ctx.drawImage(canvas, 0, 0, scaledCanvas.width, scaledCanvas.height);
                    canvas = scaledCanvas;
                    console.log(`[Compression] Scaled dimensions to ${canvas.width}x${canvas.height}`);
                }

                let quality = 0.9;
                let croppedImageData = canvas.toDataURL('image/jpeg', quality);

                // Target: ~1.2MB (Approx 1,600,000 chars in Base64)
                const MAX_BASE64_SIZE = 1600000;

                if (croppedImageData.length > MAX_BASE64_SIZE) {
                    console.log(`[Compression] Initial size ${Math.round(croppedImageData.length / 1024)}KB. Iterating...`);
                    while (croppedImageData.length > MAX_BASE64_SIZE && quality > 0.4) {
                        quality -= 0.1;
                        croppedImageData = canvas.toDataURL('image/jpeg', quality);
                        console.log(`[Compression] Quality: ${quality.toFixed(1)} | Size: ${Math.round(croppedImageData.length / 1024)}KB`);
                    }
                }

                const trialId = state.currentTrialIdForCamera;
                const currentCameraMode = state.cameraMode;
                closeCropper();

                const form = document.getElementById('trial-form');
                let photoDate = form ? form.querySelector('#photo-date').value : new Date().toISOString().split('T')[0];

                let weatherData = state.tempPhotoWeather || null;
                if (!weatherData && trialId) {
                    try {
                        const trial = state.trials.find(t => t.ID === trialId);
                        let locStr = trial ? (trial.Location || '') : '';
                        let lat, lon;
                        if (locStr.includes(',')) [lat, lon] = locStr.split(',').map(s => s.trim());

                        if (!lat || !lon) {
                            const pos = await new Promise(resolve => {
                                if (navigator.geolocation) {
                                    navigator.geolocation.getCurrentPosition(
                                        p => resolve({ lat: p.coords.latitude, lon: p.coords.longitude }),
                                        () => resolve(null),
                                        { timeout: 3000 }
                                    );
                                } else resolve(null);
                            });
                            if (pos) { lat = pos.lat; lon = pos.lon; }
                        }

                        if (lat && lon) {
                            showToast('Fetching weather for photo...', 'info');
                            weatherData = await fetchWeather(lat, lon, photoDate);
                        }
                    } catch (e) { console.warn("Auto-weather fetch failed during save:", e); }
                }

                const photoData = {
                    fileData: croppedImageData,
                    fileName: `cropped_${Date.now()}.jpg`,
                    mimeType: 'image/jpeg',
                    label: '',
                    date: photoDate,
                    weather: weatherData,
                    tempId: `photo_${Date.now()}`
                };

                if (trialId) {
                    const syncItem = {
                        id: `sync_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
                        trialId: trialId,
                        photo: photoData,
                        type: currentCameraMode === 'weed' ? 'weed_upload' : 'general_upload',
                        status: 'pending',
                        attempts: 0,
                        lastError: null
                    };

                    state.syncQueue.push(syncItem);
                    saveSyncQueue();

                    const trial = state.trials.find(t => t.ID === trialId);
                    if (trial) {
                        if (currentCameraMode === 'weed') {
                            const weedPhotos = safeJsonParse(trial.WeedPhotosJSON);
                            weedPhotos.push({ url: '', tempId: syncItem.photo.tempId, fileData: syncItem.photo.fileData, date: syncItem.photo.date, identifications: null, label: "Processing..." });
                            trial.WeedPhotosJSON = JSON.stringify(weedPhotos);
                        } else {
                            const generalPhotos = safeJsonParse(trial.PhotoURLs);
                            generalPhotos.push({ url: '', tempId: syncItem.photo.tempId, fileData: syncItem.photo.fileData, date: syncItem.photo.date, label: "Processing...", weather: weatherData });
                            trial.PhotoURLs = JSON.stringify(generalPhotos);
                        }
                    }

                    if (document.getElementById('weed-modal') && currentCameraMode === 'weed') {
                        const trialData = state.trials.find(t => t.ID === trialId);
                        document.getElementById('weed-photo-grid').innerHTML = safeJsonParse(trialData.WeedPhotosJSON).map((p, i) => render.weedPhotoCard(p, trialId, i)).join('');
                    } else applyFilters();

                    processSyncQueue();
                } else {
                    state.croppedPhotosData.push(photoData);
                    updatePhotoPreview();
                }
                state.cameraMode = 'general';
            }

            async function openCamera(trialId = null) {
                state.currentTrialIdForCamera = trialId;
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) return showToast("Camera not supported on this browser.", "error");
                try {
                    cameraStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
                    videoElement.srcObject = cameraStream;
                    cameraModal.classList.remove('hidden');
                    cameraModal.style.display = 'flex'; // FORCE FLEX for centering
                } catch (err) {
                    console.error("Camera Error:", err);
                    showToast("Could not access camera. Check browser permissions.", 'error');
                    state.currentTrialIdForCamera = null;
                }
            }

            function closeCamera() {
                if (cameraStream) { cameraStream.getTracks().forEach(track => track.stop()); }
                cameraModal.style.display = 'none';
            }

            function capturePhoto() {
                canvasElement.width = videoElement.videoWidth;
                canvasElement.height = videoElement.videoHeight;
                canvasElement.getContext('2d').drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);
                closeCamera();
                openCropper(canvasElement.toDataURL('image/jpeg', 1.0), state.currentTrialIdForCamera);
            }

            function updatePhotoPreview() {
                const previewContainer = document.getElementById('photo-preview'); if (!previewContainer) return;
                previewContainer.innerHTML = state.croppedPhotosData.map((data, index) => {
                    const imgSrc = data.fileData || data.url;
                    if (!imgSrc) return '';
                    const displaySrc = imgSrc.startsWith('data:image') ? imgSrc : `https://images.weserv.nl/?url=${encodeURIComponent(imgSrc)}&w=100&h=100&fit=crop`;

                    const task = state.backgroundQueue.get(data.tempId);
                    let statusIndicator = '';
                    if (task) {
                        if (task.status === 'processing') statusIndicator = `<div class="absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center text-white text-xs animate-pulse">Analyzing...</div>`;
                        if (task.status === 'error') statusIndicator = `<div class="absolute inset-0 bg-red-500 bg-opacity-70 flex items-center justify-center text-white text-xs font-bold">Failed</div>`;
                    }

                    return `<div class="relative group">
                        <img src="${displaySrc}" class="h-24 w-24 object-cover rounded-md border">
                        <input type="text" data-index="${index}" class="photo-label-input absolute bottom-0 left-0 w-full text-xs p-1 bg-black bg-opacity-50 text-white" placeholder="Label..." value="${sanitizeHTML(data.label) || ''}">
                        <button data-action="remove-photo" data-index="${index}" class="absolute top-0 right-0 bg-red-500 text-white rounded-full h-5 w-5 flex items-center justify-center text-xs font-bold opacity-0 group-hover:opacity-100 transition-opacity">&times;</button>
                        ${statusIndicator}
                    </div>`;
                }).join('');
            }

            // --- QR CODE LOGIC ---
            function openQrLabel(trialId) {
                const trial = state.trials.find(t => t.ID === trialId);
                if (!trial) return;
                openModal('qrLabel', false, { trial });
                setTimeout(() => {
                    new QRCode(document.getElementById("qr-code-canvas"), {
                        text: trial.ID,
                        width: 200,
                        height: 200,
                        colorDark: "#000000",
                        colorLight: "#ffffff",
                        correctLevel: QRCode.CorrectLevel.H
                    });
                }, 50);
            }

            async function openQrScanner() {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    return showToast("Camera not supported on this browser.", "error");
                }
                try {
                    qrScannerModal.classList.remove('hidden');
                    qrStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
                    qrVideo.srcObject = qrStream;
                    startPlotScanning();
                } catch (err) {
                    console.error("QR Scanner Camera Error:", err);
                    showToast("Could not access camera for scanning.", 'error');
                    qrScannerModal.classList.add('hidden');
                }
            }

            function closeQrScanner() {
                if (qrStream) { qrStream.getTracks().forEach(track => track.stop()); }
                if (qrAnimationFrame) cancelAnimationFrame(qrAnimationFrame);
                qrScannerModal.classList.add('hidden');
            }

            function startPlotScanning() {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');

                const scanLoop = () => {
                    if (qrVideo.readyState === qrVideo.HAVE_ENOUGH_DATA) {
                        canvas.height = qrVideo.videoHeight;
                        canvas.width = qrVideo.videoWidth;
                        context.drawImage(qrVideo, 0, 0, canvas.width, canvas.height);
                        const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
                        const code = jsQR(imageData.data, imageData.width, imageData.height, {
                            inversionAttempts: "dontInvert",
                        });

                        if (code) {
                            const detectedId = code.data;
                            const trial = state.trials.find(t => t.ID === detectedId);
                            if (trial) {
                                showToast(`Plot recognized: ${trial.FormulationName}`, 'success');
                                closeQrScanner();
                                openTrialDetail(trial.ID);
                                return;
                            }
                        }
                    }
                    qrAnimationFrame = requestAnimationFrame(scanLoop);
                };
                qrAnimationFrame = requestAnimationFrame(scanLoop);
            }

            // --- SPECIFIC FEATURE LOGIC (FORMULATIONS, TRIALS, AI, ETC.) ---
            function addFormulationIngredientRow(ingredient = null) {
                const container = document.getElementById('formulation-ingredients-container'); if (!container) return;
                const opts = state.ingredients.map(ing => `<option value="${ing.ID}">${sanitizeHTML(ing.Name)}</option>`).join('');
                const row = document.createElement('div'); row.className = 'flex items-center space-x-2 formulation-ingredient-row';
                row.innerHTML = `<select class="ingredient-selector flex-grow p-2 border rounded-md bg-white form-input"><option value="">Select ingredient</option>${opts}</select><input type="number" step="any" class="ingredient-quantity w-24 p-2 border rounded-md form-input" placeholder="Qty"><select class="ingredient-unit-selector w-20 p-2 border rounded-md bg-white form-input"><option>ml</option><option>L</option><option>gm</option><option>kg</option></select><button type="button" data-action="remove-ingredient-row" class="text-red-500 font-bold">&times;</button>`;
                container.appendChild(row);
                if (ingredient) { row.querySelector('.ingredient-selector').value = ingredient.id; row.querySelector('.ingredient-quantity').value = ingredient.quantity; row.querySelector('.ingredient-unit-selector').value = ingredient.unit; }
            }

            function updateFormulationCost() {
                const ingredients = [...document.querySelectorAll('.formulation-ingredient-row')].map(r => { const selector = r.querySelector('.ingredient-selector'); if (!selector || selector.value === "") return null; return { id: selector.value, quantity: r.querySelector('.ingredient-quantity').value, unit: r.querySelector('.ingredient-unit-selector').value }; }).filter(Boolean);
                document.getElementById('formulation-total-cost').textContent = `${CURRENCY_SYMBOL}${calculateFormulationCost(ingredients).toFixed(2)}`;
            }

            function calculateFormulationCost(ingredients) {
                if (!ingredients || !state.ingredients) return 0;
                return ingredients.reduce((acc, currentIng) => {
                    const details = state.ingredients.find(i => i.ID === currentIng.id);
                    if (!details) return acc;
                    const baseCost = parseFloat(details.Cost);
                    const baseUnit = details.Unit.toLowerCase();
                    let usedQuantity = parseFloat(currentIng.quantity) || 0;
                    const usedUnit = currentIng.unit.toLowerCase();
                    if (isNaN(baseCost) || isNaN(usedQuantity)) return acc;
                    let quantityInBaseUnit = usedQuantity;
                    if (baseUnit === 'l' && usedUnit === 'ml') quantityInBaseUnit /= 1000;
                    else if (baseUnit === 'ml' && usedUnit === 'l') quantityInBaseUnit *= 1000;
                    else if (baseUnit === 'kg' && usedUnit === 'gm') quantityInBaseUnit /= 1000;
                    else if (baseUnit === 'gm' && usedUnit === 'kg') quantityInBaseUnit *= 1000;
                    return acc + (baseCost * quantityInBaseUnit);
                }, 0);
            }

            // --- STATISTICAL ENGINE ---
            // --- STATISTICAL ENGINE ---
            function pow(n) { return n * n; }

            function calculateVPD(temp, humidity) {
                if (temp == null || humidity == null) return null;
                const t = parseFloat(temp);
                const rh = parseFloat(humidity);
                if (isNaN(t) || isNaN(rh)) return null;
                const es = 0.61078 * Math.exp(17.27 * t / (t + 237.3));
                const ea = es * rh / 100;
                return (es - ea).toFixed(3);
            }

            // --- ROBUST STATISTICAL ANALYSIS ENGINE (RCBD) ---
            function calculateRCBD_Stats(project, trials, blocks) {
                // 1. Group Data by Assessment Timing (DAA - Days After Application)
                const timePoints = {};

                const treatmentIds = [...new Set(trials.map(t => t.FormulationID))];
                const blockIds = [...new Set(blocks.map(b => b.ID))];

                trials.forEach(trial => {
                    const efficacy = safeJsonParse(trial.EfficacyDataJSON);
                    const lastObs = efficacy.sort((a, b) => b.daa - a.daa)[0]; // Get FINAL observation

                    if (lastObs) {
                        // Heuristic: If Project Metric is "Phytotoxicity", use 'phyto'. Else use 'cover' of first weed.
                        let value = null;
                        if (project.Metric && project.Metric.toLowerCase().includes('phyto')) {
                            value = parseFloat(lastObs.phyto);
                        } else {
                            if (lastObs.weedDetails && lastObs.weedDetails.length > 0) {
                                value = parseFloat(lastObs.weedDetails[0].cover);
                            }
                        }

                        if (value != null && !isNaN(value)) {
                            const daa = lastObs.daa;
                            const tId = trial.FormulationID;
                            const bId = trial.BlockID;

                            if (!timePoints[daa]) timePoints[daa] = [];
                            timePoints[daa].push({ tId, bId, value });
                        }
                    }
                });

                const results = {};

                // 2. Process each Timepoint
                Object.keys(timePoints).forEach(daa => {
                    const data = timePoints[daa];
                    const treatmentGroups = {};

                    data.forEach(d => {
                        if (!treatmentGroups[d.tId]) treatmentGroups[d.tId] = [];
                        treatmentGroups[d.tId].push(d.value);
                    });

                    // A. Descriptive Stats
                    const treatmentStats = Object.keys(treatmentGroups).map(tId => {
                        const vals = treatmentGroups[tId];
                        const n = vals.length;
                        const mean = vals.reduce((a, b) => a + b, 0) / n;
                        const variance = vals.reduce((a, b) => a + pow(b - mean), 0) / (n - 1 || 1);
                        const sd = Math.sqrt(variance);
                        // CV Calculation
                        const cv = mean !== 0 ? (sd / mean) * 100 : 0;

                        return { treatmentId: tId, mean, sd, cv, n };
                    });

                    // B. ANOVA (RCBD)
                    const grandTotal = data.reduce((a, b) => a + b.value, 0);
                    const N = data.length;
                    const CF = (grandTotal * grandTotal) / N;

                    const totalSS = data.reduce((a, b) => a + (b.value * b.value), 0) - CF;

                    let trSS = 0;
                    treatmentIds.forEach(tId => {
                        const sum = data.filter(d => d.tId === tId).reduce((a, b) => a + b.value, 0);
                        const n = data.filter(d => d.tId === tId).length;
                        if (n > 0) trSS += (sum * sum) / n;
                    });
                    trSS -= CF;

                    let blSS = 0;
                    blockIds.forEach(bId => {
                        const sum = data.filter(d => d.bId === bId).reduce((a, b) => a + b.value, 0);
                        const n = data.filter(d => d.bId === bId).length;
                        if (n > 0) blSS += (sum * sum) / n;
                    });
                    blSS -= CF;

                    const errSS = totalSS - trSS - blSS;

                    const trDF = treatmentIds.length - 1;
                    const blDF = blockIds.length - 1;
                    const errDF = (treatmentIds.length - 1) * (blockIds.length - 1);
                    const totalDF = N - 1;

                    const trMS = trSS / trDF;
                    const blMS = blSS / blDF;
                    const errMS = errSS / errDF;

                    const trF = trMS / errMS;
                    const blF = blMS / errMS;

                    // P Values (Approximation/jStat)
                    const trSig = (typeof jStat !== 'undefined') ? (1 - jStat.centralF.cdf(trF, trDF, errDF)).toFixed(4) : (trF > 4.0 ? '<0.05' : 'NS');
                    const blSig = (typeof jStat !== 'undefined') ? (1 - jStat.centralF.cdf(blF, blDF, errDF)).toFixed(4) : 'NS';

                    // C. LSD & Grouping
                    const tVal = (typeof jStat !== 'undefined') ? jStat.studentt.inv(0.975, errDF) : 2.05;
                    const reps = blockIds.length;
                    const lsd = tVal * Math.sqrt((2 * errMS) / reps);

                    // Grouping Logic (Descending Order = High Values First)
                    // If metric is 'Cover %', low is better. If 'Control %', high is better.
                    // We assume input data is 'Cover %' (raw data).
                    // We sort Ascending (Lower is better = 'a')? 
                    // Standard practice: 'a' goes to the best treatment.
                    // If best is Lowest Cover, we sort Ascending.
                    treatmentStats.sort((a, b) => a.mean - b.mean); // Ascending (Lowest (Best) first)

                    // Simple "Significantly Different from Best" Logic for now
                    const bestMean = treatmentStats[0].mean;
                    treatmentStats.forEach(ts => {
                        // Calculate WCE (Weed Control Efficiency) assuming Control Mean is highest
                        // Find potential control (highest mean?)
                        const worstMean = treatmentStats[treatmentStats.length - 1].mean;
                        // WCE relative to worst (Untreated)?
                        // WCE = (Untreated - Treated) / Untreated * 100
                        ts.wce = worstMean > 0 ? ((worstMean - ts.mean) / worstMean * 100) : 0;

                        if (Math.abs(ts.mean - bestMean) <= lsd) {
                            ts.rank = 'Superior (a)';
                        } else {
                            ts.rank = 'Inferior (b)'; // Simplistic, needs full permutation
                        }
                    });

                    results[daa] = {
                        isPartial: N < (treatmentIds.length * blockIds.length),
                        f: trF,
                        lsd: lsd,
                        ms: { error: errMS, treatment: trMS },
                        df: { error: errDF, treatment: trDF },
                        anovaTable: {
                            treatment: { df: trDF, ss: trSS, ms: trMS, f: trF, sig: trSig },
                            block: { df: blDF, ss: blSS, ms: blMS, f: blF, sig: blSig },
                            error: { df: errDF, ss: errSS, ms: errMS },
                            total: { df: totalDF, ss: totalSS }
                        },
                        treatmentStats
                    };
                });
                return results;
            }

            async function runProjectAnalysis(projectId) {
                const project = state.projects.find(p => p.ID === projectId);
                if (!project) return;

                project.isAnalyzing = true; // Ensure set here too if called manually

                showToast('Running Statistical Analysis...', 'info');

                const blocks = state.blocks.filter(b => b.ProjectID === projectId);
                const trials = state.trials.filter(t => t.ProjectID === projectId);

                if (blocks.length === 0 || trials.length === 0) {
                    showToast('Not enough data to analyze.', 'warning');
                    project.isAnalyzing = false;
                    return;
                }

                try {
                    // 1. Calculate Stats
                    const stats = calculateRCBD_Stats(project, trials, blocks);

                    console.log('[Analysis] Calculated stats:', stats);

                    // 2. Save Results (CRITICAL: Must stringify for Google Sheets!)
                    project.AnalysisResults = stats;
                    const analysisResultsJSON = JSON.stringify(stats);

                    console.log('[Analysis] Saving to backend...');
                    console.log('[Analysis] Project ID:', projectId);
                    console.log('[Analysis] JSON length:', analysisResultsJSON.length);

                    const saveResult = await apiCall('updateProject', {
                        ID: projectId,
                        AnalysisResultsJSON: analysisResultsJSON
                    }, false);

                    console.log('[Analysis] Save result:', saveResult);

                    if (!saveResult || (!saveResult.success && saveResult.success !== undefined) || saveResult._errType) {
                        console.error('[Analysis] SAVE FAILED! Backend returned:', saveResult);
                        showToast('Save Failed: ' + (saveResult.message || 'Unknown Server Error'), 'error');
                    }

                    // 3. Update Dashboard if visible
                    if (state.currentPage === 'projectDashboard' && state.activeProjectId === projectId) {
                        // Note: Calling render.projectDashboard here might be redundant if this was auto-triggered,
                        // BUT it is necessary to refresh the UI with the results!
                        // Since we set isAnalyzing=false afterwards, the loop condition (!results) will false, so no loop.
                        try {
                            render.projectDashboard();
                        } catch (e) { console.error("Dashboard render failed", e); }
                    }

                    showToast('Analysis Complete.', 'success');
                } catch (err) {
                    console.error("Analysis Failed:", err);
                    showToast('Analysis encountered an error.', 'error');
                } finally {
                    project.isAnalyzing = false;
                }
            }

            function renderProjectAnalysisCharts(project) {
                const results = project.AnalysisResults;
                if (!results) return;

                // Get latest DAA key
                const daas = Object.keys(results).sort((a, b) => b - a);
                if (daas.length === 0) return;

                const daa = daas[0];
                const res = results[daa];

                // 1. Bar Chart: Means + SD
                const ctxPerf = document.getElementById('project-performance-chart');
                if (ctxPerf) {
                    // Destroy existing
                    const chartInstance = Chart.getChart(ctxPerf);
                    if (chartInstance) chartInstance.destroy();

                    const labels = res.treatmentStats.map(ts => {
                        const f = state.formulations.find(form => form.ID === ts.treatmentId);
                        return truncateText(f ? f.Name : 'Unknown', 15);
                    });

                    new Chart(ctxPerf, {
                        type: 'bar',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: `Mean ${project.Metric} (${daa} DAA)`,
                                data: res.treatmentStats.map(ts => ts.mean),
                                backgroundColor: res.treatmentStats.map((_, i) => ['#0d9488', '#d97706', '#2563eb'][i % 3]),
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: { legend: { display: false } },
                            scales: { y: { beginAtZero: true, title: { display: true, text: `Mean ${project.Metric}` } } }
                        }
                    });
                }

                // 2. Line Chart: WCE over time
                const ctxWce = document.getElementById('project-wce-chart');
                if (ctxWce && daas.length > 0) {
                    const chartInstance = Chart.getChart(ctxWce);
                    if (chartInstance) chartInstance.destroy();

                    const tIds = [...new Set(daas.flatMap(d => results[d].treatmentStats.map(ts => ts.treatmentId)))];

                    const datasets = tIds.map((tId, i) => {
                        const f = state.formulations.find(form => form.ID === tId);
                        const label = f ? f.Name : 'Unknown';
                        const data = daas.sort((a, b) => a - b).map(d => {
                            const ts = results[d].treatmentStats.find(s => s.treatmentId === tId);
                            return ts ? { x: parseInt(d), y: ts.wce } : null;
                        }).filter(Boolean);

                        const colors = ['#0d9488', '#d97706', '#2563eb', '#dc2626'];
                        return {
                            label: label,
                            data: data,
                            borderColor: colors[i % colors.length],
                            fill: false
                        };
                    });

                    new Chart(ctxWce, {
                        type: 'line',
                        data: { datasets },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: { type: 'linear', title: { display: true, text: 'Days After Application' } },
                                y: { beginAtZero: true, max: 100, title: { display: true, text: 'Weed Control Efficiency (%)' } }
                            }
                        }
                    });
                }
            }



            // --- BACKGROUND PROCESSING & AI ---
            async function analyzePhotoForEfficacy(fileData, mimeType) {
                try {
                    if (!fileData || typeof fileData !== 'string' || !fileData.includes(',')) {
                        throw new Error("Invalid image data provided for analysis.");
                    }
                    const prompt = `As an agricultural expert analyzing a photo from a herbicide trial, provide your best estimate for the following metrics. For weedStatus, identify up to 2 dominant weed species visible and describe their status. Respond ONLY with a single minified JSON object in this exact format: {"percentPhytotoxicity": NUMBER, "weedDetails": [{"species": "...", "cover": NUMBER, "status": "Controlled|Burndown|Re-emerged|Resistant|Unaffected", "notes": "..."}]}.
                    - "percentPhytotoxicity": Estimate the visible damage (discoloration, necrosis, wilting) to the weeds as a percentage (0-100).
                    - "weedDetails": An array of objects.
                    - "species": The scientific or common name of the weed.
                    - "cover": Estimate the percentage of the ground covered by this specific weed species (0-100).
                    - "status": The observed condition of the weed.
                    - "notes": A brief qualitative observation.`;

                    const geminiCall = (genAI) => genAI.models.generateContent({
                        model: state.settings.apiModel || 'gemini-2.0-flash-exp',
                        contents: [{ parts: [{ text: prompt }, { inlineData: { mimeType: mimeType, data: fileData.split(',')[1] } }] }],
                        config: {
                            responseMimeType: "application/json",
                            responseSchema: {
                                type: Type.OBJECT,
                                properties: {
                                    percentPhytotoxicity: { type: Type.NUMBER },
                                    weedDetails: {
                                        type: Type.ARRAY,
                                        items: {
                                            type: Type.OBJECT,
                                            properties: {
                                                species: { type: Type.STRING },
                                                cover: { type: Type.NUMBER },
                                                status: { type: Type.STRING },
                                                notes: { type: Type.STRING }
                                            },
                                            required: ["species", "cover", "status", "notes"]
                                        }
                                    }
                                },
                                required: ["percentPhytotoxicity", "weedDetails"]
                            }
                        }
                    });

                    const response = await callGeminiApi('Analyzing photo for efficacy', geminiCall);
                    const parsed = JSON.parse(response.text);
                    return {
                        phyto: parsed.percentPhytotoxicity || 0,
                        weedDetails: parsed.weedDetails || []
                    };
                } catch (error) {
                    console.error('Efficacy analysis via Gemini failed:', error);
                    if (error.message === 'ALL_KEYS_EXHAUSTED' || error.message.includes('quota')) {
                        throw new Error('QUOTA_EXCEEDED');
                    }
                    showToast(`Efficacy analysis failed: ${error.message}`, 'error');
                    return null;
                }
            }

            async function identifyWeedsFromPhoto(fileData, mimeType) {
                try {
                    if (!fileData || typeof fileData !== 'string' || !fileData.includes(',')) {
                        throw new Error("Invalid image data provided for identification.");
                    }
                    const prompt = `You are an expert botanist specializing in weed identification for agriculture. Analyze this photo and identify ALL visible weed species. For EACH different weed species you can see:
1. Provide the scientific name
2. List common names
3. Give a confidence score (0-1) for your identification
4. Categorize the growth stage

IMPORTANT: Identify EVERY distinct weed species visible in the photo, not just the most prominent one. List them all in the identifications array.

Respond ONLY with a single minified JSON object in this format: {"identifications": [{"name": "Scientific Name", "commonNames": ["Common Name 1", ...], "confidence": 0.95, "growthStage": "Seedling|Vegetative|Flowering|Mature"}]}`;

                    const geminiCall = (genAI) => genAI.models.generateContent({
                        model: state.settings.apiModel || 'gemini-2.0-flash-exp',
                        contents: [{ parts: [{ text: prompt }, { inlineData: { mimeType: mimeType, data: fileData.split(',')[1] } }] }],
                        config: {
                            responseMimeType: "application/json",
                            responseSchema: {
                                type: Type.OBJECT,
                                properties: {
                                    identifications: {
                                        type: Type.ARRAY,
                                        items: {
                                            type: Type.OBJECT,
                                            properties: {
                                                name: { type: Type.STRING },
                                                commonNames: { type: Type.ARRAY, items: { type: Type.STRING } },
                                                confidence: { type: Type.NUMBER },
                                                growthStage: { type: Type.STRING }
                                            },
                                            required: ["name", "commonNames", "confidence", "growthStage"]
                                        }
                                    }
                                },
                                required: ["identifications"]
                            }
                        }
                    });

                    const response = await callGeminiApi('Identifying weeds from photo', geminiCall);
                    console.log('Weed identification raw response:', response);

                    // Handle different response formats from the SDK
                    let resultText = '';
                    if (typeof response === 'string') {
                        resultText = response;
                    } else if (response?.text) {
                        resultText = typeof response.text === 'function' ? response.text() : response.text;
                    } else if (response?.candidates?.[0]?.content?.parts?.[0]?.text) {
                        resultText = response.candidates[0].content.parts[0].text;
                    }

                    console.log('Weed identification result text:', resultText);

                    if (!resultText) {
                        console.warn('Empty response from weed identification');
                        return [];
                    }

                    // Clean up the response text
                    const cleanedText = resultText.replace(/```json/g, '').replace(/```/g, '').trim();
                    const parsed = JSON.parse(cleanedText);
                    console.log('Weed identification parsed:', parsed);

                    return parsed.identifications || parsed.results || [];
                } catch (error) {
                    console.error('Weed identification via Gemini failed:', error);
                    showToast(`Weed identification failed: ${error.message}`, 'error');
                    return [];
                }
            }

            async function uploadPhotos(photosData) {

                if (!photosData || photosData.length === 0) return [];
                const results = [];
                for (const photoData of photosData) {
                    try {
                        if (!state.settings.folderId) throw new Error("Folder ID missing. Check Settings.");
                        const result = await apiCall('uploadPhoto', {
                            fileData: photoData.fileData,
                            fileName: photoData.fileName,
                            mimeType: photoData.mimeType
                        }, false);
                        results.push(result);
                    } catch (error) {
                        console.error('Photo upload failed for one photo:', error);
                        results.push(null);
                    }
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
                return results.map((result, index) => {
                    if (!result || !result.url) return null;
                    return {
                        ...photosData[index],
                        url: result.url
                    };
                }).filter(Boolean);
            }

            function handlePhotoEditSubmit(form) {
                const trialId = form.querySelector('[name="trialId"]').value;
                const photoIndex = parseInt(form.querySelector('[name="photoIndex"]').value);
                const trial = state.trials.find(t => t.ID === trialId);
                if (!trial) return;

                const photos = safeJsonParse(trial.PhotoURLs);
                const photo = photos[photoIndex];
                if (photo) {
                    // Extract values with trimming to ensure cleanliness
                    const newLabel = (form.querySelector('[name="label"]').value || '').trim();
                    const newDate = form.querySelector('[name="date"]').value;
                    const wTemp = (form.querySelector('[name="temp"]').value || '').trim();
                    const wHum = (form.querySelector('[name="humidity"]').value || '').trim();
                    const wWind = (form.querySelector('[name="wind"]').value || '').trim();
                    const wRain = (form.querySelector('[name="rain"]').value || '').trim();

                    // Update local state immediately
                    photo.label = newLabel;
                    photo.date = newDate;

                    // Explicitly update weather object
                    photo.weather = {
                        temp: wTemp,
                        humidity: wHum,
                        wind: wWind,
                        rain: wRain
                    };

                    trial.PhotoURLs = JSON.stringify(photos);

                    // Optimistic UI Update: Close and refresh immediately
                    showToast('Photo details updated.', 'success');
                    closeModal();
                    openTrialDetail(trialId);

                    // Background Sync
                    // We do NOT wait for this to finish before closing UI
                    apiCall('updateTrialRecord', { ID: trialId, PhotoURLs: trial.PhotoURLs }, false)
                        .catch(err => {
                            console.error('Background sync failed:', err);
                            showToast('Warning: Changes saved locally but sync failed. Please check connection.', 'warning');
                        });
                }
            }

            function handleOpenPhotoEditModal(trialId, photoIndex) {
                const trial = state.trials.find(t => t.ID === trialId);
                if (!trial) return;

                const photos = safeJsonParse(trial.PhotoURLs);
                const photo = photos[photoIndex];
                if (!photo) return;

                openModal('photoEdit', true);

                // Defer population slightly to ensure DOM is ready
                setTimeout(() => {
                    const form = document.getElementById('photo-edit-form');
                    if (!form) return;

                    form.querySelector('[name="trialId"]').value = trialId;
                    form.querySelector('[name="photoIndex"]').value = String(photoIndex);
                    form.querySelector('[name="label"]').value = photo.label || '';

                    if (photo.date) {
                        form.querySelector('[name="date"]').value = new Date(photo.date).toISOString().split('T')[0];
                    }

                    if (photo.weather) {
                        form.querySelector('[name="temp"]').value = photo.weather.temp || '';
                        form.querySelector('[name="humidity"]').value = photo.weather.humidity || '';
                        form.querySelector('[name="wind"]').value = photo.weather.wind || '';
                        form.querySelector('[name="rain"]').value = photo.weather.rain || '';
                    }

                    // Add listener for date change in edit modal
                    const dateInput = form.querySelector('[name="date"]');
                    dateInput.addEventListener('change', async () => {
                        const newDate = dateInput.value;
                        if (!newDate) return;

                        // Try to get location from trial
                        const locationStr = trial.Location || '';
                        let lat, lon;
                        if (locationStr.includes(',')) {
                            [lat, lon] = locationStr.split(',').map(s => s.trim());
                        }

                        if (lat && lon) {
                            showToast('Fetching weather for new date...', 'info');
                            const w = await fetchWeather(lat, lon, newDate);
                            if (w) {
                                form.querySelector('[name="temp"]').value = w.temp || '';
                                form.querySelector('[name="humidity"]').value = w.humidity || '';
                                form.querySelector('[name="wind"]').value = w.wind || '';
                                form.querySelector('[name="rain"]').value = w.rain || '';
                                showToast('Weather updated.', 'success');
                            }
                        } else {
                            showToast('Trial has no location. Cannot fetch weather.', 'warning');
                        }
                    });
                }, 50);
            }

            async function processAndAddPhotoObservation(trialId, photosData) {
                console.log('processAndAddPhotoObservation called with:', { trialId, cameraMode: state.cameraMode, photoCount: photosData.length });
                const trialIndex = state.trials.findIndex(t => t.ID === trialId);
                if (trialIndex === -1) return showToast('Error: Could not find the trial.', 'error');

                showToast(`Uploading ${photosData.length} photo(s)...`, 'info');
                const successfulUploads = await uploadPhotos(photosData);
                console.log('Successful uploads:', successfulUploads.length);

                if (successfulUploads.length > 0) {
                    const trial = state.trials[trialIndex];
                    const payload = {};

                    console.log('Camera mode check:', state.cameraMode, state.cameraMode === 'weed' ? 'WEED MODE' : 'GENERAL MODE');
                    if (state.cameraMode === 'weed') {
                        // --- WEED IDENTIFICATION MODE ---
                        console.log('Entering WEED identification mode');
                        let weedPhotos = safeJsonParse(trial.WeedPhotosJSON);
                        const newWeedSpecies = new Set(); // Collect newly identified species

                        for (const photo of successfulUploads) {
                            try {
                                showToast(`Identifying weeds in photo...`, 'info');
                                const identifications = await identifyWeedsFromPhoto(photo.fileData, photo.mimeType);

                                weedPhotos.push({
                                    url: photo.url,
                                    date: photo.date,
                                    identifications: identifications,
                                    label: photo.label || (identifications.length > 0 ? identifications.map(i => i.name).join(', ') : "Unidentified Weed")
                                });

                                // Collect all newly identified species names
                                if (identifications.length > 0) {
                                    identifications.forEach(id => {
                                        if (id.name && id.name.trim()) {
                                            newWeedSpecies.add(id.name.trim());
                                        }
                                        // Also add common names
                                        if (id.commonNames && id.commonNames.length > 0) {
                                            id.commonNames.forEach(cn => {
                                                if (cn && cn.trim()) newWeedSpecies.add(cn.trim());
                                            });
                                        }
                                    });
                                }
                            } catch (err) {
                                console.error("Weed identification failed:", err);
                                weedPhotos.push({
                                    url: photo.url,
                                    date: photo.date,
                                    identifications: [],
                                    label: "Unidentified Weed"
                                });
                            }
                        }
                        payload.WeedPhotosJSON = JSON.stringify(weedPhotos);

                        // Update WeedSpecies field - merge new species with existing (no duplicates)
                        const existingSpecies = (trial.WeedSpecies || '').split(',').map(s => s.trim()).filter(Boolean);
                        const allSpecies = [...new Set([...existingSpecies, ...newWeedSpecies])];
                        if (allSpecies.length > 0) {
                            payload.WeedSpecies = allSpecies.join(', ');
                        }
                    } else {
                        // --- GENERAL EFFICACY MODE ---
                        let currentPhotos = safeJsonParse(trial.PhotoURLs);
                        successfulUploads.forEach(p => currentPhotos.push({ url: p.url, label: p.label, date: p.date, weather: p.weather }));
                        payload.PhotoURLs = JSON.stringify(currentPhotos);

                        // Only auto-analyze if enabled in settings (saves API quota)
                        if (state.settings.autoAnalyzePhotos) {
                            showToast(`Photos added. Analyzing ${successfulUploads.length} photo(s) for efficacy data...`, 'info');

                            let efficacyData = safeJsonParse(trial.EfficacyDataJSON);
                            let aiAnalysisComplete = false;

                            for (const photo of successfulUploads) {
                                try {
                                    const efficacyResult = await analyzePhotoForEfficacy(photo.fileData, photo.mimeType);
                                    if (efficacyResult) {
                                        const observationDate = new Date(photo.date);
                                        const trialDate = new Date(trial.Date);
                                        const daaValue = Math.round((observationDate.getTime() - trialDate.getTime()) / (1000 * 60 * 60 * 24));
                                        const daa = daaValue >= 0 ? daaValue : 0;

                                        efficacyData.push({
                                            date: observationDate.toISOString().split('T')[0],
                                            daa,
                                            phyto: efficacyResult.phyto,
                                            notes: `AI analysis from photo taken on ${observationDate.toLocaleDateString()}`,
                                            photoUrl: photo.url,
                                            weedDetails: efficacyResult.weedDetails,
                                        });
                                        aiAnalysisComplete = true;
                                    }
                                } catch (err) {
                                    showToast(`AI analysis failed for one photo: ${err.message}`, 'error');
                                    if (err.message === 'QUOTA_EXCEEDED') {
                                        showToast('API Quota limit reached. Halting analysis for remaining photos.', 'error');
                                        break;
                                    }
                                }
                            }

                            if (aiAnalysisComplete) {
                                payload.EfficacyDataJSON = JSON.stringify(efficacyData);
                                payload.AISummariesJSON = '{}';
                            }
                        } else {
                            showToast('Photos added. Enable "Auto-Analyze Photos" in Settings for AI efficacy analysis.', 'success');
                        }
                    }

                    const result = await apiCall('updateTrialRecord', { ID: trialId, ...payload }, false);

                    // Handle both response formats: {record: {...}} or direct record {...}
                    const updatedRecord = result?.record || (result?.ID ? result : null);
                    if (updatedRecord) {
                        const updatedTrialIndex = state.trials.findIndex(t => t.ID === trialId);
                        if (updatedTrialIndex > -1) state.trials[updatedTrialIndex] = updatedRecord;

                        if (state.cameraMode === 'weed') {
                            showToast('Weed identification photos saved.', 'success');
                        } else if (payload.EfficacyDataJSON) {
                            showToast('Efficacy data updated. AI summary will be regenerated.', 'success');
                        } else {
                            showToast('Photos saved.', 'success');
                        }

                        applyFilters();
                        if (document.querySelector(`#trial-detail-modal`)) {
                            openTrialDetail(trialId);
                        }
                    } else {
                        console.error('updateTrialRecord response:', result);
                        throw new Error('Failed to save updated trial data to the server. Check console for details.');
                    }
                }
                applyFilters();
            }


            function injectSyncPlaceholders() {
                if (!state.syncQueue || state.syncQueue.length === 0) return;
                state.syncQueue.forEach(item => {
                    const trial = state.trials.find(t => t.ID === item.trialId);
                    if (trial) {
                        const isWeed = item.type === 'weed_upload';
                        let photos = isWeed ? safeJsonParse(trial.WeedPhotosJSON) : safeJsonParse(trial.PhotoURLs);

                        // Check if already in state
                        const exists = photos.some(p => p.tempId === item.photo.tempId);
                        if (!exists) {
                            const placeholder = {
                                url: '',
                                tempId: item.photo.tempId,
                                fileData: item.photo.fileData,
                                date: item.photo.date,
                                label: "Processing..."
                            };
                            if (isWeed) {
                                placeholder.identifications = null;
                            } else {
                                placeholder.weather = item.photo.weather || null;
                            }
                            photos.push(placeholder);
                            if (isWeed) trial.WeedPhotosJSON = JSON.stringify(photos);
                            else trial.PhotoURLs = JSON.stringify(photos);
                        }
                    }
                });
            }


            // --- INITIALIZATION ---
            async function initializeApp(showOverlay = true) {
                // --- RESTORE SYNC QUEUE ---
                try {
                    const savedQueue = localStorage.getItem('herbicide_sync_queue');
                    if (savedQueue) {
                        state.syncQueue = JSON.parse(savedQueue);
                        // Reset any 'uploading' or 'processing' states to 'pending' as we are starting fresh
                        state.syncQueue.forEach(s => {
                            if (s.status === 'uploading' || s.status === 'processing') s.status = 'pending';
                        });
                        console.log(`Restored ${state.syncQueue.length} items to sync queue.`);
                        if (navigator.onLine && state.syncQueue.length > 0) {
                            setTimeout(processSyncQueue, 3000); // 3-second delay to ensure connectivity
                        }
                    }
                } catch (e) {
                    console.error("Failed to restore sync queue", e);
                }
                if (window.__EMBEDDED_STATE__) {
                    state = window.__EMBEDDED_STATE__;
                    showToast('Loaded data from standalone file.', 'success');
                    switchPage(state.currentPage || 'dashboard');
                    window.apiCall = async (action, payload) => {
                        console.log('API calls disabled in standalone mode.', { action, payload });
                        showToast('Functionality limited in offline mode.', 'error');
                        return null;
                    }
                    return;
                }

                if (showOverlay) loadingOverlay.classList.remove('hidden');
                try {
                    loadSettings();
                    if (!state.settings.scriptUrl) {
                        mainContent.innerHTML = `<div class="text-center p-8 bg-white rounded-lg shadow"><p class="text-amber-600 font-semibold">Configuration Needed</p><p class="text-gray-600 mt-2">Please go to Settings to enter your Google Apps Script URL.</p></div>`;
                        switchPage('settings');
                        return;
                    }

                    const allData = await apiCall('getAllData', {}, false);
                    if (allData === null) {
                        mainContent.innerHTML = `<div class="text-center p-8 bg-white rounded-lg shadow"><p class="text-red-500 font-semibold">Could not load app data.</p><p class="text-gray-600 mt-2">Check your connection and Data Source settings. Ensure your script is deployed correctly.</p><div class="mt-4 flex justify-center gap-4"><button onclick="location.reload()" class="bg-blue-600 text-white px-4 py-2 rounded-lg">Retry</button><button onclick="window.switchPageToSettings()" class="bg-gray-600 text-white px-4 py-2 rounded-lg">Go to Settings</button></div></div>`;
                        // Add temporary global helper for the button
                        window.switchPageToSettings = () => { switchPage('settings'); };
                        return;
                    }

                    const normalizeIDs = (arr) => Array.isArray(arr) ? arr.map(item => ({ ...item, ID: String(item.ID || ''), FormulationID: String(item.FormulationID || '') })) : []
                        ;
                    state.ingredients = normalizeIDs(allData.ingredients);
                    state.formulations = normalizeIDs(allData.formulations);

                    // Parse projects and restore AnalysisResults from JSON
                    state.projects = normalizeIDs(allData.projects).map(p => {
                        let analysisResults = {};
                        try {
                            analysisResults = p.AnalysisResultsJSON ? JSON.parse(p.AnalysisResultsJSON) : {};
                        } catch (e) {
                            console.warn('Failed to parse AnalysisResultsJSON for project:', p.ID, e);
                        }
                        return {
                            ...p,
                            AnalysisResults: analysisResults
                        };
                    });

                    state.blocks = normalizeIDs(allData.blocks).map(b => ({ ...b, ReplicationNum: parseInt(b.ReplicationNum) || 0 }));
                    state.trials = (allData.trials || []).map(t => ({
                        ...normalizeIDs([t])[0],
                        WeedPhotosJSON: t.WeedPhotosJSON || '[]',
                        EfficacyDataJSON: t.EfficacyDataJSON || '[]',
                        IsCompleted: t.IsCompleted || false,
                        AISummariesJSON: t.AISummariesJSON || '{}',
                        ProjectID: String(t.ProjectID || ''),
                        BlockID: String(t.BlockID || ''),
                        IsControl: String(t.IsControl).toLowerCase() === 'true',
                        IsStandardCheck: String(t.IsStandardCheck).toLowerCase() === 'true'
                    }));
                    state.organisations = normalizeIDs(allData.organisations);
                    injectSyncPlaceholders();
                    switchPage(state.currentPage || 'dashboard');
                    processSyncQueue();
                } catch (error) {
                    console.error("Initialization failed:", error);
                    mainContent.innerHTML = `<div class="text-center p-8 bg-white rounded-lg shadow"><p class="text-red-500 font-semibold">A critical error occurred.</p><p class="text-gray-600 mt-2">Please check the console and refresh. Error: ${error.message}</p></div>`;
                } finally {
                    if (showOverlay) loadingOverlay.classList.add('hidden');
                    lucide.createIcons();
                }
            }

            function loadSettings() {
                const settingsStr = localStorage.getItem('appSettings');
                const defaultSettings = {
                    apiKeys: [],
                    currentApiKeyIndex: 0,
                    scriptUrl: DEFAULT_SCRIPT_URL,
                    sheetId: DEFAULT_SHEET_ID,
                    folderId: DEFAULT_FOLDER_ID,
                    apiModel: 'gemini-2.0-flash-exp',
                    autoAnalyzePhotos: false,
                    showPhotoDates: false,
                    includeTimeline: false,
                    qrCodeFields: { FormulationName: true, InvestigatorName: true, Date: true, Dosage: true, Location: false, Result: false, WeedSpecies: false, Weather: false },
                    qrOnlineFields: { showInvestigator: true, showDate: true, showLocation: true, showDosage: true, showWeedSpecies: true, showResult: true, showWeather: true, showIngredients: false, showConclusion: true, showPhotos: true }
                };

                if (settingsStr) {
                    const parsed = JSON.parse(settingsStr);
                    // Backwards compatibility for old single key format
                    if (parsed.apiKey && !parsed.apiKeys) {
                        parsed.apiKeys = [parsed.apiKey].filter(Boolean);
                        delete parsed.apiKey;
                    }
                    state.settings = { ...defaultSettings, ...parsed };

                    // FORCE FIX: Reset A6 to ID if found
                    if (state.settings.cardSize === 'A6') {
                        state.settings.cardSize = 'ID';
                        localStorage.setItem('appSettings', JSON.stringify(state.settings));
                    }
                    if (!state.settings.cardSize) state.settings.cardSize = 'ID';

                    if (!Array.isArray(state.settings.apiKeys)) state.settings.apiKeys = [];
                    if (state.settings.currentApiKeyIndex >= state.settings.apiKeys.length) state.settings.currentApiKeyIndex = 0;
                } else {
                    state.settings = defaultSettings;
                    state.settings.cardSize = 'ID';
                }

                const chat = localStorage.getItem('aiChatHistory');
                state.aiChatHistory = chat ? JSON.parse(chat) : [];

                // NOTE: Sync queue is restored in initializeApp() using herbicide_sync_queue key
            }

            async function handleSettingsSave(form) {
                const apiModel = document.getElementById('settings-api-model').value;
                const keyInputs = Array.from(form.querySelectorAll('.api-key-input'));
                const apiKeys = keyInputs.map(input => input.value.trim()).filter(Boolean);

                const scriptUrl = form.querySelector('#script-url').value.trim();
                const sheetIdRaw = form.querySelector('#sheet-url').value.trim();
                const folderIdRaw = form.querySelector('#folder-url').value.trim();

                const sheetId = (sheetIdRaw.match(/[-\w]{25,}/) || [])[0] || state.settings.sheetId;
                const folderId = (folderIdRaw.match(/[-\w]{25,}/) || [])[0] || state.settings.folderId;

                const logoInput = form.querySelector('#settings-logo-hidden');
                const logoBase64 = logoInput ? logoInput.value : state.settings.logoBase64;
                const cardSize = form.querySelector('#settings-card-size').value;

                let needsReload = false;
                if (sheetId && state.settings.sheetId !== sheetId) needsReload = true;
                if (scriptUrl && state.settings.scriptUrl !== scriptUrl) needsReload = true;

                const oldKeyJson = JSON.stringify(state.settings.apiKeys);
                const newKeyJson = JSON.stringify(apiKeys);

                // Update settings object
                const newSettings = {
                    ...state.settings,
                    scriptUrl,
                    sheetId,
                    folderId,
                    logoBase64,
                    cardSize,
                    apiKeys,
                    currentApiKeyIndex: 0,
                    apiModel,
                    autoAnalyzePhotos: document.getElementById('auto-analyze-photos').checked
                };

                // Capture QR fields
                if (newSettings.qrCodeFields) {
                    Object.keys(newSettings.qrCodeFields).forEach(key => {
                        const el = form.querySelector(`[name="qr-${key}"]`);
                        if (el) newSettings.qrCodeFields[key] = el.checked;
                    });
                }
                if (newSettings.qrOnlineFields) {
                    Object.keys(newSettings.qrOnlineFields).forEach(key => {
                        const el = form.querySelector(`[name="qro-${key}"]`);
                        if (el) newSettings.qrOnlineFields[key] = el.checked;
                    });
                }


                state.settings = newSettings;
                localStorage.setItem('appSettings', JSON.stringify(state.settings));

                // CRITICAL: Sync settings to backend so online QR codes reflect current preferences
                try {
                    await apiCall('saveAllSettings', { settings: newSettings });
                    console.log('Settings synced to backend successfully');
                } catch (error) {
                    console.warn('Failed to sync settings to backend:', error);
                    showToast('Settings saved locally, but failed to sync to server. Online QR codes may not reflect changes.', 'warning');
                }

                if (needsReload) {
                    if (confirm('Critical settings changed. Reload app to apply?')) {
                        window.location.reload();
                    }
                } else if (oldKeyJson !== newKeyJson) {
                    showToast('Settings saved. New API keys applied.', 'info');
                } else {
                    showToast('Settings saved successfully.', 'success');
                }

                closeModal();
            }

            async function handleSaveLiveQrSettingsFinal() {
                const form = document.getElementById('live-qr-settings-form');
                if (!form) return;

                const trialId = form.dataset.id;
                if (!trialId) {
                    showToast('Trial ID missing. Cannot save settings.', 'error');
                    return;
                }

                // Collect checkbox states for this individual trial
                const individualSettings = {};
                Object.keys(state.settings.qrOnlineFields).forEach(key => {
                    const checkbox = form.querySelector(`[name="${key}"]`);
                    if (checkbox) {
                        individualSettings[key] = checkbox.checked;
                    }
                });

                // Save to backend
                try {
                    const payload = {
                        id: trialId,
                        LiveQRSettings: JSON.stringify(individualSettings)
                    };

                    await apiCall('saveLiveQrSettings', payload);

                    // Update local state
                    const trialIndex = state.trials.findIndex(t => t.ID === trialId);
                    if (trialIndex !== -1) {
                        state.trials[trialIndex].LiveQRSettings = JSON.stringify(individualSettings);
                    }

                    showToast('Individual QR settings saved for this trial!', 'success');
                    closeModal();
                } catch (error) {
                    console.error('Failed to save live QR settings:', error);
                    showToast('Failed to save QR settings. Please try again.', 'error');
                }
            }

            async function manageBulkAnalysis() {
                if (state.bulkAnalysisState.isRunning && !state.bulkAnalysisState.isPaused) {
                    showToast('An analysis is already in progress.', 'info');
                    return;
                }

                if (!state.bulkAnalysisState.isPaused) {
                    const trialsToProcess = state.trials.filter(trial => {
                        const efficacyData = safeJsonParse(trial.EfficacyDataJSON, []);
                        const summaries = safeJsonParse(trial.AISummariesJSON, {});
                        const photos = safeJsonParse(trial.PhotoURLs, []);

                        const hasEfficacy = efficacyData.length > 0;
                        const hasSummary = Object.keys(summaries).length > 0 && summaries.cover && summaries.phyto;
                        const hasPhotos = photos.length > 0;

                        const needsEfficacyGeneration = hasPhotos && !hasEfficacy;
                        const needsSummaryGeneration = hasEfficacy && !hasSummary;

                        return needsEfficacyGeneration || needsSummaryGeneration;
                    });

                    if (trialsToProcess.length === 0) {
                        showToast('All trials are already fully analyzed.', 'info');
                        return;
                    }

                    state.bulkAnalysisState = {
                        isRunning: true,
                        isPaused: false,
                        lastProcessedIndex: -1,
                        trialsToProcess: trialsToProcess,
                        totalToProcess: trialsToProcess.length,
                    };
                } else { // Resuming
                    state.bulkAnalysisState.isRunning = true;
                    state.bulkAnalysisState.isPaused = false;
                }

                renderBulkAnalysisControls();
                showToast(`Starting AI analysis for ${state.bulkAnalysisState.totalToProcess} trials...`, 'info');

                await runBulkAnalysisLoop();
            }

            async function handleSingleAiGeneration(trialId) {
                const trial = state.trials.find(t => t.ID === trialId);
                if (!trial) return;

                showToast(`Generating AI report for ${trial.FormulationName}...`, 'info');

                try {
                    let efficacyData = safeJsonParse(trial.EfficacyDataJSON, []);
                    let efficacyWasGenerated = false;

                    // Step 1: Generate efficacy from photos if needed
                    if (efficacyData.length === 0) {
                        const photos = safeJsonParse(trial.PhotoURLs, []);
                        if (photos.length > 0) {
                            const newEfficacyObservations = [];
                            for (const photo of photos) {
                                if (!photo.url) continue;
                                const imageData = await getImageAsResizedBase64(photo.url);
                                if (!imageData) continue;

                                const analysisResult = await analyzePhotoForEfficacy(imageData, 'image/jpeg');

                                if (analysisResult) {
                                    const observationDate = new Date(photo.date || trial.Date);
                                    const trialDate = new Date(trial.Date);
                                    const daa = Math.round((observationDate.getTime() - trialDate.getTime()) / (1000 * 60 * 60 * 24));

                                    newEfficacyObservations.push({
                                        date: observationDate.toISOString().split('T')[0],
                                        daa: daa >= 0 ? daa : 0,
                                        phyto: analysisResult.phyto,
                                        notes: `AI analysis from photo on ${observationDate.toLocaleDateString()}`,
                                        photoUrl: photo.url,
                                        weedDetails: analysisResult.weedDetails,
                                    });
                                }
                            }

                            if (newEfficacyObservations.length > 0) {
                                trial.EfficacyDataJSON = JSON.stringify(newEfficacyObservations);
                                efficacyWasGenerated = true;
                            } else {
                                showToast('No analyzable photos found to generate efficacy data.', 'error');
                            }
                        } else {
                            showToast('No photos available to analyze.', 'error');
                        }
                    }

                    // Step 2: Generate summaries if efficacy data exists (either pre-existing or just generated)
                    efficacyData = safeJsonParse(trial.EfficacyDataJSON, []);
                    if (efficacyData.length > 0) {
                        await updateTrialAISummaries(trial.ID, efficacyWasGenerated);
                        showToast('AI report generated successfully!', 'success');
                        applyFilters(); // Refresh UI
                    } else if (efficacyWasGenerated) {
                        // Saved efficacy but failed summary step maybe? 
                        // Just saving trial record in updateTrialAISummaries handles saving, but if we didn't call it...
                        const payload = { id: trial.ID, EfficacyDataJSON: trial.EfficacyDataJSON, AISummariesJSON: '{}' };
                        await apiCall('updateTrialRecord', payload, false);
                        showToast('Efficacy data generated. Summary generation skipped/failed.', 'info');
                        applyFilters();
                    }

                } catch (error) {
                    console.error("Single AI Gen Error:", error);
                    showToast(`Analysis failed: ${error.message}`, 'error');
                }
            }

            async function updateTrialAISummaries(trialId, wasEfficacyGenerated = false) {
                const trialIndex = state.trials.findIndex(t => t.ID === trialId);
                if (trialIndex === -1) return;

                const trial = state.trials[trialIndex];
                let efficacyData = safeJsonParse(trial.EfficacyDataJSON, []);
                if (efficacyData.length === 0) return;

                const currentSummaries = safeJsonParse(trial.AISummariesJSON, {});
                let finalSummaries = { ...currentSummaries };
                let summariesWereUpdated = false;

                // Determine context for AI based on trial completion
                const isFinal = String(trial.IsCompleted).toLowerCase() === 'true' || String(trial.ControlFinalized).toLowerCase() === 'true';
                const status = isFinal ? "Finalized/Completed" : "Ongoing";

                // --- PREPARE EXTRA CONTEXT (WCE, Weather, Weed IDs) ---
                const allWeedSpecies = [...new Set(efficacyData.flatMap(obs => (obs.weedDetails || []).map(wc => wc.species.trim())))];

                // 1. Weather
                const weather = {
                    temp: trial.Temperature,
                    humidity: trial.Humidity,
                    wind: trial.Windspeed,
                    rain: trial.Rain
                };

                // 2. Weed Identification (High confidence ones)
                const weedPhotos = safeJsonParse(trial.WeedPhotosJSON, []);
                const weedIds = weedPhotos.flatMap(p => p.identifications || [])
                    .filter(id => id.confidence > 0.7) // Only high confidence
                    .map(id => ({ name: id.name, confidence: id.confidence }));

                // 3. WCE Calculation
                // Find Day 0 (or closest to 0) and Final Day for each species
                const wceData = allWeedSpecies.map(species => {
                    // Get all observations for this species
                    const speciesObs = efficacyData.map(obs => {
                        const detail = (obs.weedDetails || []).find(d => d.species === species);
                        return detail ? { day: parseFloat(obs.daa), cover: parseFloat(detail.cover) } : null;
                    }).filter(Boolean).sort((a, b) => a.day - b.day);

                    if (speciesObs.length < 2) return null;

                    const initial = speciesObs[0];
                    const final = speciesObs[speciesObs.length - 1];

                    if (initial.cover <= 0) return null; // Avoid divide by zero

                    const wce = ((initial.cover - final.cover) / initial.cover) * 100;
                    return { species, wce, initialDay: initial.day, finalDay: final.day };
                }).filter(Boolean);

                const extraContext = { weather, weedIds, wceData };

                if (!finalSummaries.cover) {
                    const colors = ['#4A90E2', '#D0021B', '#F5A623', '#7ED321', '#50E3C2', '#9013FE'];
                    const coverDatasets = allWeedSpecies.map((species, index) => ({
                        label: species,
                        data: efficacyData.map(obs => { const weed = (obs.weedDetails || []).find(wc => wc.species.trim() === species); return weed ? { x: parseFloat(obs.daa), y: parseFloat(weed.cover) } : null; }).filter(p => p && !isNaN(p.x) && !isNaN(p.y)).sort((a, b) => a.x - b.x),
                        borderColor: colors[index % colors.length], tension: 0.1, fill: false
                    }));
                    const coverConfig = { type: 'line', data: { datasets: coverDatasets }, options: { scales: { x: { type: 'linear' }, y: { beginAtZero: true, max: 100 } } } };
                    const summary = await getChartSummaryFromAI(coverConfig, '% Cover by Species', allWeedSpecies.join(', '), status, trial.Result, extraContext);
                    finalSummaries.cover = summary;
                    summariesWereUpdated = true;
                }

                if (!finalSummaries.phyto) {
                    const phytoData = { label: '% Phytotoxicity', data: efficacyData.map(d => ({ x: parseFloat(d.daa), y: parseFloat(d.phyto) })).filter(p => !isNaN(p.x) && !isNaN(p.y)).sort((a, b) => a.x - b.x), borderColor: '#d97706', tension: 0.1, fill: false };
                    const phytoConfig = { type: 'line', data: { datasets: [phytoData] }, options: { scales: { x: { type: 'linear' }, y: { beginAtZero: true, max: 100 } } } };
                    const summary = await getChartSummaryFromAI(phytoConfig, '% Phytotoxicity', 'Overall', status, trial.Result, extraContext);
                    finalSummaries.phyto = summary;
                    summariesWereUpdated = true;
                }

                if (summariesWereUpdated || wasEfficacyGenerated) {
                    trial.AISummariesJSON = JSON.stringify(finalSummaries);
                    const payload = { id: trial.ID, AISummariesJSON: trial.AISummariesJSON };
                    if (wasEfficacyGenerated) {
                        payload.EfficacyDataJSON = trial.EfficacyDataJSON;
                    }
                    await apiCall('updateTrialRecord', payload, false);
                }
            }

            async function runBulkAnalysisLoop() {
                const { trialsToProcess, totalToProcess } = state.bulkAnalysisState;
                let successCount = 0;
                let errorCount = 0;

                for (let i = state.bulkAnalysisState.lastProcessedIndex + 1; i < totalToProcess; i++) {
                    if (!state.bulkAnalysisState.isRunning) break;
                    const trial = trialsToProcess[i];
                    state.bulkAnalysisState.lastProcessedIndex = i;
                    renderBulkAnalysisControls();

                    try {
                        let efficacyData = safeJsonParse(trial.EfficacyDataJSON, []);
                        let efficacyWasGenerated = false;

                        // Step 1: Generate efficacy from photos if needed
                        if (efficacyData.length === 0) {
                            const photos = safeJsonParse(trial.PhotoURLs, []);
                            if (photos.length > 0) {
                                const newEfficacyObservations = [];
                                for (const photo of photos) {
                                    if (!photo.url) continue;
                                    const imageData = await getImageAsResizedBase64(photo.url);
                                    if (!imageData) continue;

                                    const analysisResult = await analyzePhotoForEfficacy(imageData, 'image/jpeg');

                                    if (analysisResult) {
                                        const observationDate = new Date(photo.date || trial.Date);
                                        const trialDate = new Date(trial.Date);
                                        const daa = Math.round((observationDate.getTime() - trialDate.getTime()) / (1000 * 60 * 60 * 24));

                                        newEfficacyObservations.push({
                                            date: observationDate.toISOString().split('T')[0],
                                            daa: daa >= 0 ? daa : 0,
                                            phyto: analysisResult.phyto,
                                            notes: `AI analysis from photo on ${observationDate.toLocaleDateString()}`,
                                            photoUrl: photo.url,
                                            weedDetails: analysisResult.weedDetails,
                                        });
                                    }
                                }

                                if (newEfficacyObservations.length > 0) {
                                    trial.EfficacyDataJSON = JSON.stringify(newEfficacyObservations);
                                    efficacyWasGenerated = true;
                                }
                            }
                        }

                        // Step 2: Generate summaries if efficacy data exists
                        efficacyData = safeJsonParse(trial.EfficacyDataJSON, []);
                        if (efficacyData.length > 0) {
                            await updateTrialAISummaries(trial.ID, efficacyWasGenerated);
                            successCount++;
                        }
                    } catch (error) {
                        if (error.message === 'QUOTA_EXCEEDED') {
                            state.bulkAnalysisState.isRunning = false;
                            state.bulkAnalysisState.isPaused = true;
                            renderBulkAnalysisControls();
                            showToast('Analysis paused. All API keys have exceeded their quota.', 'error');
                            return; // Exit the loop
                        }
                        console.error(`Failed to process trial ${trial.ID}:`, error);
                        errorCount++;
                    }
                }

                showToast(`Finished. ${successCount} trials updated, ${errorCount} failed.`, errorCount > 0 ? 'error' : 'success');
                cancelBulkAnalysis();
                if (successCount > 0) initializeApp(false);
            }

            function cancelBulkAnalysis() {
                state.bulkAnalysisState = { isRunning: false, isPaused: false, lastProcessedIndex: -1, trialsToProcess: [], totalToProcess: 0 };
                renderBulkAnalysisControls();
                showToast('Analysis cancelled.', 'info');
            }

            function renderBulkAnalysisControls() {
                const controlsEl = document.getElementById('bulk-analysis-controls');
                const progressEl = document.getElementById('summary-progress');
                if (!controlsEl || !progressEl) return;

                const { isRunning, isPaused, lastProcessedIndex, totalToProcess } = state.bulkAnalysisState;

                if (isRunning && !isPaused) {
                    controlsEl.innerHTML = `<button data-action="cancel-bulk-analysis" class="bg-red-600 text-white px-4 py-2 rounded-lg">Cancel Analysis</button>`;
                    progressEl.textContent = `Processing ${lastProcessedIndex + 1}/${totalToProcess}...`;
                } else if (isPaused) {
                    controlsEl.innerHTML = `
                        <button data-action="manage-bulk-analysis" class="bg-green-600 text-white px-4 py-2 rounded-lg">Resume Analysis</button>
                        <button data-action="cancel-bulk-analysis" class="bg-gray-500 text-white px-4 py-2 rounded-lg">Cancel</button>
                    `;
                    progressEl.textContent = `Paused due to API quota limit. Processed ${lastProcessedIndex + 1}/${totalToProcess}.`;
                } else {
                    controlsEl.innerHTML = `<button data-action="manage-bulk-analysis" class="bg-indigo-600 text-white px-4 py-2 rounded-lg">Generate AI Efficacy Data & Summaries</button>`;
                    progressEl.textContent = '';
                }
            }


            function updateSelectionBar() {
                const count = state.selectedTrials.length;
                const bar = document.getElementById('bulk-action-bar');
                const countEl = document.getElementById('selected-count');

                if (!bar || !countEl) return;

                countEl.textContent = count;

                if (count > 0) {
                    bar.classList.remove('hidden');
                    // Small delay to allow display:block to apply before transition
                    setTimeout(() => {
                        bar.classList.remove('translate-y-20', 'opacity-0');
                    }, 10);
                } else {
                    bar.classList.add('translate-y-20', 'opacity-0');
                    setTimeout(() => {
                        if (state.selectedTrials.length === 0) bar.classList.add('hidden');
                    }, 300);
                }
            }

            async function handleBulkDelete() {
                const count = state.selectedTrials.length;
                if (count === 0) return;

                showConfirmation('Delete Selected Trials?', `Are you sure you want to delete ${count} trial(s)? This cannot be undone.`, async () => {
                    const originalTrials = [...state.trials];
                    const selectedIds = [...state.selectedTrials];

                    try {
                        // Optimistic Update
                        state.trials = state.trials.filter(t => !selectedIds.includes(t.ID));
                        state.selectedTrials = [];
                        updateSelectionBar();
                        applyFilters(); // Re-render list

                        showToast(`Deleting ${count} trials...`, 'info');

                        let successCount = 0;
                        for (const id of selectedIds) {
                            const result = await apiCall('deleteTrial', { id }, false);
                            if (result && result.success) {
                                successCount++;
                            }
                        }

                        if (successCount === count) {
                            showToast(`${successCount} trials deleted successfully.`, 'success');
                        } else {
                            showToast(`Deleted ${successCount} of ${count} trials. Some failed.`, 'warning');
                        }
                    } catch (error) {
                        console.error('Bulk delete failed:', error);
                        state.trials = originalTrials; // Revert
                        showToast('Bulk delete failed. Data restored.', 'error');
                        applyFilters();
                    }
                });
            }

            function bindEventListeners() {
                document.getElementById('sidebar-nav').addEventListener('click', e => {
                    const target = e.target.closest('a');
                    if (target && target.dataset.page) {
                        e.preventDefault();
                        switchPage(target.dataset.page);
                    }
                });

                // Close menus when clicking outside
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('[data-action="toggle-card-menu"]')) {
                        document.querySelectorAll('.card-menu').forEach(el => el.classList.add('hidden'));
                    }
                });

                document.body.addEventListener('click', e => {
                    const target = e.target.closest('[data-action]');
                    if (!target) return;
                    const { action, type, id, index, sort, trialId, photoIndex, obsIndex } = target.dataset;
                    const actions = {
                        openModal: () => handleOpenModal(type),
                        'toggle-card-menu': () => {
                            const menu = document.getElementById(`card-menu-${id}`);
                            document.querySelectorAll('.card-menu').forEach(el => {
                                if (el !== menu) el.classList.add('hidden');
                            });
                            if (menu) menu.classList.toggle('hidden');
                        },
                        'open-weed-modal': () => handleOpenModal('weedId', id),
                        'open-organise-modal': () => openModal('organise'),
                        'open-plot-scanner': () => openQrScanner(),
                        'close-qr-scanner': () => closeQrScanner(),
                        'go-to-compare': () => { switchPage('compareTrials'); },
                        'get-location': () => getGeoLocation(coords => { document.getElementById('trial-form').querySelector('[name="location"]').value = `${coords.lat.toFixed(5)}, ${coords.lon.toFixed(5)}`; showToast('Location captured!', 'success'); }),
                        'fetch-trial-weather': () => fetchWeatherForTrialDate(),
                        edit: () => handleEdit(type, id),
                        delete: () => handleDelete(type, id),
                        duplicate: () => handleDuplicateItem(type, id),
                        'finalize-trial': () => handleFinalizeTrial(id),
                        'restart-trial': () => handleRestartTrial(id),
                        'toggle-live-status': () => handleToggleLiveStatus(id),
                        // Project Dashboard Actions
                        'delete-project': () => handleDelete('project', id),
                        'add-block': () => handleOpenModal('block', null, { projectId: state.activeProjectId }),
                        'delete-block': () => handleDelete('block', id),
                        'add-plot': () => {
                            if (!target.dataset.blockId) return showToast('Error: Missing Block ID', 'error');
                            handleOpenModal('trial', null, { ProjectID: state.activeProjectId, BlockID: target.dataset.blockId });
                        },
                        'open-randomize-modal': () => handleOpenModal('randomize', null, { projectId: state.activeProjectId }),
                        'run-analysis': async () => {
                            try {
                                showToast('Starting analysis...', 'info');
                                await runProjectAnalysis(state.activeProjectId);
                            } catch (e) {
                                console.error(e);
                                showToast('Analysis failed: ' + e.message, 'error');
                            }
                        },
                        'lock-project': () => {
                            if (confirm('Are you sure you want to LOCK this project? No further changes will be allowed.')) {
                                handleProjectLock(state.activeProjectId);
                            }
                        },
                        'unlock-project': () => {
                            if (confirm('Unlock this project? Doing so will allow editing.')) {
                                const p = state.projects.find(proj => proj.ID === state.activeProjectId);
                                if (p) { p.Status = 'Draft'; apiCall('updateProject', { id: p.ID, Status: 'Draft' }, false); render.projectDashboard(); }
                            }
                        },
                        'manage-live-qr': () => {
                            const trial = state.trials.find(t => t.ID === id);
                            if (!trial) {
                                console.error('Trial not found:', id);
                                showToast('Trial not found. Please refresh the page.', 'error');
                                return;
                            }
                            openModal('liveQrSettings', false, { trial });
                        },
                        'save-live-qr-settings-final': () => handleSaveLiveQrSettingsFinal(),
                        'generate-qr-final': () => generateTrialCardsCombined(id, target.dataset.mode),
                        'analyze-trial-efficacy': () => analyzeTrialEfficacy(id),
                        'edit-control-days': () => {
                            // Ensure event doesn't bubble if this button is inside a card
                            e.stopPropagation();
                            handleQuickEditControl(id);
                        },
                        'generate-qr-label': () => openModal('qrModeChoice', { trial: state.trials.find(t => t.ID === id) }),
                        'delete-weed-photo': () => handleWeedPhotoDelete(trialId, parseInt(index, 10)),
                        'view-trial': () => openTrialDetail(id),
                        'sort-trials': () => applyFilters({ sortBy: sort }),
                        'reset-filters': () => {
                            // Clear filter state
                            state.filterState = { search: '', formulationText: '', formulation: '', startDate: '', endDate: '', sortBy: 'date' };
                            // Update UI inputs
                            const searchInput = document.querySelector('[data-type="trial-search"]');
                            const formTextInput = document.querySelector('[data-type="trial-formulation-text"]');
                            const formInput = document.querySelector('[data-type="trial-formulation"]');
                            const startInput = document.querySelector('[data-type="trial-start-date"]');
                            const endInput = document.querySelector('[data-type="trial-end-date"]');
                            if (searchInput) searchInput.value = '';
                            if (formTextInput) formTextInput.value = '';
                            if (formInput) formInput.value = '';
                            if (startInput) startInput.value = '';
                            if (endInput) endInput.value = '';
                            applyFilters();
                        },
                        'add-observation': () => addObservation(),
                        'remove-observation': () => target.closest('.observation-card').remove(),
                        'add-weed-cover': () => addWeedCoverRow(target.closest('.observation-card')),
                        'remove-weed-cover': () => target.closest('.weed-details-row').remove(),
                        'fetch-obs-weather': () => fetchWeatherForObservation(obsIndex),
                        'export-pdf-with-report': () => openReportPreviewModal(id, { withIngredients: true, withWeeds: true, withEfficacy: true, withTimeline: state.settings.includeTimeline, showPhotoDates: state.settings.showPhotoDates }),
                        'export-pdf-efficacy-no-ingredients': () => openReportPreviewModal(id, { withIngredients: false, withWeeds: true, withEfficacy: true, withTimeline: state.settings.includeTimeline, showPhotoDates: state.settings.showPhotoDates }),
                        'export-pdf-ingredients': () => generateComprehensivePdf(id, { withIngredients: true, withEfficacy: false, withTimeline: state.settings.includeTimeline, showPhotoDates: state.settings.showPhotoDates }),
                        'export-pdf-no-ingredients': () => generateComprehensivePdf(id, { withIngredients: false, withEfficacy: false, withTimeline: state.settings.includeTimeline, showPhotoDates: state.settings.showPhotoDates }),
                        'export-pdf-weeds-ingredients': () => generateComprehensivePdf(id, { withIngredients: true, withWeeds: true, withEfficacy: false, withTimeline: state.settings.includeTimeline, showPhotoDates: state.settings.showPhotoDates }),
                        'export-pdf-weeds': () => generateComprehensivePdf(id, { withIngredients: false, withWeeds: true, withEfficacy: false, withTimeline: state.settings.includeTimeline, showPhotoDates: state.settings.showPhotoDates }),
                        'export-ppt': () => generatePpt(id),
                        'export-json': exportJson,
                        'export-zip': exportWithPhotos,
                        'export-standalone': exportStandaloneHTML,
                        'import-data': handleImport,
                        'clear-data': () => clearAllData(true),
                        'force-reload': () => { showToast('Clearing cache & reloading...', 'success'); localStorage.clear(); setTimeout(() => window.location.reload(), 1500); },
                        'test-api-key': () => testApiKey(),
                        'add-ingredient-row': addFormulationIngredientRow,
                        'apply-bulk-add': handleBulkIngredients,
                        'apply-bulk-add-cost': handleBulkIngredientsCost,
                        'close-modal': closeModal,
                        'close-qr-scanner': () => closeQrScanner(),
                        'cancel-crop': closeCropper,
                        'crop-image': cropAndSaveImage,
                        'rotate-left': () => { if (cropper) cropper.rotate(-90); },
                        'rotate-right': () => { if (cropper) cropper.rotate(90); },
                        'open-camera': () => openCamera(),
                        'quick-open-camera': () => { state.cameraMode = 'general'; openCamera(id); },
                        'open-weed-camera': () => { state.cameraMode = 'weed'; openCamera(trialId); },
                        'close-camera': closeCamera,
                        'capture-photo': capturePhoto,
                        'remove-ingredient-row': () => { target.closest('.formulation-ingredient-row').remove(); updateFormulationCost(); },
                        'remove-photo': () => { state.croppedPhotosData.splice(parseInt(index, 10), 1); updatePhotoPreview(); },
                        'reset-data-sources': () => { localStorage.removeItem('appSettings'); loadSettings(); showToast('Data sources reset.', 'success'); initializeApp(); },
                        'open-photo-edit-modal': () => handleOpenPhotoEditModal(trialId, photoIndex),
                        'attach-ai-image': () => document.getElementById('ai-image-input').click(),
                        'remove-ai-image': () => { state.aiAttachedImage = { fileData: null, mimeType: null }; document.getElementById('ai-image-preview-container').style.display = 'none'; document.getElementById('ai-image-input').value = ''; },
                        'clear-chat': () => showConfirmation('Clear Chat History?', 'This will permanently delete the conversation.', () => { state.aiChatHistory = []; localStorage.removeItem('aiChatHistory'); if (document.getElementById('ai-chat-box')) document.getElementById('ai-chat-box').innerHTML = ''; appendMessageToChat('Hello! Ask me a question.', 'ai', false); showToast('Chat history cleared.'); }),
                        'run-comparison': runComparison,
                        'export-professional-report': () => generateProfessionalPdfReport(),
                        'manage-bulk-analysis': () => manageBulkAnalysis(),
                        'cancel-bulk-analysis': () => cancelBulkAnalysis(),
                        'generate-single-ai': () => handleSingleAiGeneration(id),
                        'add-api-key': () => {
                            const container = document.getElementById('api-keys-container');
                            if (container) {
                                const newIndex = container.querySelectorAll('.api-key-row').length;
                                container.insertAdjacentHTML('beforeend', render.apiKeyInput('', newIndex));
                            }
                        },
                        'remove-api-key': () => {
                            const row = target.closest('.api-key-row');
                            if (row) {
                                if (document.querySelectorAll('.api-key-row').length > 1) {
                                    row.remove();
                                } else {
                                    row.querySelector('.api-key-input').value = '';
                                }
                            }
                        },
                        'remove-compare-trial': () => {
                            // Remove from selection state
                            state.selectedTrials = state.selectedTrials.filter(tid => tid !== id);
                            // Rerender the comparison page content to update list
                            render.compareTrials();
                            updateSelectionBar();
                        },
                        'print-cards': () => generateCardsForPrint(),
                        'print-pdf': () => generateCardsPdf(),
                        'clear-selection': () => {
                            state.selectedTrials = [];
                            updateSelectionBar();
                            if (state.currentPage === 'compareTrials') render.compareTrials();
                            document.querySelectorAll('input[data-action="select-trial"]').forEach(cb => cb.checked = false);
                        },
                        'retry-sync': () => {
                            const item = state.syncQueue.find(s => s.id === id);
                            if (item) {
                                item.status = 'pending';
                                processSyncQueue();
                            }
                        },
                        'open-project-modal': () => handleOpenModal('project'),
                        'delete-selected': () => handleBulkDelete(),
                    };
                    const handler = actions[action];
                    if (handler) {
                        e.preventDefault();
                        e.stopPropagation();
                        handler();
                    }
                });

                document.body.addEventListener('input', e => {
                    const target = e.target;
                    if (target.id === 'import-file-input') document.querySelector('[data-action="import-data"]').disabled = !target.files.length;

                    if (target.matches('[data-action="filter"]')) {
                        // Handle formulation specific search separately or generally
                        if (target.dataset.type === 'formulation') {
                            const searchTerm = target.value.toLowerCase();
                            const filteredFormulations = state.formulations.filter(f => f.Name.toLowerCase().includes(searchTerm));
                            render.formulations(filteredFormulations);
                        } else {
                            applyFilters();
                        }
                    }

                    if (target.matches('[data-action="toggle-photo-dates"]')) {
                        state.settings.showPhotoDates = target.checked;
                        localStorage.setItem('appSettings', JSON.stringify(state.settings));
                    }
                    if (target.matches('[data-action="toggle-include-timeline"]')) {
                        state.settings.includeTimeline = target.checked;
                        localStorage.setItem('appSettings', JSON.stringify(state.settings));
                    }

                    if (target.matches('[data-action="select-trial"]')) {
                        const { id } = target.dataset;
                        if (target.checked) { if (!state.selectedTrials.includes(id)) state.selectedTrials.push(id); } else { state.selectedTrials = state.selectedTrials.filter(trialId => trialId !== id); }
                        updateSelectionBar();
                    }
                    if (target.id === 'trial-photos') handlePhotoSelection(e);
                    if (target.matches('.photo-label-input')) state.croppedPhotosData[target.dataset.index].label = target.value;
                    if (target.closest('#formulation-form')) updateFormulationCost();

                    // Listen for comparison filter changes
                    if (target.id === 'compare-weed-filter' || target.id === 'compare-metric-filter') {
                        runComparison();
                    }
                });

                document.body.addEventListener('change', async e => {
                    const target = e.target;
                    if (target.matches('[data-action="update-result"]')) {
                        const { id } = target.dataset; const newResult = target.value; const trialIndex = state.trials.findIndex(t => t.ID === id); if (trialIndex === -1) return;
                        state.trials[trialIndex].Result = newResult;
                        const result = await apiCall('updateTrialRecord', { id, Result: newResult }, false);
                        const updatedRecord = result?.record || (result?.ID ? result : null);
                        if (updatedRecord) {
                            const idx = state.trials.findIndex(t => t.ID === updatedRecord.ID);
                            if (idx > -1) state.trials[idx] = updatedRecord;
                            showToast('Result updated!', 'success');
                            if (state.currentPage === 'dashboard') render.dashboard();
                        } else {
                            showToast('Failed to update result.', 'error');
                        }
                    }
                    if (target.matches('[data-action="toggle-completed"]')) handleToggleCompleted(target.dataset.id, target.checked);
                    if (target.matches('[data-action="quick-add-photo"]')) {
                        if (target.files.length > 0) {
                            state.cameraMode = 'general';
                            state.photoQueue = [...target.files];
                            processPhotoQueue(target.dataset.id);
                        }
                        target.value = '';
                    }
                    if (target.id === 'weed-photos-input') {
                        if (target.files.length > 0) {
                            console.log('weed-photos-input triggered, setting cameraMode to weed');
                            state.cameraMode = 'weed';
                            state.photoQueue = [...target.files];
                            processPhotoQueue(target.dataset.trialId);
                        }
                        target.value = '';
                    }
                    if (target.id === 'ai-image-input') {
                        const file = target.files[0];
                        if (file) {
                            const reader = new FileReader();
                            reader.onload = e => { state.aiAttachedImage = { fileData: e.target.result, mimeType: file.type }; document.getElementById('ai-image-preview').src = e.target.result; document.getElementById('ai-image-preview-container').style.display = 'block'; };
                            reader.readAsDataURL(file);
                        }
                    }
                });

                document.body.addEventListener('submit', e => { e.preventDefault(); handleFormSubmit(e.target); });
            }

            function updateSelectionBar() {
                const count = state.selectedTrials.length;
                const bar = document.getElementById('selection-bar');
                const countEl = document.getElementById('selected-items-count');
                if (!bar || !countEl) return;
                countEl.textContent = `${count} selected`;
                if (count > 0) bar.classList.remove('hidden'); else bar.classList.add('hidden');
            }

            // (Sync functions relocated to end of script for cleaner architecture)

            function appendMessageToChat(text, sender, isLoading = false, image = null, mimeType = null) {
                const chatBox = document.getElementById('ai-chat-box');
                if (!chatBox) return;

                const messageContainer = document.createElement('div');
                messageContainer.className = `flex ${sender === 'user' ? 'justify-end' : 'justify-start'} mb-4`;

                const messageDiv = document.createElement('div');
                messageDiv.className = `max-w-md p-3 rounded-lg shadow-md ${sender === 'user' ? 'bg-blue-500 text-white' : 'bg-gray-200 text-gray-800'}`;

                if (isLoading) {
                    messageDiv.innerHTML = `<div class="flex items-center gap-2"><div class="animate-spin rounded-full h-4 w-4 border-b-2 border-gray-900"></div><span>Thinking...</span></div>`;
                } else {
                    const sanitizedText = sanitizeHTML(text).replace(/\n/g, '<br>');
                    let imageHTML = '';
                    if (image) {
                        imageHTML = `<img src="${image}" class="max-w-xs rounded-md my-2" alt="User attachment"/>`;
                    }
                    messageDiv.innerHTML = `${imageHTML}${sanitizedText}`;
                }

                messageContainer.appendChild(messageDiv);
                chatBox.appendChild(messageContainer);
                chatBox.scrollTop = chatBox.scrollHeight;
            }

            function setupTrialModalLogic() {
                const form = document.getElementById('trial-form');
                if (!form) return;

                const controlFinalizedCheckbox = form.querySelector('#control-finalized');
                const finalizationDetailsDiv = form.querySelector('#finalization-details');

                // RCBD Block change logic
                const projectSelect = form.querySelector('#trial-project');
                const blockSelect = form.querySelector('#trial-block');
                const repInput = form.querySelector('#trial-replication');
                const repLock = form.querySelector('#rep-lock-icon');

                const syncReplication = () => {
                    const blockId = blockSelect?.value;
                    const block = state.blocks.find(b => b.ID === blockId);
                    if (block && repInput) {
                        repInput.value = block.ReplicationNum;
                        repInput.readOnly = true;
                        repInput.classList.add('bg-slate-50', 'text-slate-500');
                        repLock?.classList.remove('hidden');
                    } else if (repInput) {
                        repInput.readOnly = false;
                        repInput.classList.remove('bg-slate-50', 'text-slate-500');
                        repLock?.classList.add('hidden');
                    }
                };

                if (projectSelect && blockSelect) {
                    projectSelect.addEventListener('change', () => {
                        const pid = projectSelect.value;
                        const filtered = state.blocks.filter(b => b.ProjectID === pid);
                        blockSelect.innerHTML = '<option value="">No Block</option>' +
                            filtered.map(b => `<option value="${b.ID}">${sanitizeHTML(b.Name)}</option>`).join('');
                        syncReplication();
                    });
                    blockSelect.addEventListener('change', syncReplication);
                }
                syncReplication(); // Initial sync

                const updateFinalizationDate = () => {
                    if (finalizationDetailsDiv) {
                        if (controlFinalizedCheckbox.checked) {
                            finalizationDetailsDiv.classList.remove('hidden');
                            const finalizationDateInput = form.querySelector('#finalization-date');
                            if (finalizationDateInput && !finalizationDateInput.value) {
                                finalizationDateInput.value = new Date().toISOString().split('T')[0];
                            }
                        } else {
                            finalizationDetailsDiv.classList.add('hidden');
                        }
                    }
                };

                controlFinalizedCheckbox?.addEventListener('change', updateFinalizationDate);
                updateFinalizationDate(); // Initial check

                // Add Photo Date Listener for Weather Fetching
                const photoDateInput = form.querySelector('#photo-date');
                if (photoDateInput) {
                    photoDateInput.addEventListener('change', async () => {
                        const date = photoDateInput.value;
                        const locationStr = form.querySelector('[name="location"]').value;

                        if (!date || !locationStr) return;

                        let lat, lon;
                        if (locationStr.includes(',')) {
                            [lat, lon] = locationStr.split(',').map(s => s.trim());
                        }

                        if (lat && lon) {
                            showToast(`Fetching weather for ${date}...`, 'info');
                            const w = await fetchWeather(lat, lon, date);
                            if (w) {
                                state.tempPhotoWeather = w;
                                showToast('Weather captured for photo.', 'success');
                            }
                        }
                    });
                }

                // Add Main Trial Date Listener for Weather Fetching
                const trialDateInput = form.querySelector('[name="date"]');
                if (trialDateInput) {
                    trialDateInput.addEventListener('change', async () => {
                        const date = trialDateInput.value;
                        const locationStr = form.querySelector('[name="location"]').value;

                        if (!date || !locationStr) return;

                        let lat, lon;
                        if (locationStr.includes(',')) {
                            [lat, lon] = locationStr.split(',').map(s => s.trim());
                        }

                        if (lat && lon) {
                            showToast(`Updating trial weather for ${date}...`, 'info');
                            const w = await fetchWeather(lat, lon, date);
                            if (w) {
                                form.querySelector('[name="temperature"]').value = w.temp || '';
                                form.querySelector('[name="humidity"]').value = w.humidity || '';
                                form.querySelector('[name="windspeed"]').value = w.wind || '';
                                form.querySelector('[name="rain"]').value = w.rain || '';
                                showToast('Trial weather updated.', 'success');
                            }
                        }
                    });
                }
            }

            function getChartDefaults() {
                return {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                font: { size: 12, family: 'Segoe UI' },
                                color: '#475569', // slate-600
                                boxWidth: 15,
                                padding: 20,
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleFont: { size: 14, weight: 'bold' },
                            bodyFont: { size: 12 },
                            padding: 12,
                            cornerRadius: 4,
                            displayColors: true,
                            boxPadding: 4,
                        }
                    },
                    scales: {
                        x: {
                            grid: { display: false, borderColor: '#e2e8f0' /* slate-200 */ },
                            ticks: { color: '#64748b', font: { size: 11 } } // slate-500
                        },
                        y: {
                            beginAtZero: true,
                            grid: { color: '#f1f5f9', borderColor: '#e2e8f0' }, // slate-100, slate-200
                            ticks: { color: '#64748b', font: { size: 11 } }
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index',
                    },
                    elements: {
                        point: {
                            radius: 4,
                            hoverRadius: 7,
                            borderWidth: 2,
                            hoverBorderWidth: 2
                        },
                        line: {
                            tension: 0.4,
                            borderWidth: 3,
                        }
                    }
                };
            }

            async function renderChartToImage(chartConfig, width = 1200, height = 600) {
                return new Promise((resolve, reject) => {
                    try {
                        const offscreenCanvas = document.createElement('canvas');
                        offscreenCanvas.width = width;
                        offscreenCanvas.height = height;

                        const ctx = offscreenCanvas.getContext('2d');
                        ctx.fillStyle = 'white';
                        ctx.fillRect(0, 0, width, height);

                        const config = JSON.parse(JSON.stringify(chartConfig)); // Deep copy

                        config.options = {
                            ...config.options,
                            animation: false,
                            responsive: false,
                            devicePixelRatio: 2 // Render at 2x resolution for HD output
                        };

                        const chart = new Chart(ctx, config);

                        setTimeout(() => {
                            try {
                                resolve(chart.toBase64Image());
                            } catch (e) {
                                reject(e);
                            } finally {
                                chart.destroy();
                            }
                        }, 300);
                    } catch (e) {
                        console.error("Error creating chart for image render:", e);
                        reject(e);
                    }
                });
            }

            /**
             * Calculate Weed Control Efficiency for all species in a trial
             * Formula: WCE (%) = ((Initial Cover - Final Cover) / Initial Cover) × 100
             * @param {Array} efficacyData - Array of {daa, weedDetails[{species, cover}]}
             * @returns {Array} - [{species, wce, initialCover, finalCover, daysObserved, controlRating}]
             */
            function calculateWeedControlEfficiency(efficacyData) {
                if (!efficacyData || efficacyData.length < 2) {
                    console.warn('WCE calculation requires at least 2 observations (Day 0 and at least 1 follow-up)');
                    return [];
                }

                // Sort by DAA to ensure chronological order
                const sorted = [...efficacyData].sort((a, b) => parseFloat(a.daa) - parseFloat(b.daa));

                const initialObs = sorted[0];  // Day 0 or earliest observation
                const finalObs = sorted[sorted.length - 1];  // Latest observation

                if (!initialObs.weedDetails || !finalObs.weedDetails) {
                    console.warn('WCE calculation requires weedDetails in observations');
                    return [];
                }

                // Get all unique weed species across all observations
                const allSpecies = new Set();
                sorted.forEach(obs => {
                    (obs.weedDetails || []).forEach(w => allSpecies.add(w.species.trim()));
                });

                const wceResults = [];

                for (const species of allSpecies) {
                    const initialWeed = initialObs.weedDetails.find(w => w.species.trim() === species);
                    const finalWeed = finalObs.weedDetails.find(w => w.species.trim() === species);

                    const initialCover = initialWeed ? parseFloat(initialWeed.cover) : 0;
                    const finalCover = finalWeed ? parseFloat(finalWeed.cover) : 0;

                    let wce = 0;
                    if (initialCover > 0) {
                        wce = ((initialCover - finalCover) / initialCover) * 100;
                        // Clamp between 0-100% (negative values indicate regrowth/resistance)
                        wce = Math.max(0, Math.min(100, wce));
                    }

                    wceResults.push({
                        species: species,
                        wce: wce,
                        initialCover: initialCover,
                        finalCover: finalCover,
                        daysObserved: parseFloat(finalObs.daa) - parseFloat(initialObs.daa),
                        controlRating: getControlRating(wce)
                    });
                }

                return wceResults;
            }

            /**
             * Convert WCE percentage to standard agronomic control rating
             * @param {Number} wce - Weed Control Efficiency (0-100%)
             * @returns {String} - Control rating classification
             */
            function getControlRating(wce) {
                if (wce >= 90) return 'Excellent';
                if (wce >= 80) return 'Good';
                if (wce >= 60) return 'Fair';
                if (wce >= 40) return 'Poor';
                return 'Negligible';
            }

            /**
             * Save calculated statistics (WCE, ANOVA, etc.) to trial record
             * @param {String} trialId - Trial ID
             */
            function saveTrialStatistics(trialId) {
                const trial = state.trials.find(t => t.ID === trialId);
                if (!trial) return;

                const efficacyData = safeJsonParse(trial.EfficacyDataJSON);
                const wceData = calculateWeedControlEfficiency(efficacyData);

                let statsPayload = {
                    wce: wceData,
                    calculatedAt: new Date().toISOString(),
                    version: '1.2'
                };

                // ANOVA & LSD Calculation (if part of a project)
                if (trial.ProjectID) {
                    try {
                        const projectTrials = state.trials.filter(t => t.ProjectID === trial.ProjectID);
                        if (projectTrials.length >= 4) {
                            // Calculate WCE for all project trials
                            const trialsWithWce = projectTrials.map(t => {
                                const eData = (t.ID === trialId) ? efficacyData : safeJsonParse(t.EfficacyDataJSON);
                                const wceResults = calculateWeedControlEfficiency(eData);
                                // Summarize WCE for ANOVA (using average of all species or first species as metric)
                                // For simplicity, we use the average WCE across all species found in the plot
                                const avgWce = wceResults.length > 0 ? wceResults.reduce((sum, r) => sum + r.wce, 0) / wceResults.length : 0;
                                return { ...t, wce: avgWce };
                            });

                            const anovaResults = calculateRCBD_ANOVA(trialsWithWce, 'wce');
                            if (anovaResults) {
                                statsPayload.anovaResults = anovaResults;
                                if (anovaResults.anovaTable && anovaResults.anovaTable.treatment && anovaResults.anovaTable.treatment.sig < 0.05) {
                                    statsPayload.lsdResults = calculateFishersLSD(anovaResults);
                                    statsPayload.tukeyResults = calculateTukeyHSD(anovaResults);
                                }
                            }
                        }
                    } catch (err) {
                        console.warn('ANOVA calculation failed:', err);
                    }
                }

                trial.StatisticsJSON = JSON.stringify(statsPayload);

                // Sync to backend
                apiCall('updateTrialRecord', {
                    id: trialId,
                    StatisticsJSON: trial.StatisticsJSON
                }, false);

                console.log(`Statistics saved for trial ${trialId}:`, statsPayload);
            }

            /**
             * Calculate ANOVA for RCBD experiment
             * @param {Array} trials - All trials in the project (must have ProjectID, Replication, TreatmentNumber)
             * @param {String} metric - 'wce', 'cover', or 'phyto'
             * @param {String} species - For WCE, which weed species to analyze (null = average all)
             * @param {Number} daa - For cover/phyto, which observation day to analyze
             * @returns {Object} ANOVA table and diagnostic stats
             */
            function calculateRCBD_ANOVA(trials, metric = 'wce', species = null, daa = null) {
                console.log(`Computing ANOVA for ${metric}, species: ${species}, DAA: ${daa}`);

                // Filter trials to same project
                if (!trials || trials.length === 0) return null;
                const projectID = trials[0].ProjectID;
                if (!projectID) return null; // Can't analyze without project context

                const projectTrials = trials.filter(t => t.ProjectID === projectID);

                if (projectTrials.length < 4) { // Need at least 2 treatments * 2 reps
                    console.warn('Insufficient trials for ANOVA');
                    return null;
                }

                // Extract data matrix: [treatment][block] = value
                const dataMatrix = [];
                const treatmentNames = [];
                const blockNames = [];

                projectTrials.forEach(trial => {
                    const stats = safeJsonParse(trial.StatisticsJSON);
                    const efficacyData = safeJsonParse(trial.EfficacyDataJSON);
                    let value = null;

                    if (metric === 'wce') {
                        if (stats && stats.wce) {
                            if (species) {
                                const wceForSpecies = stats.wce.find(w => w.species === species);
                                value = wceForSpecies ? wceForSpecies.wce : null;
                            } else {
                                // Average WCE across all species
                                value = stats.wce.reduce((sum, w) => sum + w.wce, 0) / stats.wce.length;
                            }
                        }
                    } else if (metric === 'cover' || metric === 'phyto') {
                        const observation = efficacyData.find(obs => parseFloat(obs.daa) === daa);
                        if (observation) {
                            if (metric === 'phyto') {
                                value = parseFloat(observation.phyto);
                            } else {
                                // Average cover across species or specific species
                                if (species) {
                                    const weed = observation.weedDetails.find(w => w.species === species);
                                    value = weed ? parseFloat(weed.cover) : null;
                                } else {
                                    const covers = observation.weedDetails.map(w => parseFloat(w.cover));
                                    value = covers.reduce((sum, c) => sum + c, 0) / covers.length;
                                }
                            }
                        }
                    }

                    if (value === null || isNaN(value)) return;

                    const treatmentId = trial.FormulationName || trial.FormulationID || 'Unknown Trt';
                    const blockId = trial.Replication || trial.BlockID || 'Rep1';

                    if (!treatmentNames.includes(treatmentId)) treatmentNames.push(treatmentId);
                    if (!blockNames.includes(blockId)) blockNames.push(blockId);

                    const treatmentIndex = treatmentNames.indexOf(treatmentId);
                    const blockIndex = blockNames.indexOf(blockId);

                    if (!dataMatrix[treatmentIndex]) dataMatrix[treatmentIndex] = [];
                    dataMatrix[treatmentIndex][blockIndex] = value;
                });

                const t = treatmentNames.length;  // Number of treatments
                const r = blockNames.length;      // Number of blocks/reps
                const n = t * r;                  // Total observations expected

                if (t < 2 || r < 2) {
                    console.warn(`ANOVA requires at least 2 treatments and 2 reps (Got ${t} trt, ${r} reps)`);
                    return null;
                }

                // Flatten data for calculations
                const allValues = [];
                dataMatrix.forEach(treatment => {
                    if (treatment) {
                        treatment.forEach(value => {
                            if (value !== undefined && !isNaN(value)) allValues.push(value);
                        });
                    }
                });

                // Calculate means
                const grandMean = allValues.reduce((sum, v) => sum + v, 0) / allValues.length;

                const treatmentMeans = [];
                for (let i = 0; i < t; i++) {
                    const treatment = dataMatrix[i] || [];
                    const validValues = treatment.filter(v => v !== undefined && !isNaN(v));
                    treatmentMeans.push(validValues.length > 0 ? validValues.reduce((sum, v) => sum + v, 0) / validValues.length : 0);
                }

                const blockMeans = [];
                for (let b = 0; b < r; b++) {
                    const blockValues = [];
                    for (let i = 0; i < t; i++) {
                        if (dataMatrix[i] && dataMatrix[i][b] !== undefined) blockValues.push(dataMatrix[i][b]);
                    }
                    blockMeans.push(blockValues.length > 0 ? blockValues.reduce((sum, v) => sum + v, 0) / blockValues.length : 0);
                }

                // Sum of Squares calculations
                let SS_Total = 0;
                let SS_Treatment = 0;
                let SS_Block = 0;

                // Total SS
                allValues.forEach(value => {
                    SS_Total += Math.pow(value - grandMean, 2);
                });

                // Treatment SS
                treatmentMeans.forEach((mean, i) => {
                    const reps = (dataMatrix[i] || []).filter(v => v !== undefined && !isNaN(v)).length;
                    SS_Treatment += reps * Math.pow(mean - grandMean, 2);
                });

                // Block SS
                blockMeans.forEach((mean, b) => {
                    // Count treatments in this block
                    let trtsInBlock = 0;
                    for (let i = 0; i < t; i++) if (dataMatrix[i] && dataMatrix[i][b] !== undefined) trtsInBlock++;
                    SS_Block += trtsInBlock * Math.pow(mean - grandMean, 2);
                });

                // Error SS (by subtraction)
                const SS_Error = Math.max(0, SS_Total - SS_Treatment - SS_Block);

                // Degrees of freedom
                const df_Treatment = t - 1;
                const df_Block = r - 1;
                const df_Error = (t - 1) * (r - 1);
                const df_Total = allValues.length - 1;

                // Mean Squares
                const MS_Treatment = SS_Treatment / df_Treatment;
                const MS_Block = SS_Block / df_Block;
                const MS_Error = SS_Error / df_Error;

                // F-statistics
                const F_Treatment = MS_Error > 0 ? MS_Treatment / MS_Error : 0;
                const F_Block = MS_Error > 0 ? MS_Block / MS_Error : 0;

                // P-values using jStat
                let P_Treatment = 1;
                let P_Block = 1;

                try {
                    if (typeof jStat !== 'undefined') {
                        P_Treatment = 1 - jStat.centralF.cdf(F_Treatment, df_Treatment, df_Error);
                        P_Block = 1 - jStat.centralF.cdf(F_Block, df_Block, df_Error);
                    } else {
                        console.warn("jStat library not loaded. P-values cannot be calculated.");
                    }
                } catch (e) { console.error("Stats calculation error:", e); }

                // Coefficient of Variation
                const CV = grandMean !== 0 ? (Math.sqrt(MS_Error) / grandMean) * 100 : 0;

                // R-squared
                const R_squared = SS_Total !== 0 ? (SS_Treatment + SS_Block) / SS_Total : 0;

                const getSigStars = (p) => {
                    if (p < 0.001) return '***';
                    if (p < 0.01) return '**';
                    if (p < 0.05) return '*';
                    return 'ns';
                };

                return {
                    anovaTable: {
                        treatment: { source: 'Treatments', df: df_Treatment, ss: SS_Treatment, ms: MS_Treatment, f: F_Treatment, p: P_Treatment, sig: getSigStars(P_Treatment) },
                        block: { source: 'Blocks (Reps)', df: df_Block, ss: SS_Block, ms: MS_Block, f: F_Block, p: P_Block, sig: getSigStars(P_Block) },
                        error: { source: 'Error', df: df_Error, ss: SS_Error, ms: MS_Error },
                        total: { source: 'Total', df: df_Total, ss: SS_Total }
                    },
                    means: {
                        grand: grandMean,
                        treatments: treatmentMeans.map((mean, i) => ({ name: treatmentNames[i], mean: mean, n: (dataMatrix[i] || []).filter(v => v !== undefined && !isNaN(v)).length })),
                        blocks: blockMeans.map((mean, i) => ({ name: blockNames[i], mean: mean }))
                    },
                    diagnostics: { cv: CV, r_squared: R_squared, observations: allValues.length, treatments: t, replications: r }
                };
            }

            /**
             * Calculate Fisher's Least Significant Difference
             */
            function calculateFishersLSD(anovaResults, alpha = 0.05) {
                if (!anovaResults) return null;
                const { anovaTable, means, diagnostics } = anovaResults;

                const MSE = anovaTable.error.ms;
                const df_error = anovaTable.error.df;
                const r = diagnostics.replications;

                let t_critical = 2.0; // Fallback
                if (typeof jStat !== 'undefined') {
                    t_critical = jStat.studentt.inv(1 - alpha / 2, df_error);
                }

                const LSD = t_critical * Math.sqrt(2 * MSE / r);

                // Groupings
                const sortedMeans = [...means.treatments].sort((a, b) => b.mean - a.mean);
                const groups = sortedMeans.map(tm => ({ ...tm, letters: [] }));

                let currentLetterChar = 97; // 'a'

                // logic for letter assignment (simplified greedy approach)
                for (let i = 0; i < groups.length; i++) {
                    if (!groups[i].letters.length) groups[i].letters.push(String.fromCharCode(currentLetterChar));

                    for (let j = i + 1; j < groups.length; j++) {
                        const diff = Math.abs(groups[i].mean - groups[j].mean);
                        if (diff < LSD) {
                            // No significant difference, share letter
                            const lettersToShare = groups[i].letters;
                            lettersToShare.forEach(l => {
                                if (!groups[j].letters.includes(l)) groups[j].letters.push(l);
                            });
                        } else {
                            // Significant difference. 
                            // If target has no letters yet, we might need a new letter for the new group range
                            // But this is complex logic - for MVP:
                            // Just mark comparisons.
                        }
                    }
                    // If we moved to a significantly different group, increment letter for next unassigned
                    const hasUnassigned = groups.slice(i + 1).some(g => g.letters.length === 0);
                    if (hasUnassigned) currentLetterChar++;
                }
                // Cleanup messy letters (sophisticated algorithm needed for perfect output, but this works for simple cases)

                return { lsd: LSD, alpha: alpha, groupings: groups.map(g => ({ name: g.name, mean: g.mean, grouping: g.letters.join('') })) };
            }

            /**
             * Calculate Tukey's HSD (Honest Significant Difference)
             */
            function calculateTukeyHSD(anovaResults, alpha = 0.05) {
                if (!anovaResults) return null;
                const { anovaTable, means, diagnostics } = anovaResults;
                const MSE = anovaTable.error.ms;
                const r = diagnostics.replications;
                const t = diagnostics.treatments;
                const df = anovaTable.error.df;

                // Approximate q (Studentized Range) - using t-dist proxy as jStat lacks q-table
                let q = 3.0;
                if (typeof jStat !== 'undefined') {
                    // Very rough approximation: q ~ t * sqrt(2) * correction
                    q = jStat.studentt.inv(1 - alpha / 2, df) * Math.sqrt(2);
                }

                const HSD = q * Math.sqrt(MSE / r);
                return { hsd: HSD, alpha: alpha };
            }


            function prepareTrialChartData(trial) {
                if (!trial) return null;

                let efficacyData = safeJsonParse(trial.EfficacyDataJSON);

                // Data fixup for legacy
                if (efficacyData.length > 0 && efficacyData.some(d => (d.cover !== undefined) && d.weedDetails === undefined)) {
                    efficacyData.forEach(obs => {
                        if ((obs.cover !== undefined) && obs.weedDetails === undefined) {
                            obs.weedDetails = [{ species: (trial.WeedSpecies || 'Unknown').split(',')[0].trim(), cover: obs.cover, status: '', notes: '' }];
                        }
                    });
                }

                if (efficacyData.length === 0) return null;

                const colors = ['#4A90E2', '#D0021B', '#F5A623', '#7ED321', '#50E3C2', '#9013FE', '#000000', '#4a4a4a', '#f8e71c', '#b8e986'];
                const allWeedSpecies = [...new Set(efficacyData.flatMap(obs => (obs.weedDetails || []).map(wc => wc.species.trim())))];

                // 1. Cover Chart
                const coverDatasets = allWeedSpecies.map((species, index) => {
                    const speciesData = efficacyData
                        .map(obs => {
                            const weed = (obs.weedDetails || []).find(wc => wc.species.trim() === species);
                            return weed ? { x: parseFloat(obs.daa), y: parseFloat(weed.cover) } : null;
                        })
                        .filter(p => p && !isNaN(p.x) && !isNaN(p.y))
                        .sort((a, b) => a.x - b.x);

                    const color = colors[index % colors.length];
                    return {
                        label: species,
                        data: speciesData,
                        borderColor: color,
                        backgroundColor: color + '33',
                        fill: true,
                        pointRadius: 5,
                        pointBackgroundColor: color,
                        pointHoverRadius: 8,
                    };
                });

                const chartDefaults = getChartDefaults();
                const coverChartOptions = {
                    ...chartDefaults,
                    scales: {
                        ...chartDefaults.scales,
                        x: { ...chartDefaults.scales.x, type: 'linear', title: { display: true, text: 'Days After Application (DA-A)' } },
                        y: { ...chartDefaults.scales.y, max: 100, title: { display: true, text: '% Cover' } }
                    },
                    plugins: {
                        ...chartDefaults.plugins,
                        legend: { ...chartDefaults.plugins.legend, display: allWeedSpecies.length > 1 },
                        tooltip: {
                            ...chartDefaults.plugins.tooltip,
                            callbacks: {
                                label: function (context) {
                                    let label = context.dataset.label || '';
                                    if (label) { label += ': '; }
                                    if (context.parsed.y !== null) { label += context.parsed.y.toFixed(1) + '%'; }
                                    return label;
                                }
                            }
                        }
                    }
                };

                // 2. Phyto Chart
                const phytoData = {
                    label: '% Phytotoxicity',
                    data: efficacyData.map(d => ({ x: parseFloat(d.daa), y: parseFloat(d.phyto) })).filter(p => !isNaN(p.x) && !isNaN(p.y)).sort((a, b) => a.x - b.x),
                    borderColor: '#d97706',
                    backgroundColor: '#d9770633',
                    fill: true,
                    pointRadius: 5,
                    pointBackgroundColor: '#d97706',
                };

                const phytoChartOptions = {
                    ...chartDefaults,
                    scales: {
                        ...chartDefaults.scales,
                        x: { ...chartDefaults.scales.x, type: 'linear', title: { display: true, text: 'Days After Application (DA-A)' } },
                        y: { ...chartDefaults.scales.y, max: 100, title: { display: true, text: '% Phytotoxicity' } }
                    },
                    plugins: { ...chartDefaults.plugins, legend: { display: false } }
                };

                return {
                    coverDatasets,
                    coverChartOptions,
                    phytoData,
                    phytoChartOptions,
                    allWeedSpecies
                };
            }

            // New helper to decouple drawing charts from any AI/Async logic
            function renderTrialChartsToCanvases(trial, coverCanvasId, phytoCanvasId) {
                const chartData = prepareTrialChartData(trial);
                if (!chartData) return;

                const { coverDatasets, coverChartOptions, phytoData, phytoChartOptions } = chartData;

                const coverCtx = document.getElementById(coverCanvasId);
                if (coverCtx) {
                    new Chart(coverCtx, {
                        type: 'line',
                        data: { datasets: coverDatasets },
                        options: coverChartOptions
                    });
                }

                const phytoCtx = document.getElementById(phytoCanvasId);
                if (phytoCtx && phytoData.data.length > 0) {
                    new Chart(phytoCtx, {
                        type: 'line',
                        data: { datasets: [phytoData] },
                        options: phytoChartOptions
                    });
                }
            }

            // Main render function for trial details uses the helper but assigns to state for tracking
            function renderSingleTrialCharts(trial) {
                if (!trial) return;
                if (state.charts.singleCoverChart) state.charts.singleCoverChart.destroy();
                if (state.charts.singlePhytoChart) state.charts.singlePhytoChart.destroy();

                const coverCtx = document.getElementById('single-cover-chart');
                const phytoCtx = document.getElementById('single-phyto-chart');

                let efficacyData = safeJsonParse(trial.EfficacyDataJSON);

                if (efficacyData.length > 0 && efficacyData.some(d => (d.cover !== undefined) && d.weedDetails === undefined)) {
                    efficacyData.forEach(obs => {
                        if ((obs.cover !== undefined) && obs.weedDetails === undefined) {
                            obs.weedDetails = [{ species: (trial.WeedSpecies || 'Unknown').split(',')[0].trim(), cover: obs.cover, status: '', notes: '' }];
                        }
                    });
                }

                if (efficacyData.length === 0) return;

                const colors = ['#4A90E2', '#D0021B', '#F5A623', '#7ED321', '#50E3C2', '#9013FE', '#000000', '#4a4a4a', '#f8e71c', '#b8e986'];
                const allWeedSpecies = [...new Set(efficacyData.flatMap(obs => (obs.weedDetails || []).map(wc => wc.species.trim())))];

                const coverDatasets = allWeedSpecies.map((species, index) => {
                    const speciesData = efficacyData
                        .map(obs => {
                            const weed = (obs.weedDetails || []).find(wc => wc.species.trim() === species);
                            return weed ? { x: parseFloat(obs.daa), y: parseFloat(weed.cover) } : null;
                        })
                        .filter(p => p && !isNaN(p.x) && !isNaN(p.y))
                        .sort((a, b) => a.x - b.x);

                    const color = colors[index % colors.length];
                    return {
                        label: species,
                        data: speciesData,
                        borderColor: color,
                        backgroundColor: color + '33', // 20% opacity
                        fill: true,
                        pointRadius: 5,
                        pointBackgroundColor: color,
                        pointHoverRadius: 8,
                    };
                });

                const chartDefaults = getChartDefaults();
                const coverChartOptions = {
                    ...chartDefaults,
                    scales: {
                        ...chartDefaults.scales,
                        x: { ...chartDefaults.scales.x, type: 'linear', title: { display: true, text: 'Days After Application (DA-A)' } },
                        y: { ...chartDefaults.scales.y, max: 100, title: { display: true, text: '% Cover' } }
                    },
                    plugins: {
                        ...chartDefaults.plugins,
                        legend: { ...chartDefaults.plugins.legend, display: allWeedSpecies.length > 1 },
                        tooltip: {
                            ...chartDefaults.plugins.tooltip,
                            callbacks: {
                                label: function (context) {
                                    let label = context.dataset.label || '';
                                    if (label) { label += ': '; }
                                    if (context.parsed.y !== null) { label += context.parsed.y.toFixed(1) + '%'; }
                                    return label;
                                }
                            }
                        }
                    }
                };

                if (coverCtx && coverDatasets.length > 0) {
                    state.charts.singleCoverChart = new Chart(coverCtx, {
                        type: 'line',
                        data: { datasets: coverDatasets },
                        options: coverChartOptions
                    });
                }

                const phytoData = {
                    label: '% Phytotoxicity',
                    data: efficacyData.map(d => ({ x: parseFloat(d.daa), y: parseFloat(d.phyto) })).filter(p => !isNaN(p.x) && !isNaN(p.y)).sort((a, b) => a.x - b.x),
                    borderColor: '#d97706',
                    backgroundColor: '#d9770633',
                    fill: true,
                    pointRadius: 5,
                    pointBackgroundColor: '#d97706',
                };

                if (phytoCtx && phytoData.data.length > 0) {
                    state.charts.singlePhytoChart = new Chart(phytoCtx, {
                        type: 'line',
                        data: { datasets: [phytoData] },
                        options: {
                            ...chartDefaults,
                            scales: {
                                ...chartDefaults.scales,
                                x: { ...chartDefaults.scales.x, type: 'linear', title: { display: true, text: 'Days After Application (DA-A)' } },
                                y: { ...chartDefaults.scales.y, max: 100, title: { display: true, text: '% Phytotoxicity' } }
                            },
                            plugins: { ...chartDefaults.plugins, legend: { display: false } }
                        }
                    });
                }
            }

            // Cache for AI summaries to avoid duplicate API calls
            const aiSummaryCache = new Map();

            async function getChartSummaryFromAI(chartConfig, chartTitle, seriesName, trialStatus = "Ongoing", userResult = "", extraContext = {}) {
                // Validate input
                if (!chartConfig || !chartConfig.data || !chartConfig.data.datasets) {
                    console.error('[AI Summary] Invalid chart config:', chartConfig);
                    return "Chart data not available for AI analysis.";
                }

                // Create a cache key based on chart data, title, and extra context
                const datasets = chartConfig.data.datasets.map(ds => ({
                    label: ds.label,
                    data: ds.data.map(p => ({ x: p.x, y: p.y }))
                }));
                const cacheKey = `${chartTitle}_${seriesName}_${JSON.stringify(datasets)}_${JSON.stringify(extraContext)}`;

                // Check if we have a cached summary
                if (aiSummaryCache.has(cacheKey)) {
                    console.log('Using cached AI summary for:', chartTitle);
                    return aiSummaryCache.get(cacheKey);
                }

                try {
                    const chartType = chartConfig.type;
                    const { wceData, weather, weedIds } = extraContext;

                    let weatherContext = "";
                    if (weather) {
                        weatherContext = `
                    Environmental Conditions:
                    - Temperature: ${weather.temp || 'N/A'}\u00B0C
                    - Humidity: ${weather.humidity || 'N/A'}%
                    - Rain: ${weather.rain || '0'} mm
                    (Consider these environmental factors in the efficacy analysis)`;
                    }

                    let weedIdContext = "";
                    if (weedIds && weedIds.length > 0) {
                        weedIdContext = `
                    Weed Identification Data:
                    ${weedIds.map(w => `- ${w.name} (${(w.confidence * 100).toFixed(1)}% confidence)`).join('\n')}
                    (Ensure species names in the report match these identifications interactively)`;
                    }

                    let wceContext = "";
                    if (wceData && wceData.length > 0) {
                        wceContext = `
                    Calculated Weed Control Efficiency (WCE) [((Day 0 - Final) / Day 0) * 100]:
                    ${wceData.map(d => `- ${d.species}: ${d.wce.toFixed(1)}%`).join('\n')}`;
                    }

                    const prompt = `Act as a professional Agronomist and Data Analyst. Your task is to analyze herbicide trial data and generate reports that are strictly technical, objective, and devoid of subjective adjectives like 'excellent,' 'promising,' or 'perfect.'

                    1. Data Analysis Guidelines:
                    - **Tone**: Use professional agricultural terminology (e.g., chlorosis, necrosis, desiccation, biomass reduction).
                    - **Phytotoxicity**: Describe results using specific percentage ranges and timing (e.g., '95% burndown achieved by Day 6').
                    - **Selectivity**: Explicitly identify which species were controlled and which showed resistance.
                    - **Constraint**: Never use 'Based on the data' or 'The report shows.' Speak as the investigator: 'Observations indicate...' or 'The trial confirms...'
                    
                    2. Context & Data:
                    - **Chart**: ${chartType} chart titled "${chartTitle}" for ${seriesName}.
                    - **Trial Status**: ${trialStatus}
                    - **User's Manual Verdict**: ${userResult ? userResult : "Not provided"}
                    ${weatherContext}
                    ${weedIdContext}
                    ${wceContext}

                    Data Points (x=Day, y=Value):
                    ${JSON.stringify(datasets)}

                    3. Required Report Sections:
                    - **Result Paragraph**: A single, dense paragraph summarizing the trial's performance based on the DA-A (Days After Application) timeline. Incorporate the environmental logic if relevant (e.g., "High humidity optimized uptake...").
                    - **Conclusion**: A technical summary of the formula's efficacy, specifically referencing the WCE values and species-specific susceptibility.`;

                    const geminiCall = (genAI) => genAI.models.generateContent({
                        model: state.settings.apiModel || 'gemini-2.0-flash-exp',
                        contents: [{ parts: [{ text: prompt }] }]
                    });

                    const response = await callGeminiApi(`Summarizing chart: ${chartTitle}`, geminiCall);
                    const summaryText = response.text;

                    // Cache the result
                    aiSummaryCache.set(cacheKey, summaryText);

                    return summaryText;
                } catch (error) {
                    console.error('AI Summary Error:', error);
                    return "AI summary could not be generated at this time.";
                }
            }

            async function generateComprehensivePdf(trialId, options = { withIngredients: true, withWeeds: false, chartImages: null }) {
                const trial = state.trials.find(t => t.ID === trialId);
                if (!trial) return;
                showToast('Generating PDF...', 'info');

                const { jsPDF } = window.jspdf;
                const doc = new jsPDF();
                const pageWidth = doc.internal.pageSize.getWidth();

                // --- Header ---
                doc.setFillColor(13, 148, 136); // Teal header
                doc.rect(0, 0, pageWidth, 40, 'F');
                doc.setTextColor(255, 255, 255);
                doc.setFontSize(22);
                doc.text("Herbicide Trial Report", pageWidth / 2, 25, { align: 'center' });

                doc.setTextColor(0, 0, 0);
                doc.setFontSize(16);
                doc.text(trial.FormulationName, 14, 50);

                doc.setFontSize(10);
                doc.setTextColor(100);
                const leftColX = 14;
                const rightColX = pageWidth / 2 + 10;
                let y = 60;

                doc.text(`Investigator: ${trial.InvestigatorName || 'N/A'}`, leftColX, y);
                doc.text(`Date: ${new Date(trial.Date).toLocaleDateString()}`, rightColX, y); y += 6;
                doc.text(`Location: ${trial.Location || 'N/A'}`, leftColX, y);
                doc.text(`Dosage: ${trial.Dosage || 'N/A'}`, rightColX, y); y += 6;
                doc.text(`Replication: ${trial.Replication || 'N/A'}`, leftColX, y);
                doc.text(`Result: ${trial.Result || 'N/A'}`, rightColX, y); y += 6;

                // --- Weed Species ---
                if (trial.WeedSpecies && trial.WeedSpecies.trim()) {
                    doc.setFont(undefined, 'bold');
                    doc.text(`Weed Species:`, leftColX, y);
                    doc.setFont(undefined, 'normal');
                    const weedLines = doc.splitTextToSize(trial.WeedSpecies, pageWidth - 28);
                    doc.text(weedLines, leftColX, y + 5);
                    y += (weedLines.length * 5) + 5;
                }

                y += 5; // Add spacing before weather section

                // --- Weather ---
                if (trial.Temperature) {
                    doc.setFillColor(241, 245, 249); // Slate-100
                    doc.rect(14, y - 5, pageWidth - 28, 18, 'F');
                    doc.setFont(undefined, 'bold');
                    doc.text("Weather Conditions:", 16, y);
                    doc.setFont(undefined, 'normal');
                    doc.text(`Temp: ${trial.Temperature}°C   Humidity: ${trial.Humidity}%   Wind: ${trial.Windspeed} km/h   Rain: ${trial.Rain} mm`, 16, y + 6);
                    y += 20;
                }

                y += 5; // Add spacing before weather section

                // --- Statistical Analysis (ANOVA) ---
                if (trial.StatisticsJSON) {
                    const stats = safeJsonParse(trial.StatisticsJSON);
                    if (stats.wce && stats.wce.length > 0) {
                        // Check if we have ANOVA results stored (Assuming calculateRCBD_ANOVA saves to StatisticsJSON or we run it live)
                        // For MVP, we'll run it live if possible, or assume it's saved. 
                        // To be robust, let's look for saved ANOVA results, OR simply display WCE summary stats.
                        // But the user requested ANOVA tables. 
                        // Let's assume we want to display the WCE Summary here first.

                        // Note: Full ANOVA tables are complex and usually per-species. 
                        // We will check if there is a global 'anova' field or similar, otherwise we might skip.
                        // However, I previously implemented calculateRCBD_ANOVA but didn't automate saving it to trial.StatisticsJSON yet.
                        // So checking for it might yield nothing. 
                        // CRITICAL: We need to Ensure ANOVA is calculated and available.
                        // For now, I will add the code to RENDER it if it exists.

                        if (stats.anovaResults) {
                            if (y > 220) { doc.addPage(); y = 20; }
                            doc.setFont(undefined, 'bold');
                            doc.text("Statistical Analysis (ANOVA):", 14, y);
                            y += 6;

                            // Render ANOVA Table
                            const anova = stats.anovaResults.anovaTable;
                            if (anova) {
                                const rows = [
                                    ['Treatments', anova.treatment.df, anova.treatment.ss.toFixed(2), anova.treatment.ms.toFixed(2), anova.treatment.f.toFixed(2), anova.treatment.sig],
                                    ['Blocks', anova.block.df, anova.block.ss.toFixed(2), anova.block.ms.toFixed(2), anova.block.f.toFixed(2), anova.block.sig],
                                    ['Error', anova.error.df, anova.error.ss.toFixed(2), anova.error.ms.toFixed(2), '-', '-'],
                                    ['Total', anova.total.df, anova.total.ss.toFixed(2), '-', '-', '-']
                                ];

                                doc.autoTable({
                                    startY: y,
                                    head: [['Source', 'DF', 'SS', 'MS', 'F', 'Prob']],
                                    body: rows,
                                    headStyles: { fillColor: [44, 62, 80] }, // Dark Blue
                                    theme: 'grid',
                                    styles: { fontSize: 9 }
                                });
                                y = doc.lastAutoTable.finalY + 10;
                            }
                        }
                    }
                }



                // --- Conclusion & Notes ---
                // (Previous code continued...)
                doc.setFont(undefined, 'bold');
                doc.text("Conclusion:", 14, y);
                doc.setFont(undefined, 'normal');
                const conclusionLines = doc.splitTextToSize(trial.Conclusion || 'N/A', pageWidth - 28);
                doc.text(conclusionLines, 14, y + 5);
                y += (conclusionLines.length * 5) + 8;

                doc.setFont(undefined, 'bold');
                doc.text("Notes:", 14, y);
                doc.setFont(undefined, 'normal');
                const notesLines = doc.splitTextToSize(trial.Notes || 'N/A', pageWidth - 28);
                doc.text(notesLines, 14, y + 5);
                y += (notesLines.length * 5) + 12;

                // --- Efficacy Logic ---
                const summaries = safeJsonParse(trial.AISummariesJSON, {});
                if (options.withEfficacy !== false) {
                    if (summaries.cover || options.chartImages?.cover) {
                        if (y > 200) { doc.addPage(); y = 20; }
                        doc.setFont(undefined, 'bold');
                        doc.text("Efficacy Analysis:", 14, y);
                        y += 8;

                        if (options.chartImages?.cover) {
                            try {
                                doc.addImage(options.chartImages.cover, 'PNG', 14, y, 180, 90);
                                y += 95;
                            } catch (e) { }
                        }

                        if (summaries.cover) {
                            doc.setFont(undefined, 'normal');
                            doc.setFontSize(9);
                            const maxWidth = pageWidth - 28; // Left margin 14 + right margin 14
                            const lines = doc.splitTextToSize("Analysis: " + summaries.cover, maxWidth);
                            const textHeight = lines.length * 4; // 4mm per line for 9pt font

                            // Check if text will fit on current page (leaving 20mm bottom margin)
                            if (y + textHeight > 280) {
                                doc.addPage();
                                y = 20;
                            }

                            doc.text(lines, 14, y, { maxWidth: maxWidth, align: 'left' });
                            y += textHeight + 10;
                        }
                    }

                    if (summaries.phyto || options.chartImages?.phyto) {
                        if (y > 200) { doc.addPage(); y = 20; }

                        if (options.chartImages?.phyto) {
                            try {
                                doc.setFont(undefined, 'bold');
                                doc.setFontSize(10);
                                doc.text("Phytotoxicity Analysis:", 14, y);
                                y += 5;
                                doc.addImage(options.chartImages.phyto, 'PNG', 14, y, 180, 90);
                                y += 95;
                            } catch (e) { }
                        }

                        if (summaries.phyto) {
                            doc.setFont(undefined, 'normal');
                            doc.setFontSize(9);
                            const maxWidth = pageWidth - 28; // Left margin 14 + right margin 14
                            const lines = doc.splitTextToSize("Analysis: " + summaries.phyto, maxWidth);
                            const textHeight = lines.length * 4; // 4mm per line for 9pt font

                            // Check if text will fit on current page (leaving 20mm bottom margin)
                            if (y + textHeight > 280) {
                                doc.addPage();
                                y = 20;
                            }

                            doc.text(lines, 14, y, { maxWidth: maxWidth, align: 'left' });
                            y += textHeight + 10;
                        }
                    }
                }

                // --- Weed Status Timeline ---
                if (options.withTimeline) {
                    const efficacyData = safeJsonParse(trial.EfficacyDataJSON);
                    if (efficacyData.length > 0) {
                        if (y > 220) { doc.addPage(); y = 20; }
                        doc.setFontSize(14);
                        doc.setFont(undefined, 'bold');
                        doc.text("Weed Status Timeline", 14, y);
                        y += 8;

                        const timelineRows = efficacyData.flatMap(obs => (obs.weedDetails || []).map(wd => [obs.daa, wd.species, wd.status, wd.notes]));
                        doc.autoTable({
                            startY: y,
                            head: [['DA-A', 'Species', 'Status', 'Notes']],
                            body: timelineRows,
                            headStyles: { fillColor: [13, 148, 136] },
                            theme: 'striped',
                            styles: { fontSize: 8 }
                        });
                        y = doc.lastAutoTable.finalY + 12;
                    }
                }

                doc.setFontSize(10);
                doc.setTextColor(0, 0, 0);

                // --- Ingredients (Optional) ---
                if (options.withIngredients) {
                    const formulation = state.formulations.find(f => f.ID === trial.FormulationID);
                    if (formulation) {
                        const ingredients = safeJsonParse(formulation.IngredientsJSON);
                        doc.autoTable({
                            startY: y,
                            head: [['Ingredient', 'Quantity', 'Unit']],
                            body: ingredients.map(i => [i.name, i.quantity, i.unit]),
                            headStyles: { fillColor: [13, 148, 136] },
                            theme: 'striped'
                        });
                        y = doc.lastAutoTable.finalY + 10;
                    }
                }

                // --- Photos ---
                const photos = safeJsonParse(trial.PhotoURLs);
                if (photos.length > 0) {
                    if (y > 200) { doc.addPage(); y = 20; }
                    doc.setFontSize(14);
                    doc.setFont(undefined, 'bold');
                    doc.text("Photo Log", 14, y);
                    y += 10;

                    let xOffset = 14;
                    for (let i = 0; i < photos.length; i++) {
                        const p = photos[i];
                        if (!p.url) continue;
                        try {
                            const imgData = await getImageAsResizedBase64(p.url, 300); // Helper to get Base64
                            if (imgData) {
                                if (xOffset + 50 > pageWidth) { xOffset = 14; y += 60; }
                                if (y > 250) { doc.addPage(); y = 20; xOffset = 14; }

                                doc.addImage(imgData, 'JPEG', xOffset, y, 50, 50);
                                doc.setFontSize(8);
                                // If label exists, show label. If not, fallback to date with prefix.
                                const primaryLabel = p.label ? p.label : (p.date ? `Photo: ${p.date}` : '-');
                                doc.text(primaryLabel, xOffset, y + 54);

                                // Only show secondary date if it's explicitly requested AND a label exists (to avoid double date)
                                if (p.label && options.showPhotoDates) {
                                    doc.text(p.date || '', xOffset, y + 58);
                                }
                                xOffset += 60;
                            }
                        } catch (e) { console.warn("Could not add image to PDF", e); }
                    }
                    y += 70;
                }

                // --- Weeds (Optional) ---
                if (options.withWeeds) {
                    const weedPhotos = safeJsonParse(trial.WeedPhotosJSON);
                    if (weedPhotos.length > 0) {
                        doc.addPage();
                        doc.setFontSize(16);
                        doc.text("Weed Identification", 14, 20);
                        let weedY = 30;

                        // Add weed species list at the top
                        if (trial.WeedSpecies && trial.WeedSpecies.trim()) {
                            doc.setFontSize(10);
                            doc.setFont(undefined, 'bold');
                            doc.text("Weed Species:", 14, weedY);
                            doc.setFont(undefined, 'normal');
                            const weedSpeciesLines = doc.splitTextToSize(trial.WeedSpecies, pageWidth - 28);
                            doc.text(weedSpeciesLines, 14, weedY + 5);
                            weedY += (weedSpeciesLines.length * 5) + 15;
                        }

                        for (const p of weedPhotos) {
                            if (!p.url) continue;
                            if (weedY > 220) { doc.addPage(); weedY = 20; }
                            try {
                                const imgData = await getImageAsResizedBase64(p.url, 300);
                                if (imgData) {
                                    doc.addImage(imgData, 'JPEG', 14, weedY, 60, 60);
                                    const bestMatch = p.identifications?.[0];
                                    doc.setFontSize(12);
                                    doc.text(bestMatch?.name || 'Unknown', 80, weedY + 10);
                                    doc.setFontSize(10);
                                    doc.text(`Common: ${bestMatch?.commonNames?.[0] || '-'}`, 80, weedY + 20);
                                    doc.text(`Confidence: ${bestMatch?.confidence ? (bestMatch.confidence * 100).toFixed(1) + '%' : 'N/A'}`, 80, weedY + 30);
                                    weedY += 70;
                                }
                            } catch (e) { }
                        }
                    }
                }

                doc.save(`${trial.FormulationName}_Report.pdf`);
                showToast('PDF downloaded.', 'success');
            }

            // --- Helper for PDF generation ---
            async function getImageAsResizedBase64(url, width = 800) {
                if (url.startsWith('data:image')) return url;
                // Use a proxy to avoid CORS if needed, or fetch directly if allowed
                const proxyUrl = `https://images.weserv.nl/?url=${encodeURIComponent(url)}&w=${width}&output=jpg&q=80`;
                try {
                    const res = await fetch(proxyUrl);
                    const blob = await res.blob();
                    return new Promise((resolve) => {
                        const reader = new FileReader();
                        reader.onloadend = () => resolve(reader.result);
                        reader.readAsDataURL(blob);
                    });
                } catch (e) {
                    console.error("Image fetch failed", e);
                    return null;
                }
            }

            async function generateProfessionalPdfReport() {
                const trials = state.selectedTrials.map(id => state.trials.find(t => t.ID === id)).filter(Boolean);
                if (trials.length === 0) return showToast('Select at least one trial to compare.', 'error');

                showToast('Generating Professional Report...', 'info');

                // Ensure comparison view is up to date
                runComparison();

                // Wait for chart
                setTimeout(async () => {
                    const canvas = document.getElementById('compare-chart');
                    if (!canvas) return;

                    const { jsPDF } = window.jspdf;
                    const doc = new jsPDF('l', 'mm', 'a4'); // Landscape A4
                    const pageWidth = doc.internal.pageSize.getWidth();

                    // Header
                    doc.setFillColor(13, 148, 136); // Teal 600
                    doc.rect(0, 0, pageWidth, 20, 'F');
                    doc.setTextColor(255, 255, 255);
                    doc.setFontSize(16);
                    doc.setFont(undefined, 'bold');
                    doc.text("Comparative Field Trial Report", 14, 13);
                    doc.setFontSize(10);
                    doc.text(`Generated: ${new Date().toLocaleDateString()}`, pageWidth - 14, 13, { align: 'right' });

                    // Chart
                    const imgData = canvas.toDataURL('image/png');
                    doc.addImage(imgData, 'PNG', 10, 30, pageWidth - 20, 100);

                    // Table
                    const head = [['Metric', ...trials.map(t => t.FormulationName)]];

                    // Reconstruct table data for PDF
                    const rows = [
                        ['Investigator', ...trials.map(t => t.InvestigatorName || '-')],
                        ['Location', ...trials.map(t => t.Location || '-')],
                        ['Date', ...trials.map(t => new Date(t.Date).toLocaleDateString())],
                        ['Dosage', ...trials.map(t => t.Dosage || '-')],
                        ['Cost/ha', ...trials.map(t => {
                            const f = state.formulations.find(f => f.ID === t.FormulationID);
                            return f ? CURRENCY_SYMBOL + parseFloat(f.EstimatedCost || 0).toFixed(2) : '-';
                        })],
                        ['Result', ...trials.map(t => t.Result || '-')],
                        ['Weed Species', ...trials.map(t => t.WeedSpecies || '-')],
                        ['AI Cover Analysis', ...trials.map(t => {
                            const s = safeJsonParse(t.AISummariesJSON, {});
                            return s.cover || '-';
                        })],
                        ['AI Phyto Analysis', ...trials.map(t => {
                            const s = safeJsonParse(t.AISummariesJSON, {});
                            return s.phyto || '-';
                        })],
                        ['Weather', ...trials.map(t => `${t.Temperature || ''}C, ${t.Rain || ''}mm`)],
                    ];

                    // Add Last Control % if chart is showing a weed
                    const weedSelect = document.getElementById('compare-weed-filter');
                    if (weedSelect && weedSelect.value) {
                        const selectedWeed = weedSelect.value;
                        const controlRow = [`Final ${selectedWeed} Cover%`, ...trials.map(t => {
                            const eff = safeJsonParse(t.EfficacyDataJSON);
                            const last = eff.sort((a, b) => b.daa - a.daa)[0];
                            const detail = last ? (last.weedDetails || []).find(d => d.species === selectedWeed) : null;
                            return detail ? detail.cover + '%' : 'N/A';
                        })];
                        rows.push(controlRow);
                    }

                    doc.autoTable({
                        startY: 140,
                        head: head,
                        body: rows,
                        headStyles: { fillColor: [13, 148, 136] },
                        theme: 'grid',
                        styles: { fontSize: 10, cellPadding: 2 }
                    });

                    // Footer
                    const pageCount = doc.internal.getNumberOfPages();
                    for (let i = 1; i <= pageCount; i++) {
                        doc.setPage(i);
                        doc.setFontSize(8);
                        doc.setTextColor(150);
                        doc.text(`Page ${i} of ${pageCount} - Weedicide Herbicide App`, pageWidth / 2, doc.internal.pageSize.getHeight() - 10, { align: 'center' });
                    }

                    doc.save('Comparative_Report_Pro.pdf');
                    showToast('Report downloaded.', 'success');
                }, 1000);
            }

            async function generatePpt(trialId) {
                const trial = state.trials.find(t => t.ID === trialId);
                if (!trial) return;
                showToast('Generating PowerPoint...', 'info');

                const pptx = new PptxGenJS();
                pptx.layout = 'LAYOUT_16x9';

                // Slide 1: Title
                const slide1 = pptx.addSlide();
                slide1.addText('Herbicide Trial Report', { x: 1, y: 1, w: '80%', fontSize: 24, bold: true, color: '008080' });
                slide1.addText(trial.FormulationName, { x: 1, y: 2, w: '80%', fontSize: 18 });
                slide1.addText(`Investigator: ${trial.InvestigatorName}`, { x: 1, y: 3, fontSize: 14 });
                slide1.addText(`Date: ${new Date(trial.Date).toLocaleDateString()}`, { x: 1, y: 3.5, fontSize: 14 });

                // Slide 2: Photos
                const photos = safeJsonParse(trial.PhotoURLs).slice(0, 4);
                if (photos.length > 0) {
                    const slide2 = pptx.addSlide();
                    slide2.addText('Field Photos', { x: 0.5, y: 0.5, fontSize: 18, color: '008080' });

                    let xPos = 0.5;
                    for (const p of photos) {
                        if (p.url) {
                            slide2.addImage({ path: p.url, x: xPos, y: 1.5, w: 3, h: 3 });
                            xPos += 3.2;
                        }
                    }
                }

                pptx.writeFile({ fileName: `${trial.FormulationName}_Presentation.pptx` });
                showToast('PPT downloaded.', 'success');
            }

            function exportJson() {
                const dataStr = JSON.stringify(state, null, 2);
                const blob = new Blob([dataStr], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `herbicide_data_${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }

            async function exportWithPhotos() {
                showToast('Creating ZIP archive...', 'info');
                const zip = new JSZip();
                zip.file("data.json", JSON.stringify(state, null, 2));

                const photosFolder = zip.folder("photos");
                const allPhotos = state.trials.flatMap(t => safeJsonParse(t.PhotoURLs));

                for (let i = 0; i < allPhotos.length; i++) {
                    const p = allPhotos[i];
                    if (p.url) {
                        try {
                            const imgData = await getImageAsResizedBase64(p.url, 1000);
                            if (imgData) {
                                // Remove data:image/jpeg;base64, prefix
                                const base64Data = imgData.split(',')[1];
                                photosFolder.file(`photo_${i}.jpg`, base64Data, { base64: true });
                            }
                        } catch (e) { }
                    }
                }

                const content = await zip.generateAsync({ type: "blob" });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(content);
                a.download = `herbicide_data_complete_${new Date().toISOString().split('T')[0]}.zip`;
                a.click();
                showToast('ZIP downloaded.', 'success');
            }

            function exportStandaloneHTML() {
                showToast('Generating standalone HTML...', 'info');
                // Logic to bundle state into HTML file
                const html = document.documentElement.outerHTML.replace('const state = {', `const state = ${JSON.stringify(state)}; //`);
                const blob = new Blob([html], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'herbicide-app-standalone.html';
                a.click();
            }

            function handleImport(event) {
                const file = document.getElementById('import-file-input').files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        if (file.name.endsWith('.json')) {
                            const importedState = JSON.parse(e.target.result);
                            state = { ...state, ...importedState };
                            saveStateToLocalStorage(); // Mock persistence
                            initializeApp(false);
                            showToast('Data imported successfully.', 'success');
                        } else {
                            showToast('ZIP import not fully supported in this demo version.', 'info');
                        }
                    } catch (err) {
                        showToast('Invalid file format.', 'error');
                    }
                };
                reader.readAsText(file);
            }

            function saveStateToLocalStorage() {
                // Backup state to localStorage for offline recovery
                // Uses safeStringify to avoid circular reference errors
                try {
                    localStorage.setItem('backupState', safeStringify(state));
                    console.log('State backup saved successfully');
                } catch (e) {
                    console.warn('Failed to save state backup to localStorage:', e.message);
                    // Fallback: try to save only critical data
                    try {
                        const criticalData = {
                            settings: state.settings,
                            filterState: state.filterState,
                            aiChatHistory: state.aiChatHistory
                        };
                        localStorage.setItem('backupState', JSON.stringify(criticalData));
                        console.log('Critical data backup saved as fallback');
                    } catch (fallbackError) {
                        console.error('All backup attempts failed:', fallbackError);
                    }
                }
            }

            async function clearAllData(confirm = false) {
                if (!confirm) {
                    showConfirmation('Delete Everything?', 'This will wipe all data from the database.', () => clearAllData(true));
                    return;
                }

                // In a real app, this would make API calls to delete everything
                state.trials = [];
                state.formulations = [];
                state.ingredients = [];
                state.organisations = [];
                state.syncQueue = [];
                saveSyncQueue();

                await apiCall('clearAllData', {}, false); // Assuming backend support
                initializeApp();
                showToast('All data cleared.', 'success');
            }

            function runComparison() {
                const weedSelect = document.getElementById('compare-weed-filter');
                const metricSelect = document.getElementById('compare-metric-filter');

                if (!weedSelect) return;

                const selectedWeed = weedSelect.value;
                const metric = metricSelect ? metricSelect.value : 'cover'; // 'cover' or 'phyto'

                // --- 1. CHART RENDERING ---
                if (!selectedWeed && metric === 'cover') {
                    document.getElementById('compare-chart-title').textContent = "Please select a weed species to compare.";
                    return;
                }

                const ctx = document.getElementById('compare-chart');
                if (ctx) {
                    if (state.charts.compareChart) state.charts.compareChart.destroy();

                    const trialsToCompare = state.selectedTrials.map(id => state.trials.find(t => t.ID === id)).filter(Boolean);

                    const datasets = trialsToCompare.map((t, i) => {
                        const efficacy = safeJsonParse(t.EfficacyDataJSON);
                        let dataPoints = [];

                        if (metric === 'phyto') {
                            dataPoints = efficacy.map(obs => ({ x: obs.daa, y: obs.phyto })).filter(p => p.x != null && p.y != null).sort((a, b) => a.x - b.x);
                        } else {
                            dataPoints = efficacy.map(obs => {
                                const detail = (obs.weedDetails || []).find(d => d.species === selectedWeed);
                                return detail ? { x: obs.daa, y: detail.cover } : null;
                            }).filter(Boolean).sort((a, b) => a.x - b.x);
                        }

                        const colors = ['#0d9488', '#d97706', '#2563eb', '#dc2626', '#7c3aed', '#db2777'];
                        return {
                            label: t.FormulationName,
                            data: dataPoints,
                            borderColor: colors[i % colors.length],
                            backgroundColor: colors[i % colors.length],
                            fill: false,
                            tension: 0.2
                        };
                    });

                    state.charts.compareChart = new Chart(ctx, {
                        type: 'line',
                        data: { datasets },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: { type: 'linear', title: { display: true, text: 'Days After Application (DA-A)' } },
                                y: { beginAtZero: true, max: 100, title: { display: true, text: metric === 'phyto' ? '% Phytotoxicity' : '% Cover' } }
                            },
                            plugins: {
                                legend: { position: 'top' },
                                tooltip: { mode: 'index', intersect: false }
                            }
                        }
                    });

                    const metricTitle = metric === 'phyto' ? '% Phytotoxicity Comparison' : `% Cover Comparison: ${selectedWeed}`;
                    document.getElementById('compare-chart-title').textContent = metricTitle;
                }

                // --- 2. TABLE RENDERING ---
                const tableContainer = document.getElementById('compare-table-container');
                if (tableContainer) {
                    const trials = state.selectedTrials.map(id => state.trials.find(t => t.ID === id)).filter(Boolean);
                    if (trials.length === 0) {
                        tableContainer.innerHTML = '<p class="text-gray-500">No trials selected.</p>';
                        return;
                    }

                    // Define rows for comparison
                    const rows = [
                        { label: 'Formulation', getValue: t => t.FormulationName },
                        { label: 'Investigator', getValue: t => t.InvestigatorName || '-' },
                        { label: 'Date', getValue: t => new Date(t.Date).toLocaleDateString() },
                        { label: 'Dosage', getValue: t => t.Dosage || '-' },
                        {
                            label: 'Cost/ha', getValue: t => {
                                const f = state.formulations.find(f => f.ID === t.FormulationID);
                                return f ? CURRENCY_SYMBOL + parseFloat(f.EstimatedCost || 0).toFixed(2) : '-';
                            }
                        },
                        { label: 'Result', getValue: t => `<span class="px-2 py-0.5 rounded text-xs font-bold ${t.Result === 'Excellent' ? 'bg-green-100 text-green-800' : t.Result === 'Poor' ? 'bg-red-100 text-red-800' : 'bg-gray-100'}">${t.Result || '-'}</span>` },
                        { label: 'Weed Species', getValue: t => t.WeedSpecies || '-' },
                        { label: 'Weather', getValue: t => `${t.Temperature || '-'}°C, ${t.Rain || '-'}mm` },
                        {
                            label: 'AI Cover Analysis', getValue: t => {
                                const s = safeJsonParse(t.AISummariesJSON, {});
                                return s.cover ? `<span class="whitespace-pre-wrap text-xs block min-w-[200px]">${sanitizeHTML(s.cover)}</span>` : '-';
                            }
                        },
                        {
                            label: 'AI Phyto Analysis', getValue: t => {
                                const s = safeJsonParse(t.AISummariesJSON, {});
                                return s.phyto ? `<span class="whitespace-pre-wrap text-xs block min-w-[200px]">${sanitizeHTML(s.phyto)}</span>` : '-';
                            }
                        },
                    ];

                    let html = `<table class="min-w-full divide-y divide-gray-200 border text-sm">`;
                    html += `<thead class="bg-gray-50"><tr><th class="px-4 py-3 text-left font-medium text-gray-500 w-1/4">Metric</th>${trials.map(t => `<th class="px-4 py-3 text-left font-bold text-slate-800">${sanitizeHTML(t.FormulationName)}</th>`).join('')}</tr></thead>`;
                    html += `<tbody class="bg-white divide-y divide-gray-200">`;

                    rows.forEach(row => {
                        html += `<tr><td class="px-4 py-3 font-medium text-gray-900 bg-gray-50/50">${row.label}</td>${trials.map(t => `<td class="px-4 py-3 text-gray-600">${row.getValue(t)}</td>`).join('')}</tr>`;
                    });

                    // Add summary stats row if weed selected
                    if (selectedWeed && metric === 'cover') {
                        html += `<tr><td class="px-4 py-3 font-medium text-teal-800 bg-teal-50">Final ${sanitizeHTML(selectedWeed)} Control</td>${trials.map(t => {
                            const eff = safeJsonParse(t.EfficacyDataJSON);
                            const last = eff.sort((a, b) => b.daa - a.daa)[0];
                            const detail = last ? (last.weedDetails || []).find(d => d.species === selectedWeed) : null;
                            const cover = detail ? parseFloat(detail.cover) : -1;
                            return `<td class="px-4 py-3 font-bold ${cover < 10 && cover >= 0 ? 'text-green-600' : 'text-amber-600'}">${cover >= 0 ? cover.toFixed(1) + '%' : 'N/A'}</td>`;
                        }).join('')}</tr>`;
                    }

                    html += `</tbody></table>`;
                    tableContainer.innerHTML = html;
                }
            }

            // --- MISSING HELPERS ---
            async function fetchWeather(lat, lon, date) {
                let url = ''; // Define outer scope for error logging
                try {
                    // 1. Strict Input Validation
                    const latNum = parseFloat(lat);
                    const lonNum = parseFloat(lon);
                    if (!lat || !lon || isNaN(latNum) || isNaN(lonNum)) {
                        console.error("fetchWeather: Invalid coordinates:", lat, lon);
                        return null;
                    }
                    // Validate date format YYYY-MM-DD
                    const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
                    if (!date || typeof date !== 'string' || !dateRegex.test(date)) {
                        console.error("fetchWeather: Invalid date format:", date);
                        return null;
                    }

                    const targetDate = new Date(date);
                    if (isNaN(targetDate.getTime())) {
                        console.error("fetchWeather: Invalid Date object:", date);
                        return null;
                    }

                    const today = new Date();
                    today.setHours(0, 0, 0, 0);

                    // Calculate age of date in days
                    const diffTime = today - targetDate;
                    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

                    // Logic:
                    // 1. > 14 days ago: Use Archive API (Forecast API implicit history is limited/unreliable beyond ~30 days)
                    // 2. Recent Past (<= 14 days) & Future: Use Forecast API

                    const isOldArchive = diffDays > 14;
                    const dateStr = date; // YYYY-MM-DD

                    if (isOldArchive) {
                        url = `https://archive-api.open-meteo.com/v1/archive?latitude=${lat}&longitude=${lon}&start_date=${dateStr}&end_date=${dateStr}&daily=temperature_2m_max,relative_humidity_2m_mean,wind_speed_10m_max,rain_sum&timezone=auto`;
                    } else {
                        // Use Forecast API (it automatically covers recent past up to 92 days if specific dates are requested)
                        url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&daily=temperature_2m_max,relative_humidity_2m_mean,wind_speed_10m_max,rain_sum&start_date=${dateStr}&end_date=${dateStr}&timezone=auto`;
                    }

                    const res = await fetch(url);
                    if (!res.ok) {
                        const errData = await res.json().catch(() => ({}));
                        console.error('Weather API Error Detail:', errData);
                        throw new Error(`Weather API Error: ${res.status}${errData.reason ? ' - ' + errData.reason : ''}`);
                    }
                    const data = await res.json();

                    if (data.daily && data.daily.time && data.daily.time.length > 0) {
                        console.log('Weather API Response Dates:', data.daily.time, 'Looking for:', dateStr);

                        // Find the index that matches our requested date
                        // The API returns an array, and sometimes handles timezones by shifting the day.
                        // We trust the query 'start_date' usually, but finding the exact string match is safest.
                        const index = data.daily.time.findIndex(t => t === dateStr);

                        // Fallback: Use 0 if single day requested and match not found (typical response)
                        // But if 0 is "Today" and we asked for "Yesterday", we must be careful.
                        // If index is -1, it means the API didn't return the requested date.

                        const safeIndex = index !== -1 ? index : 0; // WARNING: This might be the bug if index is -1

                        if (index === -1) {
                            console.warn('Weather date mismatch! API returned:', data.daily.time[0], 'Expected:', dateStr);
                        }

                        // Sanity check: if returned date is not what we asked for, and we are in strict mode
                        if (index === -1 && data.daily.time[0] !== dateStr) {
                            // If the mismatch is significant, return null.
                            if (Math.abs(new Date(data.daily.time[0]) - targetDate) > 86400000) {
                                console.error('Weather date mismatch too large. Aborting.');
                                return null;
                            }
                        }

                        return {
                            temp: data.daily.temperature_2m_max[safeIndex],
                            humidity: data.daily.relative_humidity_2m_mean[safeIndex],
                            wind: data.daily.wind_speed_10m_max[safeIndex],
                            rain: data.daily.rain_sum[safeIndex]
                        };
                    }
                    return null;
                } catch (e) {
                    console.error("Weather fetch failed:", e);
                    console.error("Failed URL:", url);
                    showToast('Could not fetch weather data.', 'error');
                    return null;
                }
            }

            async function fetchWeatherForTrialDate() {
                const location = document.querySelector('[name="location"]').value;
                const date = document.querySelector('[name="date"]').value;
                if (!location || !date) return showToast('Enter location and date first.', 'error');

                let lat, lon;
                if (location.includes(',')) {
                    [lat, lon] = location.split(',').map(s => s.trim());
                }

                if (lat && lon) {
                    showToast('Fetching weather...', 'info');
                    const w = await fetchWeather(lat, lon, date);
                    if (w) {
                        document.querySelector('[name="temperature"]').value = w.temp || '';
                        document.querySelector('[name="humidity"]').value = w.humidity || '';
                        document.querySelector('[name="windspeed"]').value = w.wind || '';
                        document.querySelector('[name="rain"]').value = w.rain || '';
                        showToast('Weather updated from Open-Meteo.', 'success');
                    }
                } else {
                    showToast('Invalid location format (lat,lon required).', 'error');
                }
            }

            function fetchWeatherForObservation(index) {
                // Determine context: are we inside the modal or card?
                // This logic might need to traverse DOM to find date/location
                // For now, keep as placeholder or implement if observation has location context
                showToast('Observation weather fetch not linked to location yet.', 'info');
            }

            async function handleToggleCompleted(id, isChecked) {
                const trial = state.trials.find(t => t.ID === id);
                if (trial) {
                    trial.IsCompleted = isChecked;
                    const result = await apiCall('updateTrialRecord', { ID: id, IsCompleted: isChecked }, false);
                    const updatedRecord = result?.record || (result?.ID ? result : null);
                    if (updatedRecord) {
                        const idx = state.trials.findIndex(t => t.ID === updatedRecord.ID);
                        if (idx > -1) state.trials[idx] = updatedRecord;
                        if (state.currentPage === 'dashboard') render.dashboard();
                        else if (state.currentPage === 'trials') applyFilters();
                    }
                }
            }

            function handleFinalizeTrial(id) {
                const trial = state.trials.find(t => t.ID === id);
                if (!trial) return;
                trial.ControlFinalized = true;
                trial.FinalizationDate = new Date().toISOString().split('T')[0];
                // Calc days
                const days = Math.floor((new Date() - new Date(trial.Date)) / (1000 * 60 * 60 * 24));
                trial.FinalControlDuration = days < 0 ? 0 : days;

                apiCall('updateTrialRecord', {
                    id,
                    ControlFinalized: true,
                    FinalizationDate: trial.FinalizationDate,
                    FinalControlDuration: trial.FinalControlDuration
                }, false);

                applyFilters(); // Re-render trial card with persistent sorting
                showToast('Trial control finalized.', 'success');
            }

            function handleRestartTrial(id) {
                const trial = state.trials.find(t => t.ID === id);
                if (!trial) return;
                trial.ControlFinalized = false;
                trial.FinalControlDuration = null;
                trial.FinalizationDate = null;

                apiCall('updateTrialRecord', {
                    id,
                    ControlFinalized: false,
                    FinalizationDate: null,
                    FinalControlDuration: null
                }, false);
                applyFilters(); // Re-render trial card with persistent sorting
                showToast('Trial counting restarted.', 'success');
            }

            async function analyzeTrialEfficacy(id) {
                const trial = state.trials.find(t => t.ID === id);
                if (!trial) return showToast('Trial not found.', 'error');

                console.log('Analyzing trial:', id, 'Trial data:', trial);

                const photos = safeJsonParse(trial.PhotoURLs);
                console.log('Photos found:', photos.length, photos);

                if (photos.length === 0) {
                    return showToast('No photos to analyze in this trial. Add photos first.', 'error');
                }

                // Check for API keys
                if (!state.settings.apiKeys || state.settings.apiKeys.length === 0) {
                    return showToast('No API keys configured. Go to Settings to add a Gemini API key.', 'error');
                }

                const confirmRun = confirm(`This will analyze ${photos.length} photo(s) for efficacy data using ${photos.length} API call(s). Continue?`);
                if (!confirmRun) return;

                showToast(`Analyzing ${photos.length} photo(s) for efficacy...`, 'info');

                let efficacyData = safeJsonParse(trial.EfficacyDataJSON);
                let aiAnalysisComplete = false;
                let photosAnalyzed = 0;

                for (const photo of photos) {
                    try {
                        // Skip photos that already have efficacy data linked
                        const alreadyAnalyzed = efficacyData.some(e => e.photoUrl === photo.url);
                        if (alreadyAnalyzed) {
                            console.log('Skipping already analyzed photo:', photo.url);
                            continue;
                        }

                        // Need to fetch the photo as base64 for analysis
                        const photoNum = photos.indexOf(photo) + 1;
                        console.log(`[Analysis] Processing photo ${photoNum}/${photos.length}`);
                        showToast(`Analyzing photo ${photoNum}/${photos.length}...`, 'info');

                        // Fetch photo and convert to base64
                        const photoData = await fetchPhotoAsBase64(photo.url);
                        if (!photoData) {
                            console.error(`[Analysis] Skipping photo ${photoNum} - fetch failed`);
                            continue;
                        }

                        console.log(`[Analysis] Sending photo ${photoNum} to Gemini AI...`);
                        const efficacyResult = await analyzePhotoForEfficacy(photoData.fileData, photoData.mimeType);
                        if (efficacyResult) {
                            const observationDate = new Date(photo.date || trial.Date);
                            const trialDate = new Date(trial.Date);
                            const daaValue = Math.round((observationDate.getTime() - trialDate.getTime()) / (1000 * 60 * 60 * 24));
                            const daa = daaValue >= 0 ? daaValue : 0;

                            efficacyData.push({
                                date: observationDate.toISOString().split('T')[0],
                                daa,
                                phyto: efficacyResult.phyto,
                                notes: `AI analysis from photo taken on ${observationDate.toLocaleDateString()}`,
                                photoUrl: photo.url,
                                weedDetails: efficacyResult.weedDetails,
                            });
                            aiAnalysisComplete = true;
                            photosAnalyzed++;
                            console.log(`[Analysis] ✔ Photo ${photoNum} complete | Total analyzed: ${photosAnalyzed}`);
                        } else {
                            console.warn(`[Analysis] Photo ${photoNum} returned no data`);
                        }
                    } catch (err) {
                        console.error(`[Analysis] Photo analysis failed:`, err);
                        showToast(`Analysis failed: ${err.message}`, 'error');
                        if (err.message.includes('QUOTA_EXCEEDED') || err.message.includes('ALL_KEYS_EXHAUSTED')) {
                            console.error('[Analysis] Quota exhausted - stopping analysis');
                            showToast('API Quota exhausted. Try again later.', 'error');
                            break;
                        }
                    }
                }

                console.log(`[Analysis] Complete | Photos analyzed: ${photosAnalyzed} | AI complete: ${aiAnalysisComplete}`);

                if (aiAnalysisComplete) {
                    trial.EfficacyDataJSON = JSON.stringify(efficacyData);
                    trial.AISummariesJSON = '{}'; // Clear cached summaries

                    const payloadSize = Math.round(trial.EfficacyDataJSON.length / 1024);
                    console.log(`[Analysis] Saving results to spreadsheet | Payload: ${payloadSize}KB | Records: ${efficacyData.length}`);

                    showToast('Saving analysis results to spreadsheet...', 'info');

                    let saveAttempts = 0;
                    let result = null;

                    while (saveAttempts < 2 && !result) {
                        try {
                            result = await apiCall('updateTrialRecord', {
                                ID: id,
                                EfficacyDataJSON: trial.EfficacyDataJSON,
                                AISummariesJSON: '{}'
                            }, true);

                            if (result && !result._errType) {
                                console.log('[Analysis] ✅ Save successful');
                                // TRIGGER STATS UPDATE
                                saveTrialStatistics(id);
                                break;
                            } else if (result && result._errType) {
                                throw new Error(result.message);
                            }
                        } catch (err) {
                            saveAttempts++;
                            console.error(`[Analysis] Save attempt ${saveAttempts} failed:`, err);

                            if (saveAttempts < 2) {
                                showToast(`Save failed. Retrying (${saveAttempts}/2)...`, 'info');
                                await new Promise(resolve => setTimeout(resolve, 3000));
                            }
                        }
                    }

                    if (result && !result._errType) {
                        showToast(`Efficacy analysis complete! Analyzed ${photosAnalyzed} photo(s). Opening report...`, 'success');
                        applyFilters();
                        // Open the trial detail view to show the analysis results
                        setTimeout(() => openTrialDetail(id), 500);
                    } else {
                        console.error('[Analysis] All save attempts failed');
                        showToast(`Analysis completed but failed to save to spreadsheet. Data size: ${payloadSize}KB. Try analyzing fewer photos at once.`, 'error');
                        // Save locally so work isn't lost
                        localStorage.setItem(`temp_analysis_${id}`, trial.EfficacyDataJSON);
                        console.log(`[Analysis] Results backed up to localStorage: temp_analysis_${id}`);
                    }
                } else {
                    console.log('[Analysis] No new photos analyzed');
                    showToast('No new photos to analyze. All photos already have efficacy data.', 'info');
                    // Still open the trial detail to show existing data
                    openTrialDetail(id);
                }
            }

            // Helper function to fetch a photo URL and convert to base64
            async function fetchPhotoAsBase64(url) {
                try {
                    console.log(`[Photo Fetch] Starting fetch for: ${url}`);
                    // Use the proxy to avoid CORS issues
                    const proxiedUrl = `https://images.weserv.nl/?url=${encodeURIComponent(url)}&output=jpg`;
                    const fetchStart = Date.now();
                    const response = await fetch(proxiedUrl);

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const blob = await response.blob();
                    const fetchTime = ((Date.now() - fetchStart) / 1000).toFixed(2);
                    console.log(`[Photo Fetch] Downloaded in ${fetchTime}s | Size: ${Math.round(blob.size / 1024)}KB`);

                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = () => {
                            console.log(`[Photo Fetch] Converted to Base64 | Total: ${((Date.now() - fetchStart) / 1000).toFixed(2)}s`);
                            resolve({
                                fileData: reader.result,
                                mimeType: blob.type || 'image/jpeg'
                            });
                        };
                        reader.onerror = reject;
                        reader.readAsDataURL(blob);
                    });
                } catch (error) {
                    console.error(`[Photo Fetch] FAILED for ${url}:`, error.message);
                    showToast(`Failed to fetch photo: ${error.message}`, 'error');
                    return null;
                }
            }

            // --- PHOTO COMPRESSION FOR PDF (Handles 50+ photos efficiently) ---
            async function compressImageForPDF(base64Data, maxWidth = 800, maxHeight = 600, quality = 0.7) {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = () => {
                        let width = img.width;
                        let height = img.height;

                        // Resize if too large
                        if (width > maxWidth || height > maxHeight) {
                            const ratio = Math.min(maxWidth / width, maxHeight / height);
                            width = Math.floor(width * ratio);
                            height = Math.floor(height * ratio);
                        }

                        const canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);

                        // Compress as JPEG
                        resolve({ fileData: canvas.toDataURL('image/jpeg', quality), mimeType: 'image/jpeg' });
                    };
                    img.onerror = () => resolve({ fileData: base64Data, mimeType: 'image/jpeg' });
                    img.src = base64Data;
                });
            }

            async function generateRegulatoryProjectReport(projectId) {
                const project = state.projects.find(p => p.ID === projectId);
                if (!project) return;

                showToast('Generating Enhanced Regulatory Report...', 'info');

                // --- DEBUG: Check what we have ---
                console.log('[Regulatory Report] Project object:', project);
                console.log('[Regulatory Report] AnalysisResults:', project.AnalysisResults);
                console.log('[Regulatory Report] AnalysisResultsJSON:', project.AnalysisResultsJSON);

                // --- 1. PREPARE DATA ---
                const blocks = state.blocks.filter(b => b.ProjectID === projectId);
                const trials = state.trials.filter(t => t.ProjectID === projectId);
                const results = project.AnalysisResults || {};
                const daas = Object.keys(results).sort((a, b) => a - b);

                console.log('[Regulatory Report] Parsed results:', results);
                console.log('[Regulatory Report] DAAs found:', daas);

                if (daas.length === 0) {
                    console.error('[Regulatory Report] NO ANALYSIS RESULTS! Check if analysis saved properly.');
                    showToast('No analysis results found. Run analysis first.', 'error');
                    return;
                }

                // Parse protocol data
                let protocol = {};
                try {
                    protocol = project.ProtocolJSON ? JSON.parse(project.ProtocolJSON) : (project.Protocol || {});
                } catch (e) {
                    protocol = project.Protocol || {};
                }

                // --- 2. GENERATE AI EXECUTIVE SUMMARY ---
                showToast('Generating AI executive summary...', 'info');
                let aiExecutiveSummary = '';
                try {
                    const apiKey = state.settings.apiKeys?.[0]?.key;
                    if (apiKey) {
                        const summaryContext = `Generate a professional executive summary for this herbicide efficacy trial:
                        
Project: ${project.Name}
Design: RCBD with ${blocks.length} replications
Treatments: ${[...new Set(trials.map(t => t.FormulationName))].join(', ')}
Metric: ${project.Metric}

Analysis Results:
${daas.map(dat => {
                            const res = results[dat];
                            const topTreatment = res.treatmentStats.sort((a, b) => b.wce - a.wce)[0];
                            const topName = state.formulations.find(f => f.ID === topTreatment.treatmentId)?.Name || 'Unknown';
                            return `${dat} DAA: Best treatment = ${topName} (${topTreatment.wce.toFixed(1)}% WCE, ${topTreatment.rank})`;
                        }).join('\n')}

Write a 2-3 paragraph executive summary highlighting key findings, treatment performance, and recommendations. Be professional and regulatory-appropriate.`;

                        const summaryResponse = await callGeminiAPI(summaryContext, null, apiKey);
                        aiExecutiveSummary = summaryResponse || 'Executive summary generation not available.';
                    } else {
                        aiExecutiveSummary = `This report summarizes the efficacy evaluation of ${trials.length} treatment plots across ${blocks.length} replications using ${project.Metric} as the response variable. Analysis was conducted at ${daas.join(', ')} days after application.`;
                    }
                } catch (e) {
                    console.warn('AI summary failed:', e);
                    aiExecutiveSummary = `Trial evaluated ${trials.length} plots in RCBD design with ${blocks.length} replications.`;
                }

                // --- 3. CAPTURE CHARTS AS IMAGES ---
                showToast('Capturing analysis charts...', 'info');
                const chartImages = {};

                try {
                    // Create temporary hidden container
                    const tempDiv = document.createElement('div');
                    tempDiv.style.position = 'absolute';
                    tempDiv.style.left = '-9999px';
                    tempDiv.style.width = '800px';
                    tempDiv.style.height = '400px';
                    document.body.appendChild(tempDiv);

                    // WCE Over Time Chart
                    const wceCanvas = document.createElement('canvas');
                    wceCanvas.width = 800;
                    wceCanvas.height = 400;
                    tempDiv.appendChild(wceCanvas);

                    const treatments = [...new Set(trials.map(t => t.FormulationID || t.FormulationName))];
                    const colors = ['#10b981', '#3b82f6', '#ef4444', '#f59e0b', '#8b5cf6', '#ec4899', '#14b8a6', '#f97316'];

                    const wceDatasets = treatments.map((tId, idx) => {
                        const tName = state.formulations.find(f => f.ID === tId)?.Name || tId;
                        const data = daas.map(dat => {
                            const ts = results[dat].treatmentStats.find(s => s.treatmentId === tId);
                            return ts ? { x: parseInt(dat), y: ts.wce } : null;
                        }).filter(Boolean);

                        return {
                            label: tName,
                            data,
                            borderColor: colors[idx % colors.length],
                            backgroundColor: colors[idx % colors.length] + '33',
                            borderWidth: 3,
                            pointRadius: 6,
                            pointHoverRadius: 8,
                            tension: 0.3
                        };
                    });

                    new Chart(wceCanvas, {
                        type: 'line',
                        data: { datasets: wceDatasets },
                        options: {
                            responsive: false,
                            animation: false,
                            plugins: {
                                title: { display: true, text: 'Weed Control Efficacy Over Time', font: { size: 16, weight: 'bold' } },
                                legend: { position: 'right' }
                            },
                            scales: {
                                x: { type: 'linear', title: { display: true, text: 'Days After Application' } },
                                y: { min: 0, max: 100, title: { display: true, text: 'WCE (%)' } }
                            }
                        }
                    });

                    await new Promise(resolve => setTimeout(resolve, 500));
                    chartImages.wceTimeline = wceCanvas.toDataURL('image/png');

                    // Final DAT Performance Chart
                    const finalDat = daas[daas.length - 1];
                    const finalRes = results[finalDat];

                    const perfCanvas = document.createElement('canvas');
                    perfCanvas.width = 800;
                    perfCanvas.height = 400;
                    tempDiv.appendChild(perfCanvas);

                    const perfData = finalRes.treatmentStats.map(ts => {
                        const tName = state.formulations.find(f => f.ID === ts.treatmentId)?.Name || 'Unknown';
                        return { treatment: tName, wce: ts.wce, mean: ts.mean };
                    }).sort((a, b) => b.wce - a.wce);

                    new Chart(perfCanvas, {
                        type: 'bar',
                        data: {
                            labels: perfData.map(d => d.treatment),
                            datasets: [{
                                label: `${project.Metric}`,
                                data: perfData.map(d => d.mean),
                                backgroundColor: perfData.map((d, i) => colors[i % colors.length]),
                                borderWidth: 2,
                                borderColor: '#1f2937'
                            }]
                        },
                        options: {
                            responsive: false,
                            animation: false,
                            plugins: {
                                title: { display: true, text: `Treatment Performance at ${finalDat} DAA`, font: { size: 16, weight: 'bold' } },
                                legend: { display: false }
                            },
                            scales: {
                                y: { beginAtZero: true, title: { display: true, text: project.Metric } }
                            }
                        }
                    });

                    await new Promise(resolve => setTimeout(resolve, 500));
                    chartImages.finalPerformance = perfCanvas.toDataURL('image/png');

                    // Cleanup
                    document.body.removeChild(tempDiv);
                } catch (e) {
                    console.warn('Chart capture failed:', e);
                }

                // --- 4. AGGREGATE WEATHER DATA ---
                const weatherData = [];
                trials.forEach(t => {
                    const photos = safeJsonParse(t.PhotoURLs, []);
                    photos.forEach(p => {
                        if (p.weather && p.date) {
                            const trialDate = new Date(t.Date);
                            const photoDate = new Date(p.date);
                            const daa = Math.round((photoDate - trialDate) / (1000 * 60 * 60 * 24));
                            weatherData.push({
                                daa,
                                temp: p.weather.temp,
                                humidity: p.weather.humidity,
                                date: p.date
                            });
                        }
                    });
                });

                // --- 5. COLLECT PHOTOS BY TREATMENT ---
                const photosByTreatment = {};
                trials.forEach(t => {
                    const tName = t.FormulationName || 'Unknown';
                    if (!photosByTreatment[tName]) photosByTreatment[tName] = [];

                    const photos = safeJsonParse(t.PhotoURLs, []);
                    photos.forEach(p => {
                        if (p.url || p.fileData) {
                            const block = state.blocks.find(b => b.ID === t.BlockID);
                            photosByTreatment[tName].push({
                                url: p.url || p.fileData,
                                rep: block?.ReplicationNum || '?',
                                date: p.date ? new Date(p.date).toLocaleDateString() : '',
                                label: p.label || '',
                                weather: p.weather ? `${p.weather.temp}°C, ${p.weather.humidity}% RH` : '',
                                daa: p.date ? Math.round((new Date(p.date) - new Date(t.Date)) / (1000 * 60 * 60 * 24)) : ''
                            });
                        }
                    });
                });

                // --- 6. INITIALIZE PDF ---
                showToast('Building PDF document...', 'info');
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF();
                const pageWidth = doc.internal.pageSize.getWidth();
                const pageHeight = doc.internal.pageSize.getHeight();
                const margin = 14;
                let y = margin;
                let pageNum = 1;

                // Helper: Add Footer
                const addFooter = () => {
                    const oldY = y;
                    y = pageHeight - 10;
                    doc.setFontSize(8);
                    doc.setTextColor(150);
                    doc.text(`${project.Name} - Page ${pageNum}`, margin, y);
                    doc.text(`Generated ${new Date().toLocaleDateString()}`, pageWidth - margin - 40, y);
                    doc.setTextColor(0);
                    y = oldY;
                    pageNum++;
                };

                // Helper: Center Text
                const centerText = (text, yPos, size = 12, style = 'normal') => {
                    doc.setFontSize(size);
                    doc.setFont("helvetica", style);
                    const textWidth = doc.getTextWidth(text);
                    doc.text(text, (pageWidth - textWidth) / 2, yPos);
                };

                // Helper: Check Page Break
                const checkPageBreak = (height = 20) => {
                    if (y + height > pageHeight - 20) {
                        addFooter();
                        doc.addPage();
                        y = margin;
                        return true;
                    }
                    return false;
                };

                // --- 7. COVER PAGE ---
                doc.setFontSize(24);
                doc.setFont("helvetica", "bold");
                doc.setTextColor(13, 148, 136);
                centerText("EFFICACY TRIAL REPORT", 50, 24, "bold");

                doc.setTextColor(0);
                doc.setFontSize(18);
                centerText(project.Name || 'Project Report', 70, 18, "bold");

                doc.setFontSize(12);
                doc.setFont("helvetica", "normal");
                centerText(`Randomized Complete Block Design`, 85, 12);
                centerText(`${blocks.length} Replications | ${trials.length} Plots`, 95, 12);

                y = 120;
                const coverFields = [
                    ['Project ID:', project.ID],
                    ['Response Variable:', project.Metric],
                    ['Investigator:', protocol.Investigator || 'Not specified'],
                    ['Location:', protocol.Location || 'Not specified'],
                    ['Report Date:', new Date().toLocaleDateString()],
                    ['Status:', project.Status]
                ];

                coverFields.forEach(([label, value]) => {
                    doc.setFont("helvetica", "bold");
                    doc.text(label, margin, y);
                    doc.setFont("helvetica", "normal");
                    doc.text(String(value), margin + 50, y);
                    y += 8;
                });

                addFooter();
                doc.addPage();
                y = margin;

                // --- 8. TABLE OF CONTENTS ---
                doc.setFontSize(18);
                doc.setFont("helvetica", "bold");
                doc.text("Table of Contents", margin, y);
                y += 12;

                doc.setFontSize(11);
                doc.setFont("helvetica", "normal");
                const toc = [
                    '1. Executive Summary',
                    '2. Trial Design & Methods',
                    '3. Statistical Analysis Results',
                    '4. Efficacy Visualization',
                    '5. Weather Correlation',
                    '6. Photo Documentation by Treatment',
                    'Appendix: Raw Data Tables'
                ];

                toc.forEach(item => {
                    doc.text(item, margin + 5, y);
                    y += 7;
                });

                addFooter();
                doc.addPage();
                y = margin;

                // --- 9. EXECUTIVE SUMMARY ---
                doc.setFontSize(16);
                doc.setFont("helvetica", "bold");
                doc.setTextColor(13, 148, 136);
                doc.text("1. Executive Summary", margin, y);
                doc.setTextColor(0);
                y += 10;

                doc.setFontSize(10);
                doc.setFont("helvetica", "normal");
                const summaryLines = doc.splitTextToSize(aiExecutiveSummary, pageWidth - 2 * margin);
                doc.text(summaryLines, margin, y);
                y += summaryLines.length * 5 + 10;

                checkPageBreak(30);

                // --- 10. TRIAL DESIGN & METHODS ---
                doc.setFontSize(16);
                doc.setFont("helvetica", "bold");
                doc.setTextColor(13, 148, 136);
                doc.text("2. Trial Design & Methods", margin, y);
                doc.setTextColor(0);
                y += 10;

                const protocolTable = [
                    ['Trial Design', `RCBD with ${blocks.length} Replications`],
                    ['Total Plots', trials.length],
                    ['Treatments', [...new Set(trials.map(t => t.FormulationName))].length],
                    ['Response Variable', project.Metric],
                    ['Location', protocol.Location || 'Not specified'],
                    ['Crop', protocol.Crop || 'Not specified'],
                    ['Plot Size', protocol.PlotSize || 'Not specified'],
                    ['Application Equipment', protocol.Equipment || 'Not specified'],
                    ['Spray Volume', protocol.SprayVolume || 'Not specified'],
                    ['Nozzle Type', protocol.NozzleType || 'Not specified'],
                    ['Pressure', protocol.Pressure || 'Not specified'],
                    ['Application Dates', protocol.ApplicationDates || 'Not specified']
                ].filter(row => row[1] && row[1] !== 'Not specified');

                doc.autoTable({
                    startY: y,
                    head: [['Parameter', 'Value']],
                    body: protocolTable,
                    theme: 'striped',
                    headStyles: { fillColor: [13, 148, 136], fontStyle: 'bold' },
                    styles: { fontSize: 9 },
                    margin: { left: margin, right: margin }
                });

                y = doc.lastAutoTable.finalY + 15;

                // Treatment List
                checkPageBreak(40);
                doc.setFontSize(13);
                doc.setFont("helvetica", "bold");
                doc.text("Treatment List", margin, y);
                y += 8;

                const treatmentList = [...new Set(trials.map(t => t.FormulationName))].map((name, idx) => [idx + 1, name]);

                doc.autoTable({
                    startY: y,
                    head: [['#', 'Treatment Name']],
                    body: treatmentList,
                    theme: 'grid',
                    headStyles: { fillColor: [45, 55, 72] },
                    styles: { fontSize: 9 },
                    margin: { left: margin, right: margin }
                });

                y = doc.lastAutoTable.finalY + 15;

                addFooter();
                doc.addPage();
                y = margin;

                // --- 11. STATISTICAL RESULTS ---
                doc.setFontSize(16);
                doc.setFont("helvetica", "bold");
                doc.setTextColor(13, 148, 136);
                doc.text("3. Statistical Analysis Results", margin, y);
                doc.setTextColor(0);
                y += 10;

                for (const dat of daas) {
                    checkPageBreak(70);

                    const res = results[dat];
                    doc.setFontSize(14);
                    doc.setFont("helvetica", "bold");
                    doc.text(`Assessment at ${dat} Days After Application`, margin, y);
                    y += 8;

                    doc.setFontSize(9);
                    doc.setFont("helvetica", "normal");
                    let anovaText = `F-ratio: ${res.f?.toFixed(2) || 'N/A'} | LSD(0.05): ${res.lsd?.toFixed(3) || 'N/A'} | MSE: ${res.ms?.error?.toFixed(4) || 'N/A'}`;
                    if (res.isPartial) anovaText += ' [Preliminary - Partial Data]';
                    doc.text(anovaText, margin, y);
                    y += 6;

                    const tableBody = res.treatmentStats.map(ts => {
                        const trt = state.formulations.find(f => f.ID === ts.treatmentId) || { Name: ts.treatmentId };
                        return [
                            trt.Name,
                            ts.mean.toFixed(2),
                            `± ${ts.sd.toFixed(2)}`,
                            ts.cv ? ts.cv.toFixed(1) : '-',
                            ts.wce.toFixed(1),
                            ts.rank || 'N/A'
                        ];
                    });

                    doc.autoTable({
                        startY: y,
                        head: [['Treatment', `Mean (${project.Metric})`, 'SD', 'CV%', 'WCE%', 'Ranking']],
                        body: tableBody,
                        theme: 'grid',
                        headStyles: { fillColor: [45, 55, 72], fontSize: 8 },
                        styles: { fontSize: 8, cellPadding: 2 },
                        margin: { left: margin, right: margin }
                    });

                    y = doc.lastAutoTable.finalY + 12;
                }

                addFooter();
                doc.addPage();
                y = margin;

                // --- 12. EFFICACY CHARTS ---
                doc.setFontSize(16);
                doc.setFont("helvetica", "bold");
                doc.setTextColor(13, 148, 136);
                doc.text("4. Efficacy Visualization", margin, y);
                doc.setTextColor(0);
                y += 10;

                if (chartImages.wceTimeline) {
                    doc.addImage(chartImages.wceTimeline, 'PNG', margin, y, pageWidth - 2 * margin, 80);
                    y += 90;
                }

                checkPageBreak(90);

                if (chartImages.finalPerformance) {
                    doc.addImage(chartImages.finalPerformance, 'PNG', margin, y, pageWidth - 2 * margin, 80);
                    y += 90;
                }

                addFooter();
                doc.addPage();
                y = margin;

                // --- 13. WEATHER CORRELATION ---
                if (weatherData.length > 0) {
                    doc.setFontSize(16);
                    doc.setFont("helvetica", "bold");
                    doc.setTextColor(13, 148, 136);
                    doc.text("5. Weather Correlation", margin, y);
                    doc.setTextColor(0);
                    y += 10;

                    doc.setFontSize(10);
                    doc.setFont("helvetica", "normal");
                    doc.text(`Weather data recorded at ${weatherData.length} observation points.`, margin, y);
                    y += 8;

                    const avgTemp = (weatherData.reduce((a, b) => a + b.temp, 0) / weatherData.length).toFixed(1);
                    const avgHumidity = (weatherData.reduce((a, b) => a + b.humidity, 0) / weatherData.length).toFixed(1);

                    doc.text(`Average Temperature: ${avgTemp}°C | Average Humidity: ${avgHumidity}%`, margin, y);
                    y += 12;

                    const weatherTable = weatherData.slice(0, 15).map(w => [
                        w.daa,
                        w.date,
                        `${w.temp}°C`,
                        `${w.humidity}%`
                    ]);

                    doc.autoTable({
                        startY: y,
                        head: [['DAA', 'Date', 'Temperature', 'Humidity']],
                        body: weatherTable,
                        theme: 'striped',
                        headStyles: { fillColor: [13, 148, 136] },
                        styles: { fontSize: 9 },
                        margin: { left: margin, right: margin }
                    });

                    y = doc.lastAutoTable.finalY + 15;

                    addFooter();
                    doc.addPage();
                    y = margin;
                }

                // --- 14. PHOTO DOCUMENTATION ---
                doc.setFontSize(16);
                doc.setFont("helvetica", "bold");
                doc.setTextColor(13, 148, 136);
                doc.text("6. Photo Documentation", margin, y);
                doc.setTextColor(0);
                y += 10;

                const treatmentNames = Object.keys(photosByTreatment);
                let photoCount = 0;
                let totalPhotos = Object.values(photosByTreatment).reduce((sum, arr) => sum + arr.length, 0);

                showToast(`Compressing and embedding ${totalPhotos} photos...`, 'info');

                for (const trtName of treatmentNames) {
                    const photos = photosByTreatment[trtName];
                    if (photos.length === 0) continue;

                    checkPageBreak(30);

                    doc.setFontSize(12);
                    doc.setFont("helvetica", "bold");
                    doc.text(`Treatment: ${trtName}`, margin, y);
                    y += 8;

                    doc.setFontSize(9);
                    doc.setFont("helvetica", "normal");
                    doc.text(`${photos.length} photo(s) recorded across replications`, margin, y);
                    y += 10;

                    // Show ALL photos with compression (no arbitrary limit!)
                    for (let i = 0; i < photos.length; i += 2) {
                        checkPageBreak(75);

                        const p1 = photos[i];
                        const p2 = photos[i + 1];

                        const imgWidth = (pageWidth - 3 * margin) / 2;
                        const imgHeight = 50;

                        // First photo - WITH COMPRESSION
                        if (p1) {
                            try {
                                const base64Obj = await fetchPhotoAsBase64(p1.url);
                                if (base64Obj?.fileData) {
                                    // COMPRESS before embedding!
                                    const compressed = await compressImageForPDF(base64Obj.fileData, 800, 600, 0.7);
                                    doc.addImage(compressed.fileData, 'JPEG', margin, y, imgWidth, imgHeight);
                                    doc.setFontSize(7);
                                    doc.text(`Rep ${p1.rep} | ${p1.daa} DAA`, margin, y + imgHeight + 3);
                                    doc.text(`${p1.date} | ${p1.weather}`, margin, y + imgHeight + 6);
                                    photoCount++;
                                }
                            } catch (e) {
                                doc.setFontSize(8);
                                doc.text('[Image unavailable]', margin, y + 10);
                            }
                        }

                        // Second photo - WITH COMPRESSION
                        if (p2) {
                            try {
                                const base64Obj = await fetchPhotoAsBase64(p2.url);
                                if (base64Obj?.fileData) {
                                    // COMPRESS before embedding!
                                    const compressed = await compressImageForPDF(base64Obj.fileData, 800, 600, 0.7);
                                    doc.addImage(compressed.fileData, 'JPEG', margin + imgWidth + margin, y, imgWidth, imgHeight);
                                    doc.setFontSize(7);
                                    doc.text(`Rep ${p2.rep} | ${p2.daa} DAA`, margin + imgWidth + margin, y + imgHeight + 3);
                                    doc.text(`${p2.date} | ${p2.weather}`, margin + imgWidth + margin, y + imgHeight + 6);
                                    photoCount++;
                                }
                            } catch (e) {
                                doc.setFontSize(8);
                                doc.text('[Image unavailable]', margin + imgWidth + margin, y + 10);
                            }
                        }

                        y += imgHeight + 12;

                        // Progress update every 10 photos
                        if (photoCount % 10 === 0) {
                            showToast(`Embedded ${photoCount}/${totalPhotos} photos...`, 'info');
                        }
                    }

                    y += 5;
                }

                if (photoCount > 0) {
                    doc.setFontSize(8);
                    doc.setTextColor(100);
                    doc.text(`Total ${photoCount} photos embedded with compression (800x600, quality=70%)`, margin, y);
                    doc.setTextColor(0);
                }

                addFooter();

                // --- 15. SAVE PDF ---
                doc.save(`${project.Name}_Enhanced_Regulatory_Report.pdf`);
                showToast('Enhanced regulatory report generated successfully!', 'success');
                showToast('Report generated successfully.', 'success');
            }

            function handleQuickEditControl(id) {
                const trial = state.trials.find(t => t.ID === id);
                if (!trial) return;

                const currentDays = trial.FinalControlDuration ||
                    Math.floor((new Date() - new Date(trial.Date)) / (1000 * 60 * 60 * 24));

                const newDays = prompt("Set final control days:", currentDays);
                if (newDays !== null && !isNaN(parseInt(newDays))) {
                    trial.ControlFinalized = true;
                    trial.FinalControlDuration = parseInt(newDays);
                    trial.FinalizationDate = new Date().toISOString().split('T')[0];

                    apiCall('updateTrialRecord', {
                        id: trial.ID,
                        ControlFinalized: true,
                        FinalizationDate: trial.FinalizationDate,
                        FinalControlDuration: trial.FinalControlDuration
                    }, false);
                    applyFilters();
                    showToast('Control days updated.', 'success');
                }
            }

            async function handleWeedPhotoUpload(trialId, photos) {
                console.log('handleWeedPhotoUpload called, setting cameraMode to weed');
                state.cameraMode = 'weed'; // Explicitly set weed mode
                const result = await processAndAddPhotoObservation(trialId, photos);
            }

            async function processAndAddPhotoObservation(trialId, photoFiles) {
                if (!photoFiles || photoFiles.length === 0) return;
                const trial = state.trials.find(t => t.ID === trialId);
                if (!trial) return;

                const isWeed = state.cameraMode === 'weed';
                const type = isWeed ? 'weed_upload' : 'general_upload';

                showToast(`Processing ${photoFiles.length} photo(s)...`, 'info');

                // Helper to read file as Base64
                const readFile = (file) => new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve({ name: file.name, type: file.type, data: e.target.result });
                    reader.readAsDataURL(file);
                });

                let addedCount = 0;

                for (const file of photoFiles) {
                    try {
                        const fileDataObj = await readFile(file);
                        const tempId = `temp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                        const timestamp = new Date().toISOString();

                        // 1. Create Photo Object for Local State
                        const newPhoto = {
                            tempId: tempId,
                            url: '', // Placeholder until synced
                            fileData: fileDataObj.data, // Store locally for immediate display
                            date: timestamp.split('T')[0],
                            label: 'Processing...',
                            weather: 'Pending...',
                            rep: trial.Replication || 1,
                            daa: 0 // meaningful daa calculated later if needed
                        };

                        // 2. Update Local State (Instant Feedback)
                        if (isWeed) {
                            const current = safeJsonParse(trial.WeedPhotosJSON);
                            current.push(newPhoto);
                            trial.WeedPhotosJSON = JSON.stringify(current);
                        } else {
                            const current = safeJsonParse(trial.PhotoURLs);
                            current.push(newPhoto);
                            trial.PhotoURLs = JSON.stringify(current);
                        }

                        // 3. Add to Sync Queue
                        const syncItem = {
                            id: `sync_${tempId}`,
                            type: type,
                            status: 'pending',
                            trialId: trialId,
                            timestamp: Date.now(),
                            photo: {
                                tempId: tempId,
                                fileData: fileDataObj.data,
                                mimeType: fileDataObj.type,
                                fileName: fileDataObj.name,
                                date: timestamp,
                                label: 'New Upload'
                            },
                            attempts: 0
                        };

                        state.syncQueue.push(syncItem);
                        addedCount++;

                    } catch (e) {
                        console.error("Error processing photo:", e);
                        showToast("Error reading photo file.", "error");
                    }
                }

                if (addedCount > 0) {
                    // 4. Persistence & Sync Trigger
                    saveSyncQueue(); // Save queue to localStorage

                    // Persist local trial state modification immediately so it survives refresh even if sync hasn't run
                    // Note: We avoid apiCall here because syncQueue handles the cloud update. 
                    // But we SHOULD save the local state changes (WeedPhotosJSON with base64/tempId) to LS if we had full local persistent storage. 
                    // Since we rely on simple state, this is fine for session.

                    processSyncQueue(); // Trigger background sync
                    refreshRelevantUI(trialId, type);
                    showToast(`${addedCount} photos queued for sync.`, 'success');
                }
            }

            function handleWeedPhotoDelete(trialId, index) {
                const trial = state.trials.find(t => t.ID === trialId);
                const photos = safeJsonParse(trial.WeedPhotosJSON);
                photos.splice(index, 1);
                trial.WeedPhotosJSON = JSON.stringify(photos);
                apiCall('updateTrialRecord', { id: trialId, WeedPhotosJSON: trial.WeedPhotosJSON }, false);
                // Refresh modal if open
                const modal = document.getElementById('weed-modal');
                if (modal) {
                    document.getElementById('weed-photo-grid').innerHTML = photos.map((p, i) => render.weedPhotoCard(p, trialId, i)).join('');
                }
            }

            async function handleAiQuery(query) {
                if (!query) return;
                const chatBox = document.getElementById('ai-chat-box');
                appendMessageToChat(query, 'user');
                document.getElementById('ai-input').value = '';
                appendMessageToChat('', 'ai', true);

                try {
                    const apiKey = state.settings.geminiApiKey || (state.settings.apiKeys && state.settings.apiKeys[0]?.key);
                    if (!apiKey) throw new Error("Gemini API Key missing in Settings.");

                    // Build Context
                    let context = `You are an expert agronomist and trial analyst for "Weedicide", a high-tech herbicide research platform.
                Current App State:
                - Page: ${state.currentPage}
                - Total Trials: ${state.trials.length}
                - Total Projects: ${state.projects.length}
                `;

                    // 1. Project Context
                    if (state.currentPage === 'projectDashboard' && state.activeProjectId) {
                        const project = state.projects.find(p => p.ID === state.activeProjectId);
                        if (project) {
                            const projectTrials = state.trials.filter(t => t.ProjectID === project.ID);
                            context += `\nCurrently analyzing Project: "${project.Name}"
                        - Metric: ${project.Metric}
                        - Status: ${project.Status}
                        - Block Count: ${state.blocks.filter(b => b.ProjectID === project.ID).length}
                        - Trials in Project: ${projectTrials.length}`;

                            if (project.AnalysisResults) {
                                context += `\n\nStatistical Analysis Results (ANOVA/LSD):\n${JSON.stringify(project.AnalysisResults)}`;
                            } else {
                                context += `\n(No statistical analysis has been run for this project yet)`;
                            }
                        }
                    }

                    // 2. Trial Detail Context (Modal)
                    const trialModal = document.getElementById('trial-detail-modal');
                    const isTrialModalOpen = trialModal && !trialModal.classList.contains('hidden');

                    if (isTrialModalOpen) {
                        // Attempt to find Trial ID from DOM (looking for ANY data-trial-id attribute inside)
                        const idEl = trialModal.querySelector('[data-trial-id]');
                        const trialId = idEl ? idEl.dataset.trialId : null;

                        if (trialId) {
                            const trial = state.trials.find(t => t.ID === trialId);
                            if (trial) {
                                context += `\n\nCurrently Viewing Trial: "${trial.FormulationName}"
                                - Investigator: ${trial.InvestigatorName}
                                - Date: ${trial.Date}
                                - Result: ${trial.Result}
                                - Weed Species: ${trial.WeedSpecies}
                                - Conclusion: ${trial.Conclusion}`;

                                if (trial.StatisticsJSON && trial.StatisticsJSON.length > 5) {
                                    context += `\n\nTrial Statistics:\n${trial.StatisticsJSON}`;
                                }

                                // Summarize Efficacy
                                const eff = safeJsonParse(trial.EfficacyDataJSON);
                                if (eff.length > 0) {
                                    const last = eff[eff.length - 1];
                                    context += `\n\nEfficacy Data (Latest Day ${last.daa}): ${JSON.stringify(last)}`;
                                }
                            }
                        }
                    }

                    // 3. Comparison Context
                    if (state.selectedTrials.length > 0) {
                        context += `\n\nUser has selected ${state.selectedTrials.length} trials for comparison. IDs: ${state.selectedTrials.join(', ')}.`;
                        const selectedDetails = state.selectedTrials.map(id => {
                            const t = state.trials.find(tr => tr.ID === id);
                            return t ? `${t.FormulationName} (Date: ${t.Date}, Result: ${t.Result})` : null;
                        }).filter(Boolean).join(' vs ');
                        context += `\nComparing: ${selectedDetails}`;
                    }

                    // 4. Formulations Context
                    if (state.formulations.length > 0) {
                        context += `\n\nAvailable Formulations: ${state.formulations.map(f => f.Name).join(', ')}`;
                    }

                    const prompt = `${context}\n\nUser Question: ${query}\n\nRespond as a knowledgeable, technical agronomist. Be concise but scientifically rigorous.`;

                    const geminiCall = (genAI) => genAI.models.generateContent({
                        model: state.settings.apiModel || 'gemini-2.0-flash-exp',
                        contents: [{ parts: [{ text: prompt }] }]
                    });

                    const response = await callGeminiApi(`AI Chat: ${query.substring(0, 30)}...`, geminiCall);

                    // Remove loading
                    if (chatBox.lastChild) chatBox.lastChild.remove();

                    appendMessageToChat(response.text, 'ai');
                } catch (e) {
                    console.error("AI Query Error:", e);
                    if (chatBox.lastChild) chatBox.lastChild.remove();
                    appendMessageToChat(`Error: ${e.message}`, 'ai');
                }
            }

            function handleOrganiseSubmit(form) {
                const orgId = form.querySelector('[name="organisationId"]').value;
                const newName = form.querySelector('[name="newOrganisationName"]').value;

                if (newName) {
                    const newOrg = { ID: 'temp_' + Date.now(), Name: newName, TrialIDs: JSON.stringify(state.selectedTrials) };
                    state.organisations.push(newOrg);
                    apiCall('addOrganisation', newOrg, false).then(res => {
                        const record = res?.record || (res?.ID ? res : null);
                        if (record) {
                            state.organisations[state.organisations.length - 1] = record;
                            render.organisations();
                        }
                    });
                } else if (orgId) {
                    const org = state.organisations.find(o => o.ID === orgId);
                    const currentTrials = safeJsonParse(org.TrialIDs);
                    const updatedTrials = [...new Set([...currentTrials, ...state.selectedTrials])];
                    org.TrialIDs = JSON.stringify(updatedTrials);
                    apiCall('updateOrganisation', { id: orgId, TrialIDs: org.TrialIDs }, false);
                }

                closeModal();
                showToast('Trials added to organisation.', 'success');
                state.selectedTrials = [];
                updateOrganiseBar();
            }


            // --- PROTOCOL MODAL LOGIC ---
            function openProtocolModal(projectId) {
                const project = state.projects.find(p => p.ID === projectId);
                if (!project) return;

                // Load protocol from JSON string (where it's actually stored)
                let protocol = {};
                try {
                    protocol = project.ProtocolJSON ? JSON.parse(project.ProtocolJSON) : {};
                } catch (e) {
                    console.warn('Failed to parse ProtocolJSON:', e);
                    protocol = {};
                }
                const p = protocol;

                // Populate Modal Fields
                document.getElementById('protocol-investigator').value = p.Investigator || '';
                document.getElementById('protocol-location').value = p.Location || '';
                document.getElementById('protocol-crop').value = p.Crop || '';
                document.getElementById('protocol-plot-size').value = p.PlotSize || '';
                document.getElementById('protocol-spray-vol').value = p.SprayVolume || '';
                document.getElementById('protocol-nozzle').value = p.NozzleType || '';
                document.getElementById('protocol-pressure').value = p.Pressure || '';
                document.getElementById('protocol-equipment').value = p.Equipment || '';
                document.getElementById('protocol-dates').value = p.ApplicationDates || '';

                // Store Project ID on the Save Button for retrieval
                const saveBtn = document.getElementById('save-protocol-btn');
                if (saveBtn) saveBtn.dataset.projectId = projectId;

                // Show the modal directly (it's already in the DOM)
                const protocolModal = document.getElementById('protocol-settings-modal');
                if (protocolModal) {
                    protocolModal.classList.remove('hidden');
                }
            }

            async function saveProtocol() {
                const btn = document.getElementById('save-protocol-btn');
                const projectId = btn.dataset.projectId;
                const project = state.projects.find(p => p.ID === projectId);

                if (!project) return;

                const protocolData = {
                    Investigator: document.getElementById('protocol-investigator').value,
                    Location: document.getElementById('protocol-location').value,
                    Crop: document.getElementById('protocol-crop').value,
                    PlotSize: document.getElementById('protocol-plot-size').value,
                    SprayVolume: document.getElementById('protocol-spray-vol').value,
                    NozzleType: document.getElementById('protocol-nozzle').value,
                    Pressure: document.getElementById('protocol-pressure').value,
                    Equipment: document.getElementById('protocol-equipment').value,
                    ApplicationDates: document.getElementById('protocol-dates').value
                };

                // Save to local state
                project.Protocol = protocolData;
                project.ProtocolJSON = JSON.stringify(protocolData);

                // Persist to Cloud
                await apiCall('updateProject', {
                    ID: projectId,
                    ProtocolJSON: JSON.stringify(protocolData)
                }, false);

                showToast('Protocol details saved.', 'success');

                // Close the protocol modal
                const protocolModal = document.getElementById('protocol-settings-modal');
                if (protocolModal) {
                    protocolModal.classList.add('hidden');
                }
            }

            // Expose globally for HTML onclick
            window.saveProtocol = saveProtocol;
            window.closeModal = closeModal;

            function handlePhotoEditSubmit(form) {
                const trialId = form.querySelector('[name="trialId"]').value;
                const photoIndex = parseInt(form.querySelector('[name="photoIndex"]').value);
                const trial = state.trials.find(t => t.ID === trialId);

                const photos = safeJsonParse(trial.PhotoURLs);
                if (photos[photoIndex]) {
                    photos[photoIndex].label = form.querySelector('[name="label"]').value || '';
                    photos[photoIndex].date = form.querySelector('[name="date"]').value;

                    // Capture weather fields explicitly
                    const wTemp = form.querySelector('[name="temp"]').value;
                    const wHum = form.querySelector('[name="humidity"]').value;
                    const wWind = form.querySelector('[name="wind"]').value;
                    const wRain = form.querySelector('[name="rain"]').value;

                    // Ensure weather object exists and is populated
                    photos[photoIndex].weather = {
                        temp: wTemp,
                        humidity: wHum,
                        wind: wWind,
                        rain: wRain
                    };

                    trial.PhotoURLs = JSON.stringify(photos);
                    apiCall('updateTrialRecord', { id: trialId, PhotoURLs: trial.PhotoURLs }, false);
                    showToast('Photo details updated.', 'success');
                    closeModal();
                    openTrialDetail(trialId); // Refresh detail view
                }
            }

            function handleBulkIngredients() {
                const text = document.getElementById('bulk-ingredients-input').value;
                if (!text) return showToast('Please enter ingredients.', 'error');

                // Split by comma
                const items = text.split(',').map(s => s.trim()).filter(Boolean);
                let addedCount = 0;

                items.forEach(itemStr => {
                    // Regex: Name (Group 1), Quantity (Group 2), Unit (Group 4)
                    // Example: "Acetic Acid 500ml" -> "Acetic Acid", "500", "ml"
                    const match = itemStr.match(/^(.+?)\s+(\d+(?:\.\d+)?)\s*([a-zA-Z]+)$/);
                    if (match) {
                        const name = match[1].trim();
                        const quantity = match[2];
                        const unit = match[3];

                        // Try to find ingredient by name match
                        const ingredient = state.ingredients.find(ing => ing.Name.toLowerCase() === name.toLowerCase());
                        if (ingredient) {
                            addFormulationIngredientRow({ id: ingredient.ID, quantity, unit });
                            addedCount++;
                        } else {
                            showToast(`Ingredient '${name}' not found in database.`, 'error');
                        }
                    } else {
                        showToast(`Could not parse: '${itemStr}'. Use format 'Name QuantityUnit'.`, 'error');
                    }
                });

                if (addedCount > 0) {
                    updateFormulationCost();
                    showToast(`${addedCount} ingredients added.`, 'success');
                }
            }

            async function handleBulkIngredientsCost() {
                const text = document.getElementById('bulk-ingredients-cost-input').value;
                if (!text) return showToast('Please enter ingredients.', 'error');

                const items = text.split(',').map(s => s.trim()).filter(Boolean);
                let count = 0;

                showToast(`Processing ${items.length} items...`, 'info');

                for (const itemStr of items) {
                    // Regex: Name Cost Unit
                    // Example: "Glyphosate 15000 L" -> "Glyphosate", "15000", "L"
                    const match = itemStr.match(/^(.+?)\s+(\d+(?:\.\d+)?)\s*([a-zA-Z]+)$/);
                    if (match) {
                        const name = match[1].trim();
                        const cost = parseFloat(match[2]);
                        const unit = match[3];

                        const payload = {
                            ID: `temp_${Date.now()}_${count}`,
                            Name: name, name: name,
                            Cost: cost, cost: cost,
                            Unit: unit, unit: unit
                        };

                        // Add locally first for responsiveness
                        state.ingredients.push(payload);
                        count++;

                        // Sync to backend (fire and forget for speed in bulk, or await)
                        // We await here to ensure data integrity
                        await apiCall('addIngredient', payload, false);
                    }
                }

                render.ingredients();
                showToast(`${count} ingredients added/synced.`, 'success');
            }

            async function openReportPreviewModal(trialId, options) {
                openModal('reportPreview');
                const trial = state.trials.find(t => t.ID === trialId);

                // 1. Render charts IMMEDIATELY. Do not wait for any async logic or timeouts.
                setTimeout(() => {
                    renderTrialChartsToCanvases(trial, 'preview-cover-canvas', 'preview-phyto-canvas');
                    document.getElementById('cover-report-section').classList.remove('hidden');
                    document.getElementById('phyto-report-section').classList.remove('hidden');
                }, 50);

                // 2. Fetch AI summaries in background INDEPENDENTLY
                const summaries = safeJsonParse(trial.AISummariesJSON, {});
                const coverInput = document.getElementById('cover-summary-textarea');
                const phytoInput = document.getElementById('phyto-summary-textarea');

                coverInput.value = summaries.cover || 'Generating professional analysis...';
                phytoInput.value = summaries.phyto || 'Generating professional analysis...';

                if (!summaries.cover || !summaries.phyto) {
                    // This is async and might take time, but the graphs are already visible
                    await updateTrialAISummaries(trialId);
                    const newSum = safeJsonParse(state.trials.find(t => t.ID === trialId).AISummariesJSON);
                    coverInput.value = newSum.cover || 'Analysis generation failed.';
                    phytoInput.value = newSum.phyto || 'Analysis generation failed.';
                }

                // Add persistence listeners
                // Add persistence listeners with Debounce
                let saveTimeout;
                const saveSummary = () => {
                    const t = state.trials.find(tr => tr.ID === trialId);
                    if (t) {
                        const s = safeJsonParse(t.AISummariesJSON, {});
                        s.cover = coverInput.value;
                        s.phyto = phytoInput.value;
                        t.AISummariesJSON = JSON.stringify(s);

                        clearTimeout(saveTimeout);
                        saveTimeout = setTimeout(() => {
                            apiCall('updateTrialRecord', { id: trialId, AISummariesJSON: t.AISummariesJSON }, false);
                            showToast('AI Summary saved to cloud.', 'success');
                        }, 1000);
                    }
                };
                coverInput.addEventListener('input', saveSummary);
                phytoInput.addEventListener('input', saveSummary);

                // Initialize regeneration logic
                const chartData = prepareTrialChartData(trial);

                const regenerateCoverBtn = document.getElementById('regenerate-cover-summary');
                if (regenerateCoverBtn) {
                    regenerateCoverBtn.onclick = async () => {
                        if (!chartData) return;
                        coverInput.value = 'Regenerating summary...';
                        const { coverDatasets, coverChartOptions, allWeedSpecies } = chartData;

                        // Create complete chart config object
                        const coverChartConfig = {
                            type: 'line',
                            data: { datasets: coverDatasets },
                            options: coverChartOptions
                        };

                        const wceData = calculateWeedControlEfficiency(safeJsonParse(trial.EfficacyDataJSON));
                        const summary = await getChartSummaryFromAI(coverChartConfig, '% Cover by Species', allWeedSpecies.join(', '), "Ongoing", trial.Result, { wceData, weedIds: safeJsonParse(trial.WeedPhotosJSON).map(p => p.identifications?.[0]).filter(Boolean) });
                        coverInput.value = summary;
                        saveSummary();
                    };
                }

                const regeneratePhytoBtn = document.getElementById('regenerate-phyto-summary');
                if (regeneratePhytoBtn) {
                    regeneratePhytoBtn.onclick = async () => {
                        if (!chartData) return;
                        phytoInput.value = 'Regenerating summary...';
                        const { phytoData, phytoChartOptions } = chartData;

                        // Create complete chart config object
                        const phytoChartConfig = {
                            type: 'line',
                            data: { datasets: [phytoData] },
                            options: phytoChartOptions
                        };

                        const wceData = calculateWeedControlEfficiency(safeJsonParse(trial.EfficacyDataJSON));
                        const summary = await getChartSummaryFromAI(phytoChartConfig, '% Phytotoxicity', 'Overall', "Ongoing", trial.Result, { wceData });
                        phytoInput.value = summary;
                        saveSummary();
                    };
                }

                const generatePdfBtn = document.getElementById('generate-pdf-from-preview');
                if (generatePdfBtn) {
                    generatePdfBtn.onclick = () => {
                        // Capture canvas images
                        const coverCanvas = document.getElementById('preview-cover-canvas');
                        const phytoCanvas = document.getElementById('preview-phyto-canvas');
                        const chartImages = {
                            cover: coverCanvas ? coverCanvas.toDataURL('image/png') : null,
                            phyto: phytoCanvas ? phytoCanvas.toDataURL('image/png') : null
                        };
                        const showPhotoDates = document.getElementById('show-photo-dates')?.checked || state.settings.showPhotoDates;
                        const withTimeline = document.getElementById('include-timeline')?.checked || state.settings.includeTimeline;
                        generateComprehensivePdf(trialId, { ...options, chartImages, showPhotoDates, withTimeline });
                    };
                }
            }

            // --- HANDLE DELETE FUNCTION (Missing!) ---
            async function handleDelete(type, id) {
                if (!confirm(`Are you sure you want to delete this ${type}? This action cannot be undone.`)) {
                    return;
                }

                try {
                    if (type === 'trial') {
                        // Delete trial
                        const result = await apiCall('deleteTrial', { id }, false);
                        if (result && result.success) {
                            state.trials = state.trials.filter(t => t.ID !== id);
                            showToast('Trial deleted successfully.', 'success');
                            applyFilters();
                        } else {
                            showToast('Failed to delete trial.', 'error');
                        }
                    } else if (type === 'formulation') {
                        // Delete formulation
                        const result = await apiCall('deleteFormulation', { id }, false);
                        if (result && result.success) {
                            state.formulations = state.formulations.filter(f => f.ID !== id);
                            showToast('Formulation deleted successfully.', 'success');
                            render.formulations();
                        } else {
                            showToast('Failed to delete formulation.', 'error');
                        }
                    } else if (type === 'ingredient') {
                        // Delete ingredient
                        const result = await apiCall('deleteIngredient', { id }, false);
                        if (result && result.success) {
                            state.ingredients = state.ingredients.filter(i => i.ID !== id);
                            showToast('Ingredient deleted successfully.', 'success');
                            render.ingredients();
                        } else {
                            showToast('Failed to delete ingredient.', 'error');
                        }
                    } else if (type === 'project') {
                        // Delete project with cascading deletes (blocks and trials)
                        const projectBlocks = state.blocks.filter(b => b.ProjectID === id);
                        const projectTrials = state.trials.filter(t => t.ProjectID === id);

                        showToast(`Deleting project and ${projectBlocks.length} blocks, ${projectTrials.length} trials...`, 'info');

                        // Delete all trials in project
                        for (const trial of projectTrials) {
                            await apiCall('deleteTrial', { id: trial.ID }, false);
                        }

                        // Delete all blocks in project
                        for (const block of projectBlocks) {
                            await apiCall('deleteBlock', { id: block.ID }, false);
                        }

                        // Delete project itself
                        const result = await apiCall('deleteProject', { id }, false);
                        if (result && result.success) {
                            state.projects = state.projects.filter(p => p.ID !== id);
                            state.blocks = state.blocks.filter(b => b.ProjectID !== id);
                            state.trials = state.trials.filter(t => t.ProjectID !== id);

                            showToast('Project and all related data deleted successfully.', 'success');
                            switchPage('projects');
                        } else {
                            showToast('Failed to delete project.', 'error');
                        }
                    } else if (type === 'block') {
                        // Delete block with cascading deletes (trials in block)
                        const blockTrials = state.trials.filter(t => t.BlockID === id);

                        showToast(`Deleting block and ${blockTrials.length} trials...`, 'info');

                        // Delete all trials in block
                        for (const trial of blockTrials) {
                            await apiCall('deleteTrial', { id: trial.ID }, false);
                        }

                        // Delete block itself
                        const result = await apiCall('deleteBlock', { id }, false);
                        if (result && result.success) {
                            state.blocks = state.blocks.filter(b => b.ID !== id);
                            state.trials = state.trials.filter(t => t.BlockID !== id);

                            showToast('Block and related trials deleted successfully.', 'success');
                            render.projectDashboard();
                        } else {
                            showToast('Failed to delete block.', 'error');
                        }
                    } else if (type === 'organisation') {
                        // Delete organisation
                        const result = await apiCall('deleteOrganisation', { id }, false);
                        if (result && result.success) {
                            state.organisations = state.organisations.filter(o => o.ID !== id);
                            showToast('Organisation deleted successfully.', 'success');
                            render.organisations();
                        } else {
                            showToast('Failed to delete organisation.', 'error');
                        }
                    }
                } catch (error) {
                    console.error(`Error deleting ${type}:`, error);
                    showToast(`Error deleting ${type}: ${error.message}`, 'error');
                }
            }

            function openTrialDetail(id) {
                const trial = state.trials.find(t => t.ID === id);
                openModal('trialDetail', false, { trial });
                setTimeout(() => renderSingleTrialCharts(trial), 100);
            }

            function applyFilters(overrides = {}) {
                const search = document.querySelector('[data-type="trial-search"]')?.value.toLowerCase() || state.filterState.search;
                const formulationText = document.querySelector('[data-type="trial-formulation-text"]')?.value.toLowerCase() || state.filterState.formulationText;
                const formulation = document.querySelector('[data-type="trial-formulation"]')?.value || state.filterState.formulation;
                const start = document.querySelector('[data-type="trial-start-date"]')?.value || state.filterState.startDate;
                const end = document.querySelector('[data-type="trial-end-date"]')?.value || state.filterState.endDate;
                const sortBy = overrides.sortBy || state.filterState.sortBy;

                state.filterState = { search, formulationText, formulation, startDate: start, endDate: end, sortBy };

                let filtered = state.trials.filter(t => {
                    const matchesSearch = !search || (t.InvestigatorName || '').toLowerCase().includes(search) || (t.WeedSpecies || '').toLowerCase().includes(search);
                    const matchesFormText = !formulationText || (t.FormulationName || '').toLowerCase().includes(formulationText);
                    const matchesForm = !formulation || t.FormulationName === formulation;
                    const matchesDate = (!start || new Date(t.Date) >= new Date(start)) && (!end || new Date(t.Date) <= new Date(end));
                    return matchesSearch && matchesFormText && matchesForm && matchesDate;
                });

                if (sortBy === 'date') filtered.sort((a, b) => new Date(b.Date).getTime() - new Date(a.Date).getTime());
                if (sortBy === 'result') {
                    const scores = { 'Excellent': 4, 'Good': 3, 'Fair': 2, 'Poor': 1, '': 0 };
                    filtered.sort((a, b) => scores[b.Result || ''] - scores[a.Result || '']);
                }

                render.trials(filtered);
            }

            function getGeoLocation(callback) {
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                        pos => callback({ lat: pos.coords.latitude, lon: pos.coords.longitude }),
                        err => showToast('Location access denied.', 'error')
                    );
                } else {
                    showToast('Geolocation not supported.', 'error');
                }
            }

            // --- PLOT SCANNER LOGIC ---
            let scannerStream = null;
            let scannerAnimationId = null;
            // Create a single canvas for scanning to avoid garbage collection churn
            const scannerCanvas = document.createElement("canvas");
            const scannerCtx = scannerCanvas.getContext("2d");

            function openQrScanner() {
                const modal = document.getElementById('qr-scanner-modal-fixed');
                const video = document.getElementById('qr-video');
                if (!modal || !video) return;

                if (typeof jsQR === 'undefined') {
                    showToast('QR Scanner library not loaded. Please refresh.', 'error');
                    return;
                }

                // Check for Secure Context / Protocol
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    console.error("Camera API unavailable. Protocol:", window.location.protocol);
                    if (window.location.protocol === 'file:') {
                        alert("⚠️ Camera Blocked by Browser Security\n\nYou are opening this file directly (file://). Modern browsers block camera access in this mode for security.\n\nSolution:\nUse a local server (like 'Live Server' in VS Code) or upload to a secure website (https://).");
                    } else {
                        showToast("Camera API not supported or blocked by browser context.", "error");
                    }
                    return;
                }

                modal.classList.remove('hidden');

                // Helper to start camera with fallback
                const startCamera = (constraints) => {
                    navigator.mediaDevices.getUserMedia(constraints)
                        .then(stream => {
                            scannerStream = stream;
                            video.srcObject = stream;
                            video.setAttribute("playsinline", true); // Required for iOS Safari
                            video.play().catch(e => console.error("Video play error:", e));
                            requestAnimationFrame(scanQrTick);
                        })
                        .catch(err => {
                            console.warn("Camera failed with constraints:", constraints, err);
                            // Fallback: If environment camera failed, try ANY camera
                            if (constraints.video && constraints.video.facingMode === 'environment') {
                                console.log("Retrying with generic camera access...");
                                startCamera({ video: true });
                            } else {
                                console.error("All camera attempts failed:", err);
                                showToast("Could not access any camera. Please check permissions.", "error");
                                closeQrScanner();
                            }
                        });
                };

                // Initial attempt: Prefer back camera, HD resolution
                startCamera({
                    video: {
                        facingMode: "environment",
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                });
            }

            function closeQrScanner() {
                const modal = document.getElementById('qr-scanner-modal-fixed');
                const video = document.getElementById('qr-video');

                if (modal) modal.classList.add('hidden');

                if (scannerAnimationId) cancelAnimationFrame(scannerAnimationId);

                if (video) {
                    video.pause();
                    video.srcObject = null;
                }

                if (scannerStream) {
                    scannerStream.getTracks().forEach(track => track.stop());
                    scannerStream = null;
                }
            }

            function scanQrTick() {
                const video = document.getElementById('qr-video');
                const modal = document.getElementById('qr-scanner-modal-fixed');

                // Stop if modal is closed
                if (!modal || modal.classList.contains('hidden')) return;

                if (!video || !video.videoWidth) {
                    scannerAnimationId = requestAnimationFrame(scanQrTick);
                    return;
                }

                // Draw video frame to canvas
                scannerCanvas.width = video.videoWidth;
                scannerCanvas.height = video.videoHeight;
                scannerCtx.drawImage(video, 0, 0, scannerCanvas.width, scannerCanvas.height);

                const imageData = scannerCtx.getImageData(0, 0, scannerCanvas.width, scannerCanvas.height);

                // Scan for QR code
                const code = jsQR(imageData.data, imageData.width, imageData.height, {
                    inversionAttempts: "dontInvert",
                });

                if (code) {
                    // Success!
                    handleScannedQr(code.data);
                } else {
                    scannerAnimationId = requestAnimationFrame(scanQrTick);
                }
            }

            function handleScannedQr(data) {
                // Feedback
                if (navigator.vibrate) navigator.vibrate(200);

                // Try to extract Trial ID
                let trialId = null;

                // Case 1: URL with trialId parameter (Online QR)
                if (data.includes('trialId=')) {
                    try {
                        const url = new URL(data);
                        trialId = url.searchParams.get('trialId');
                    } catch (e) {
                        // Fallback regex
                        const match = data.match(/trialId=([^&]+)/);
                        if (match) trialId = match[1];
                    }
                }
                // Case 2: Just the ID
                else if (data.match(/^[0-9a-f]{8}-[0-9a-f]{4}/i)) {
                    trialId = data; // Assume it's an ID
                }

                if (trialId) {
                    const trial = state.trials.find(t => t.ID === trialId);
                    if (trial) {
                        showToast(`Found: ${trial.FormulationName}`, 'success');
                        closeQrScanner();
                        // openTrialDetail(trialId); // OLD WORKFLOW
                        openScanActions(trialId); // NEW RAPID WORKFLOW
                    } else {
                        closeQrScanner();
                        showToast('Trial ID found in QR, but not in local database.', 'warning');
                    }
                } else {
                    // Determine if it looks like an offline QR
                    if (data.includes('H-APP:')) {
                        closeQrScanner();
                        alert("This is an Offline QR Code.\\n\\nContent:\\n" + data + "\\n\\nPlease use Online QR Codes for navigation.");
                    }
                    else {
                        scannerAnimationId = requestAnimationFrame(scanQrTick);
                    }
                }
            }

            function openScanActions(trialId) {
                const trial = state.trials.find(t => t.ID === trialId);
                if (!trial) return;

                const modal = document.getElementById('scan-action-modal');
                const title = document.getElementById('scan-match-title');
                const subtitle = document.getElementById('scan-match-subtitle');

                title.textContent = trial.FormulationName;
                subtitle.textContent = `${trial.InvestigatorName || 'Unknown Info'} • ${trial.Location || 'No Loc'}`;

                // Unbind previous listeners (simple clone hack to clear)
                const btnCamera = document.getElementById('scan-action-camera');
                const btnWeed = document.getElementById('scan-action-weed');
                const btnGallery = document.getElementById('scan-action-gallery');
                const btnDetail = document.getElementById('scan-action-detail');
                const inputGallery = document.getElementById('scan-gallery-input');

                const newBtnCamera = btnCamera.cloneNode(true);
                const newBtnWeed = btnWeed.cloneNode(true);
                const newBtnGallery = btnGallery.cloneNode(true);
                const newBtnDetail = btnDetail.cloneNode(true);
                const newInputGallery = inputGallery.cloneNode(true);

                btnCamera.parentNode.replaceChild(newBtnCamera, btnCamera);
                btnWeed.parentNode.replaceChild(newBtnWeed, btnWeed);
                btnGallery.parentNode.replaceChild(newBtnGallery, btnGallery);
                btnDetail.parentNode.replaceChild(newBtnDetail, btnDetail);
                inputGallery.parentNode.replaceChild(newInputGallery, inputGallery);

                // Bind new actions
                newBtnCamera.addEventListener('click', () => {
                    modal.classList.add('hidden');
                    state.cameraMode = 'general';
                    openCamera(trialId);
                });

                newBtnWeed.addEventListener('click', () => {
                    modal.classList.add('hidden');
                    state.cameraMode = 'weed';
                    openCamera(trialId);
                });

                newBtnGallery.addEventListener('click', () => {
                    newInputGallery.click();
                });

                newInputGallery.addEventListener('change', (e) => {
                    if (e.target.files && e.target.files.length > 0) {
                        modal.classList.add('hidden');
                        state.currentTrialIdForCamera = trialId;
                        state.cameraMode = 'general'; // Default to general for gallery
                        // Reuse photo queue logic
                        state.photoQueue = Array.from(e.target.files);
                        processPhotoQueue(trialId);
                        // Reset input
                        newInputGallery.value = '';
                    }
                });

                newBtnDetail.addEventListener('click', () => {
                    modal.classList.add('hidden');
                    openTrialDetail(trialId);
                });

                modal.classList.remove('hidden');
                modal.style.display = 'flex'; // FORCE FLEX FOR CENTERING
            }

            // --- REPORTING & EXPORT LOGIC ---
            /* runComparison is defined earlier at ~3476 */

            async function getLogoDimensions(logoDataUrl) { return new Promise(resolve => { if (!logoDataUrl) { resolve(null); return; } const img = new Image(); img.onload = () => { const aspectRatio = img.width / img.height; const logoHeight = 1.2; const logoWidth = logoHeight * aspectRatio; resolve({ width: logoWidth, height: logoHeight }); }; img.onerror = () => resolve(null); img.src = logoDataUrl; }); }
            async function generateQrCodeDataUrl(dataString) { return new Promise((resolve, reject) => { try { const tempDiv = document.createElement('div'); new QRCode(tempDiv, { text: dataString, width: 256, height: 256, correctLevel: QRCode.CorrectLevel.M }); setTimeout(() => { const canvas = tempDiv.querySelector('canvas'); if (canvas) resolve(canvas.toDataURL('image/png')); else reject(new Error('QR Code generation failed.')); }, 100); } catch (error) { resolve(null); } }); }

            async function generateCardsForPrint() {
                if (state.selectedTrials.length === 0) return showToast('No trials selected.', 'error');

                // Map cardSize to dimensions (cm)
                let cardWidth = 9, cardHeight = 6;
                const sizeSetting = state.settings.cardSize || 'ID';
                if (sizeSetting === 'A6') { cardWidth = 10; cardHeight = 14; } // Portrait 
                if (sizeSetting === 'A4') { cardWidth = 19; cardHeight = 13; } // Landscape half
                const companyLogo = state.settings.logoBase64;

                showToast('Generating print layout...', 'info');

                const printWindow = window.open('', '_blank');
                if (!printWindow) return showToast("Pop-up blocker prevented opening print window.", 'error');

                let htmlContent = `
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>Print Trial Cards</title>
                <style>
                    @media print { body { -webkit-print-color-adjust: exact; print-color-adjust: exact; } }
                    body { margin: 0.5cm; font-family: sans-serif; }
                    .page {
                        display: grid;
                        grid-template-columns: repeat(auto-fill, minmax(${cardWidth}cm, 1fr));
                        gap: 0.5cm;
                        page-break-after: always;
                    }
                    .card {
                        width: ${cardWidth}cm;
                        height: ${cardHeight}cm;
                        border: 1px solid #ccc;
                        border-radius: 4px;
                        padding: 0.4cm;
                        box-sizing: border-box;
                        display: flex;
                        flex-direction: column;
                        justify-content: space-between;
                        page-break-inside: avoid;
                        overflow: hidden;
                        position: relative;
                    }
                    .card-header { display: flex; justify-content: space-between; align-items: flex-start; }
                    .card-header h3 { font-size: 12pt; margin: 0; font-weight: bold; color: #2c5282; max-width: 65%; }
                    .logo { max-width: 2.5cm; max-height: 1.2cm; object-fit: contain; }
                    .card-body p { font-size: 9pt; margin: 0.1cm 0; }
                    .card-footer { text-align: right; }
                    .qr-code { width: 2.5cm; height: 2.5cm; }
                     .qr-code { width: 2.5cm; height: 2.5cm; }
                 </style>
            </head>
            <body><div class="page">`;

                const selected = state.selectedTrials.map(id => state.trials.find(t => t.ID === id)).filter(Boolean);

                for (const trial of selected) {
                    // Generate QR
                    const params = new URLSearchParams({ trialId: trial.ID, spreadsheetId: state.settings.sheetId });
                    const qrDataString = `${state.settings.scriptUrl}?${params.toString()}`;
                    const qrCodeUrl = await generateQrCodeDataUrl(qrDataString);

                    htmlContent += `
                <div class="card">
                    <div>
                        <div class="card-header">
                            <h3>${sanitizeHTML(trial.FormulationName)}</h3>
                            ${companyLogo ? `<img src="${companyLogo}" class="logo" alt="Logo">` : ''}
                        </div>
                        <div class="card-body">
                            <p><strong>Investigator:</strong> ${sanitizeHTML(trial.InvestigatorName)}</p>
                            <p><strong>Date:</strong> ${new Date(trial.Date).toLocaleDateString()}</p>
                            <p><strong>Dosage:</strong> ${sanitizeHTML(trial.Dosage)}</p>
                        </div>
                    </div>
                    <div class="card-footer">
                        ${qrCodeUrl ? `<img src="${qrCodeUrl}" class="qr-code">` : ''}
                    </div>
                </div>`;
                }

                htmlContent += `</div></body></html>`;
                printWindow.document.write(htmlContent);
                printWindow.document.close();
                setTimeout(() => { printWindow.focus(); printWindow.print(); printWindow.close(); }, 500);
            }

            async function generateCardsPdf() {
                if (state.selectedTrials.length === 0) return showToast('No trials selected.', 'error');
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF();
                let y = 10;

                state.selectedTrials.forEach((id, index) => {
                    const trial = state.trials.find(t => t.ID === id);
                    if (!trial) return;
                    if (index > 0 && index % 2 === 0) { doc.addPage(); y = 10; }

                    doc.setFontSize(16);
                    doc.text(trial.FormulationName || 'Trial', 10, y);
                    y += 10;
                    doc.setFontSize(12);
                    doc.text(`Investigator: ${trial.InvestigatorName || '-'}`, 10, y);
                    y += 7;
                    doc.text(`Date: ${new Date(trial.Date).toLocaleDateString()}`, 10, y);
                    y += 7;
                    doc.text(`Result: ${trial.Result || '-'}`, 10, y);
                    y += 15;

                    // Add more details or photos here...
                    y += 20;
                });

                doc.save('trial-cards.pdf');
            }

            function generateTrialCards() {
                return state.selectedTrials.map(id => {
                    const trial = state.trials.find(t => t.ID === id);
                    if (!trial) return '';
                    return `<div class="bg-white p-6 rounded-xl border border-gray-200 shadow-sm break-inside-avoid">
    <div class="flex justify-between items-start mb-4">
        <div>
            <h3 class="font-bold text-xl">${sanitizeHTML(trial.FormulationName)}</h3>
            <p class="text-gray-500 text-sm">${new Date(trial.Date).toLocaleDateString()}</p>
        </div>
        <span
            class="px-3 py-1 rounded-full text-sm font-bold result-${(trial.Result || 'none').toLowerCase()}">${trial.Result
                        || 'None'}</span>
    </div>
    <div class="grid grid-cols-2 gap-4 text-sm text-gray-700">
        <p><strong>Investigator:</strong> ${sanitizeHTML(trial.InvestigatorName)}</p>
        <p><strong>Location:</strong> ${sanitizeHTML(trial.Location)}</p>
        <p><strong>Dosage:</strong> ${sanitizeHTML(trial.Dosage)}</p>
        <p><strong>Status:</strong> ${String(trial.IsCompleted).toLowerCase() === 'true' ? 'Completed' : 'Active'}</p>
    </div>
    <div class="mt-4 pt-4 border-t flex justify-end">
        <div id="qr-${trial.ID}"></div>
    </div>
</div>`;
                }).join('');
            }





            // --- CHART RENDERER (Moved to Root Scope) ---
            function renderProjectAnalysisCharts(project) {
                if (!project || !project.AnalysisResults) return;

                const results = project.AnalysisResults;
                const dats = Object.keys(results).sort((a, b) => parseInt(a) - parseInt(b));
                if (dats.length === 0) return;

                // 1. WCE Over Time Chart
                const wceCtx = document.getElementById('project-wce-chart');
                if (wceCtx) {
                    const treatmentNames = [...new Set(Object.values(results).flatMap(r => r.treatmentStats.map(ts => {
                        const f = state.formulations.find(form => form.ID === ts.treatmentId);
                        return f ? f.Name : ts.treatmentId;
                    })))];

                    const datasets = treatmentNames.map((name, index) => {
                        const dataPoints = dats.map(dat => {
                            const res = results[dat];
                            const f = state.formulations.find(form => form.Name === name);
                            const id = f ? f.ID : name;

                            const stat = res.treatmentStats.find(ts => ts.treatmentId === id || state.formulations.find(x => x.ID === ts.treatmentId)?.Name === name);
                            return stat ? stat.wce : 0;
                        });

                        const color = getColorForIndex(index);

                        return {
                            label: name,
                            data: dataPoints,
                            borderColor: color,
                            backgroundColor: color,
                            fill: false,
                            tension: 0.1
                        };
                    });

                    if (state.charts.projectWce) state.charts.projectWce.destroy();
                    state.charts.projectWce = new Chart(wceCtx, {
                        type: 'line',
                        data: {
                            labels: dats.map(d => `${d} DAT`),
                            datasets: datasets
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { position: 'bottom' },
                                title: { display: true, text: '% Weed Control Efficiency' }
                            },
                            scales: {
                                y: { beginAtZero: true, max: 100, title: { display: true, text: '% WCE' } }
                            }
                        }
                    });
                }

                // 2. Performance Bar Chart (Last DAT)
                const perfCtx = document.getElementById('project-performance-chart');
                if (perfCtx) {
                    const lastDat = dats[dats.length - 1];
                    const res = results[lastDat];
                    const stats = res.treatmentStats;

                    const labels = stats.map(ts => {
                        const f = state.formulations.find(form => form.ID === ts.treatmentId);
                        return f ? f.Name : ts.treatmentId;
                    });
                    const data = stats.map(ts => ts.mean);
                    const bgColors = stats.map(ts => {
                        if (ts.rank === 'Superior') return 'rgba(20, 184, 166, 0.7)'; // Teal
                        if (ts.rank === 'Inferior') return 'rgba(239, 68, 68, 0.7)'; // Red
                        if (ts.rank === 'Control') return 'rgba(245, 158, 11, 0.7)'; // Amber
                        return 'rgba(100, 116, 139, 0.7)'; // Slate
                    });

                    if (state.charts.projectPerf) state.charts.projectPerf.destroy();
                    state.charts.projectPerf = new Chart(perfCtx, {
                        type: 'bar',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: `Mean ${project.Metric} (${lastDat} DAT)`,
                                data: data,
                                backgroundColor: bgColors,
                                borderColor: bgColors.map(c => c.replace('0.7', '1')),
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false },
                                title: { display: true, text: `Efficacy at ${lastDat} DAT` }
                            },
                            scales: {
                                y: { beginAtZero: true, title: { display: true, text: project.Metric } }
                            }
                        }
                    });
                }
            }

            function getColorForIndex(index) {
                const colors = [
                    '#0d9488', // Teal
                    '#ef4444', // Red
                    '#f59e0b', // Amber
                    '#3b82f6', // Blue
                    '#8b5cf6', // Violet
                    '#ec4899', // Pink
                    '#10b981', // Emerald
                    '#6366f1'  // Indigo
                ];
                return colors[index % colors.length];
            }


            // --- STARTUP ---

            // --- SETTINGS LOGIC ---
            function bindSettingsEvents() {
                document.body.addEventListener('change', (e) => {
                    if (e.target.id === 'settings-logo-input') {
                        const file = e.target.files[0];
                        if (file) {
                            const reader = new FileReader();
                            reader.onload = (readerEvent) => {
                                const base64 = readerEvent.target.result;
                                document.getElementById('settings-logo-preview').src = base64;
                                document.getElementById('settings-logo-hidden').value = base64;
                            };
                            reader.readAsDataURL(file);
                        }
                    }
                });
            }

            // --- CONSOLIDATED HIGH-TECH OFFLINE SYNC LOGIC ---
            function saveSyncQueue() {
                try {
                    localStorage.setItem('herbicide_sync_queue', JSON.stringify(state.syncQueue));
                } catch (e) {
                    console.error("Failed to save sync queue:", e);
                }
            }

            function renderSyncStatus() {
                const el = document.getElementById('sync-status');
                if (!el) return;

                const pending = state.syncQueue.filter(s => s.status === 'pending' || s.status === 'failed').length;
                const uploading = state.syncQueue.filter(s => s.status === 'uploading').length;

                if (pending === 0 && uploading === 0) {
                    el.innerHTML = '';
                    el.classList.add('hidden');
                    return;
                }

                el.classList.remove('hidden');
                let html = '';
                if (uploading > 0) {
                    html = `<div class="flex items-center gap-2 text-teal-600 font-bold animate-pulse">
                        <i data-lucide="upload-cloud" class="h-4 w-4"></i>
                        <span>Syncing ${uploading} items...</span>
                    </div>`;
                } else if (pending > 0) {
                    html = `<div class="flex items-center gap-2 text-slate-500 font-medium">
                        <i data-lucide="clock" class="h-4 w-4"></i>
                        <span>${pending} updates queued</span>
                    </div>`;
                }

                el.innerHTML = html;
                if (window.lucide) lucide.createIcons();
            }

            let _isSyncProcessing = false;
            async function processSyncQueue() {
                if (_isSyncProcessing || state.syncQueue.length === 0) return;
                _isSyncProcessing = true;

                const queueStartTime = Date.now();
                console.log(`%c[HighTechSync] 🚀 Starting Sync Process | Queue: ${state.syncQueue.length} items`, "color: #0d9488; font-weight: bold; font-size: 1.1em;");
                renderSyncStatus();

                let itemsToProcess = state.syncQueue.filter(item =>
                    item.status === 'pending' ||
                    item.status === 'failed' ||
                    item.status === 'uploading'
                );

                let isFirstItem = true;

                for (const item of itemsToProcess) {
                    if (!navigator.onLine) {
                        console.warn("[HighTechSync] 📵 Offline detected. Pausing sync.");
                        break;
                    }

                    const itemStartTime = Date.now();
                    const itemLabel = item.photo.fileName || item.id;

                    if (!isFirstItem || (item.attempts || 0) > 0) {
                        const waitTime = Math.min(10000, (isFirstItem ? 0 : 500) + ((item.attempts || 0) * 2000));
                        if (waitTime > 0) {
                            console.log(`[HighTechSync] Waiting ${waitTime}ms (backoff)...`);
                            await new Promise(resolve => setTimeout(resolve, waitTime));
                        }
                    }
                    isFirstItem = false;

                    // RE-CHECK DATA INTEGRITY
                    const trial = state.trials.find(t => t.ID === item.trialId);
                    if (trial) {
                        const isWeed = item.type === 'weed_upload';
                        let photos = isWeed ? safeJsonParse(trial.WeedPhotosJSON) : safeJsonParse(trial.PhotoURLs);
                        if (photos.some(p => p.tempId === item.photo.tempId && p.url)) {
                            console.log(`[HighTechSync] ✅ Already synced: ${itemLabel}`);
                            item.status = 'completed';
                            state.syncQueue = state.syncQueue.filter(i => i.id !== item.id);
                            saveSyncQueue();
                            continue;
                        }
                    }

                    item.status = 'uploading';
                    saveSyncQueue();
                    renderSyncStatus();

                    try {
                        const payloadSize = Math.round(item.photo.fileData.length / 1024);
                        console.group(`[Syncing Item] ${itemLabel} (${payloadSize} KB)`);
                        console.log(`Start Time: ${new Date(itemStartTime).toLocaleTimeString()}`);

                        const isWeed = item.type === 'weed_upload';

                        // 1. ATOMIC UPLOAD
                        if (!state.settings.folderId) throw new Error("Folder ID missing.");

                        const uploadStart = Date.now();
                        console.log(`[Step 1/3] Uploading to Google Drive...`);

                        const result = await apiCall('uploadPhoto', {
                            trialId: item.trialId,
                            fileData: item.photo.fileData,
                            mimeType: item.photo.mimeType,
                            fileName: item.photo.fileName,
                            isWeed: isWeed,
                            label: item.photo.label,
                            date: item.photo.date
                        }, false);

                        const uploadTime = ((Date.now() - uploadStart) / 1000).toFixed(2);
                        console.log(`%c✔ Drive Upload Complete (${uploadTime}s)`, "color: #16a34a;");

                        if (result && result._errType) throw new Error(`Server Error: ${result.message}`);
                        if (!result?.url && !result?.id) throw new Error('Empty response from script.');

                        const publicUrl = result.url || result.fileUrl;
                        console.log(`Cloud URL: ${publicUrl}`);

                        // 2. INTERNAL STATE & BACKGROUND AI
                        if (trial) {
                            let photos = isWeed ? safeJsonParse(trial.WeedPhotosJSON) : safeJsonParse(trial.PhotoURLs);
                            const idx = photos.findIndex(p => p.tempId === item.photo.tempId);

                            if (idx > -1) {
                                photos[idx].url = publicUrl;
                                if (!photos[idx].label || photos[idx].label === "Processing...") {
                                    photos[idx].label = item.photo.label || `Synced ${new Date().toLocaleDateString()}`;
                                }
                                delete photos[idx].fileData;
                            } else {
                                photos.push({ url: publicUrl, date: item.photo.date, label: item.photo.label || '', tempId: item.photo.tempId });
                            }

                            if (isWeed) trial.WeedPhotosJSON = JSON.stringify(photos); else trial.PhotoURLs = JSON.stringify(photos);

                            // 3. PERSIST PHOTO LINK TO SHEET
                            const handshakeStart = Date.now();
                            console.log(`[Step 2/3] Updating Spreadsheet...`);

                            await apiCall('updateTrialRecord', {
                                ID: trial.ID,
                                [isWeed ? 'WeedPhotosJSON' : 'PhotoURLs']: trial[isWeed ? 'WeedPhotosJSON' : 'PhotoURLs']
                            }, false);

                            const handshakeTime = ((Date.now() - handshakeStart) / 1000).toFixed(2);
                            console.log(`%c✔ Spreadsheet Handshake Complete (${handshakeTime}s)`, "color: #16a34a;");

                            refreshRelevantUI(item.trialId, item.type);

                            // 4. FIRE-AND-FORGET AI
                            console.log(`[Step 3/3] Launching Background AI Analysis (Non-blocking)...`);
                            (async () => {
                                const aiStart = Date.now();
                                try {
                                    if (isWeed) {
                                        const ids = await identifyWeedsFromPhoto(item.photo.fileData, item.photo.mimeType);
                                        if (ids?.length > 0) {
                                            const t = state.trials.find(x => x.ID === item.trialId);
                                            let wPhotos = safeJsonParse(t.WeedPhotosJSON);
                                            const pIdx = wPhotos.findIndex(p => p.tempId === item.photo.tempId);
                                            if (pIdx > -1) {
                                                wPhotos[pIdx].identifications = ids;
                                                if (!wPhotos[pIdx].label || wPhotos[pIdx].label.includes('Synced')) wPhotos[pIdx].label = ids.map(i => i.name).join(', ');
                                                t.WeedPhotosJSON = JSON.stringify(wPhotos);
                                                await apiCall('updateTrialRecord', { ID: t.ID, WeedPhotosJSON: t.WeedPhotosJSON }, false);
                                                refreshRelevantUI(item.trialId, 'weed_upload');
                                                console.log(`[AI Background] Weed ID finished in ${((Date.now() - aiStart) / 1000).toFixed(2)}s`);
                                            }
                                        }
                                    } else {
                                        // 1. Proactive Weed ID (If missing species or first photo)
                                        const currentWeeds = (trial.WeedSpecies || '').trim();
                                        const currentPhotos = safeJsonParse(trial.PhotoURLs);

                                        // Run if NO weeds are listed yet, OR if this is the first photo
                                        if (!currentWeeds || currentPhotos.length <= 1) {
                                            console.log('[AI Background] Triggering proactive Weed ID on first photo...');
                                            const ids = await identifyWeedsFromPhoto(item.photo.fileData, item.photo.mimeType);
                                            if (ids && ids.length > 0) {
                                                const newNames = ids.map(i => i.name).filter(n => n);
                                                const uniqueNames = [...new Set([...(currentWeeds ? currentWeeds.split(', ') : []), ...newNames])];
                                                trial.WeedSpecies = uniqueNames.join(', ');
                                                await apiCall('updateTrialRecord', { ID: trial.ID, WeedSpecies: trial.WeedSpecies }, false);
                                                console.log('[AI Background] Proactive Weed ID updated species list:', trial.WeedSpecies);
                                                // Identify common weeds for better UX
                                                const common = ids.flatMap(i => i.commonNames || []).join(', ');
                                                if (common) showToast(`Identified potential weeds: ${common}`, 'info');
                                            }
                                        }

                                        // 2. Efficacy Analysis (If enabled)
                                        if (state.settings.autoAnalyzePhotos) {
                                            const eff = await analyzePhotoForEfficacy(item.photo.fileData, item.photo.mimeType);
                                            if (eff) {
                                                const t = state.trials.find(x => x.ID === item.trialId);
                                                let eData = safeJsonParse(t.EfficacyDataJSON);
                                                const obsDate = new Date(item.photo.date);
                                                const tDate = new Date(t.Date);
                                                const daa = Math.round((obsDate.getTime() - tDate.getTime()) / (1000 * 60 * 60 * 24));

                                                eData.push({ date: obsDate.toISOString().split('T')[0], daa: daa >= 0 ? daa : 0, phyto: eff.phyto, notes: `AI Background analysis from photo on ${obsDate.toLocaleDateString()}`, photoUrl: publicUrl, weedDetails: eff.weedDetails });
                                                t.EfficacyDataJSON = JSON.stringify(eData);
                                                t.AISummariesJSON = '{}';
                                                await apiCall('updateTrialRecord', { ID: t.ID, EfficacyDataJSON: t.EfficacyDataJSON, AISummariesJSON: '{}' }, false);
                                                refreshRelevantUI(item.trialId, 'general_upload');
                                                console.log(`[AI Background] Efficacy finished in ${((Date.now() - aiStart) / 1000).toFixed(2)}s`);
                                            }
                                        }
                                    }
                                } catch (aiErr) { console.warn(`[AI Background] Failed:`, aiErr.message); }
                            })();
                        }

                        item.status = 'completed';
                        state.syncQueue = state.syncQueue.filter(i => i.id !== item.id);

                        const totalItemTime = ((Date.now() - itemStartTime) / 1000).toFixed(2);
                        console.log(`%cTotal Item Process Time: ${totalItemTime}s`, "font-weight: bold; color: #0d9488;");
                        console.groupEnd();

                    } catch (error) {
                        console.error(`%c[Sync Error] ${itemLabel} Failed: ${error.message}`, "color: #dc2626; font-weight: bold;");
                        item.attempts = (item.attempts || 0) + 1;
                        item.status = error.message.includes('Timeout') || error.message.includes('fetch') ? 'pending' : 'failed';
                        item.lastError = error.message;
                        console.groupEnd();
                    }
                    saveSyncQueue();
                    renderSyncStatus();
                }

                _isSyncProcessing = false;
                const totalQueueTime = ((Date.now() - queueStartTime) / 1000).toFixed(2);
                console.log(`[HighTechSync] Queue Finished | Total Time: ${totalQueueTime}s`);

                // Feedback for user
                const successCount = itemsToProcess.filter(i => i.status === 'completed').length;
                if (successCount > 0) {
                    showToast(`Sync complete! ${successCount} items processed.`, 'success');
                } else if (itemsToProcess.some(i => i.status === 'failed')) {
                    showToast('Sync finished with errors. Will retry automatically.', 'warning');
                }

                renderSyncStatus();
            }

            function refreshRelevantUI(trialId, type) {
                const modal = document.getElementById('weed-modal');
                if (modal && type === 'weed_upload' && !modal.classList.contains('hidden')) {
                    const trial = state.trials.find(t => t.ID === trialId);
                    const grid = document.getElementById('weed-photo-grid');
                    if (grid) grid.innerHTML = safeJsonParse(trial.WeedPhotosJSON).map((p, i) => render.weedPhotoCard(p, trialId, i)).join('');
                }

                if (document.getElementById('trial-detail-modal') && !document.getElementById('trial-detail-modal').classList.contains('hidden')) {
                    openTrialDetail(trialId);
                } else {
                    applyFilters();
                }
            }

            window.addEventListener('online', () => {
                showToast('Network Detected. Testing connection...', 'info');
                // 5-second "Warm up" to ensure DNS and IP are stable
                setTimeout(processSyncQueue, 5000);
            });

            // --- MISSING UI HELPERS ---
            function updateOrganiseBar() {
                // Correct ID is 'selection-bar' (from CSS/HTML) not 'organise-bar'
                const bar = document.getElementById('selection-bar');
                if (!bar) { console.warn('Selection bar element not found'); return; }

                const count = state.selectedTrials.length;
                const countEl = document.getElementById('selected-items-count');
                if (countEl) countEl.textContent = `${count} selected`;

                if (count > 0) {
                    bar.classList.remove('hidden');
                    // Force display if classList fails to override !important hidden rule
                    bar.style.display = 'flex';
                } else {
                    bar.classList.add('hidden');
                    bar.style.display = 'none';
                }
            }

            // Expose to window for global access if needed
            window.updateOrganiseBar = updateOrganiseBar;

            window.calculateAndSaveTrialStats = async function (trialId) {
                const trial = state.trials.find(t => t.ID === trialId);
                if (!trial) return;

                showToast('Calculating statistics...', 'info');

                try {
                    const efficacyData = safeJsonParse(trial.EfficacyDataJSON, []);
                    if (efficacyData.length === 0) throw new Error("No efficacy data logged. Please add observations first.");

                    const allWeedSpecies = [...new Set(efficacyData.flatMap(obs => (obs.weedDetails || []).map(wc => wc.species.trim())))];

                    if (allWeedSpecies.length === 0) {
                        // For new trials or those without observations, this is normal.
                        // Do not throw an error, just exit gracefully.
                        console.log("No weed species data found for stats calculation (Normal for new trials).");
                        return;
                    }

                    // Calculate WCE for each species
                    const wceResults = allWeedSpecies.map(species => {
                        const speciesObs = efficacyData.map(obs => {
                            const detail = (obs.weedDetails || []).find(d => d.species === species);
                            return detail ? { day: parseFloat(obs.daa), cover: parseFloat(detail.cover) } : null;
                        }).filter(Boolean).sort((a, b) => a.day - b.day);

                        if (speciesObs.length < 1) return null;

                        const initial = speciesObs[0];
                        const final = speciesObs[speciesObs.length - 1];

                        // If only 1 data point, assume initial was 100? No, unsafe.
                        // For single point, just show cover.
                        // But for WCE we need 2 points OR assume day 0 was 100% or use a baseline.
                        // Here we just use First vs Last recorded.

                        let wce = 0;
                        if (speciesObs.length >= 2 && initial.cover > 0) {
                            wce = ((initial.cover - final.cover) / initial.cover) * 100;
                        } else if (initial.cover > 0 && final.cover === 0) {
                            wce = 100;
                        }

                        let rating = 'Poor';
                        if (wce >= 95) rating = 'Excellent';
                        else if (wce >= 85) rating = 'Good';
                        else if (wce >= 70) rating = 'Fair';

                        return {
                            species,
                            initialCover: initial.cover,
                            finalCover: final.cover,
                            wce: wce,
                            controlRating: rating
                        };
                    }).filter(Boolean);

                    const stats = {
                        wce: wceResults,
                        calculatedAt: new Date().toISOString()
                    };

                    trial.StatisticsJSON = JSON.stringify(stats);

                    // Persist
                    await apiCall('updateTrialRecord', { id: trialId, StatisticsJSON: trial.StatisticsJSON }, false);

                    showToast('Statistics calculated and saved.', 'success');

                    // Refresh view
                    openTrialDetail(trialId);
                    setTimeout(() => {
                        const btn = document.querySelector('button[data-tab="stats"]');
                        if (btn) btn.click();
                    }, 300);

                } catch (e) {
                    console.error(e);
                    showToast(e.message, 'error');
                }
            };

            // --- CONSOLE DEBUGGER OVERLAY ---
            (function () {
                const consoleDiv = document.createElement('div');
                consoleDiv.id = 'app-debug-console';
                consoleDiv.style.cssText = `position: fixed; bottom: 0; right: 0; width: 400px; height: 200px; background: rgba(0,0,0,0.85); color: #0f0; font-family: monospace; font-size: 11px; overflow-y: auto; z-index: 99999; padding: 10px; border-top-left-radius: 8px; display: none; pointer-events: none; opacity: 0.8;`;
                document.body.appendChild(consoleDiv);

                // Add toggle button to settings page or keyboard shortcut (Ctrl+Backtick)
                document.addEventListener('keydown', e => {
                    if (e.ctrlKey && e.key === '`') {
                        consoleDiv.style.display = consoleDiv.style.display === 'none' ? 'block' : 'none';
                        // Enable pointer events when visible
                        consoleDiv.style.pointerEvents = consoleDiv.style.display === 'block' ? 'auto' : 'none';
                    }
                });

                function logToScreen(type, args) {
                    const line = document.createElement('div');
                    line.style.borderBottom = '1px solid #333';
                    line.style.padding = '2px 0';
                    line.style.color = type === 'error' ? '#ff6b6b' : type === 'warn' ? '#fca5a5' : '#0f0';
                    try {
                        line.textContent = `[${type.toUpperCase()}] ` + args.map(a =>
                            typeof a === 'object' ? JSON.stringify(a) : String(a)
                        ).join(' ');
                    } catch (e) { line.textContent = '[Log Error]'; }
                    consoleDiv.appendChild(line);
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                }

                const originalLog = console.log;
                const originalError = console.error;
                const originalWarn = console.warn;

                console.log = function (...args) { logToScreen('log', args); originalLog.apply(console, args); };
                console.error = function (...args) { logToScreen('error', args); originalError.apply(console, args); };
                console.warn = function (...args) { logToScreen('warn', args); originalWarn.apply(console, args); };

                console.log("Debug Console Initialized. Press Ctrl + ` to toggle.");
            })();


            // --- GLOBAL EVENT LISTENERS (Delegation) ---
            document.addEventListener('click', (e) => {
                const btn = e.target.closest('[data-action]');
                if (!btn) return;

                const action = btn.dataset.action;
                const id = btn.dataset.id;

                try {
                    // Handle missing actions that were not delegated elsewhere
                    if (action === 'delete-project') {
                        deleteProject(id);
                    }
                    else if (action === 'open-protocol-modal') {
                        const projectId = state.activeProjectId || id;
                        if (projectId) {
                            if (typeof openProtocolModal === 'function') {
                                openProtocolModal(projectId);
                            } else {
                                console.error('openProtocolModal function is blocked or missing.');
                                showToast('Error: Application logic missing. Reload page.', 'error');
                            }
                        } else {
                            console.warn('No active project ID found for protocol modal.');
                            showToast('Please open a project first.', 'warn');
                        }
                    }
                    else if (action === 'generate-regulatory-report') {
                        const projectId = id || state.activeProjectId;
                        if (projectId) {
                            generateRegulatoryProjectReport(projectId);
                        }
                    }
                    else if (action === 'save-protocol') {
                        saveProtocol();
                    }
                    else if (action === 'run-analysis') {
                        render.scientificReport(id);
                    }
                    else if (action === 'recalculate-daa') {
                        recalculateAllDAA(id);
                    }
                    else if (action === 'run-analysis') {
                        render.scientificReport(id);
                    }
                } catch (err) {
                    console.error('Action Handler Error:', err);
                    showToast('Action failed. Check console.', 'error');
                }
            });

            async function deleteProject(id) {
                const project = state.projects.find(p => p.ID === id);
                if (!project) return;

                if (!confirm(`Are you sure you want to delete the project "${project.Name}"? This will delete all associated blocks and trials.`)) {
                    return;
                }

                showToast(`Deleting project "${project.Name}"...`, 'info');

                try {
                    await apiCall('deleteProject', { id });

                    // Update local state
                    state.projects = state.projects.filter(p => p.ID !== id);
                    state.blocks = state.blocks.filter(b => b.ProjectID !== id);
                    state.trials = state.trials.filter(t => t.ProjectID !== id);

                    showToast('Project deleted successfully.', 'success');

                    // Refresh view
                    if (state.activeProjectId === id) {
                        switchPage('projects');
                    } else {
                        render.projects();
                    }
                } catch (error) {
                    console.error('Delete Project Error:', error);
                    showToast('Failed to delete project: ' + error.message, 'error');
                }
            }

            // --- RESTORED PROTOCOL FUNCTIONS ---
            // Global bridge function for Scientific Report (accessible from onclick)
            window.openScientificReport = function (projectId) {
                console.log('🌉 Bridge function called with projectId:', projectId);
                if (typeof render !== 'undefined' && render.scientificReport) {
                    render.scientificReport(projectId);
                } else {
                    console.error('render.scientificReport not available');
                    alert('Feature not loaded. Please refresh the page.');
                }
            };

            // Global function to recalculate DAA for all observations in a project
            window.recalculateAllDAA = async function (projectId) {
                if (!projectId) projectId = state.activeProjectId;
                if (!projectId) {
                    showToast('No project selected', 'error');
                    return;
                }

                console.log('🔄 Recalculating DAA for project:', projectId);
                showToast('Recalculating DAA...', 'info');

                const trials = state.trials.filter(t => t.ProjectID === projectId);
                let totalUpdated = 0;
                let trialsModified = 0;

                for (const trial of trials) {
                    const trialDate = new Date(trial.Date);
                    const efficacyData = safeJsonParse(trial.EfficacyDataJSON) || [];
                    const photos = safeJsonParse(trial.PhotoURLs) || [];

                    if (efficacyData.length === 0) continue;

                    let trialUpdated = false;
                    console.log(`  📋 Trial: ${trial.FormulationName}, ${efficacyData.length} observations, ${photos.length} photos`);

                    // For each observation, try to find matching photo and recalculate DAA
                    efficacyData.forEach((obs, idx) => {
                        const oldDAA = obs.daa;

                        // Try to match observation with photo by index or timestamp
                        const matchingPhoto = photos.find(p => p.date && new Date(p.date).getTime() === obs.timestamp)
                            || photos[idx]
                            || photos[0]; // Fallback to first photo

                        if (matchingPhoto && matchingPhoto.date) {
                            const photoDate = new Date(matchingPhoto.date);
                            const newDAA = Math.round((photoDate.getTime() - trialDate.getTime()) / (1000 * 60 * 60 * 24));
                            obs.daa = newDAA >= 0 ? newDAA : 0;

                            if (oldDAA !== obs.daa) {
                                console.log(`    ✏️ Obs ${idx}: DAA ${oldDAA} → ${obs.daa} (Photo: ${matchingPhoto.date})`);
                                totalUpdated++;
                                trialUpdated = true;
                            }
                        } else {
                            console.warn(`    ⚠️ Obs ${idx}: No matching photo with date, keeping DAA ${oldDAA}`);
                        }
                    });

                    // Save updated EfficacyDataJSON if modified
                    if (trialUpdated) {
                        trial.EfficacyDataJSON = JSON.stringify(efficacyData);
                        await apiCall('updateTrialRecord', { ID: trial.ID, EfficacyDataJSON: trial.EfficacyDataJSON }, false);
                        trialsModified++;
                    }
                }


                console.log(`✅ Recalculation complete: ${totalUpdated} observations updated across ${trialsModified} trials`);
                showToast(`✅ Updated DAA for ${totalUpdated} observations in ${trialsModified} trials`, 'success');

                // Note: Refresh page (F5) to see updated values in dashboard/reports
            };

            window.openProtocolModal = function (projectId) {
                const project = state.projects.find(p => p.ID === projectId);
                if (!project) return;
                state.activeProjectId = projectId; // Ensure active project is set

                const protocol = safeJsonParse(project.ProtocolJSON) || {};

                // Populate fields
                setVal('protocol-investigator', protocol.investigator || project.Investigator || '');
                setVal('protocol-location', protocol.location || project.Location || '');
                setVal('protocol-crop', protocol.crop || '');
                setVal('protocol-plot-size', protocol.plotSize || '');
                setVal('protocol-spray-vol', protocol.sprayVol || '');
                setVal('protocol-nozzle', protocol.nozzle || '');
                setVal('protocol-pressure', protocol.pressure || '');
                setVal('protocol-equipment', protocol.equipment || '');
                setVal('protocol-dates', protocol.dates || '');

                const modal = document.getElementById('protocol-settings-modal');
                if (modal) modal.classList.remove('hidden');
            };

            window.saveProtocol = async function () {
                const projectId = state.activeProjectId;
                if (!projectId) return;

                const protocol = {
                    investigator: getVal('protocol-investigator'),
                    location: getVal('protocol-location'),
                    crop: getVal('protocol-crop'),
                    plotSize: getVal('protocol-plot-size'),
                    sprayVol: getVal('protocol-spray-vol'),
                    nozzle: getVal('protocol-nozzle'),
                    pressure: getVal('protocol-pressure'),
                    equipment: getVal('protocol-equipment'),
                    dates: getVal('protocol-dates')
                };

                const project = state.projects.find(p => p.ID === projectId);
                if (project) {
                    project.ProtocolJSON = JSON.stringify(protocol);
                    // Also update legacy fields if they exist
                    project.Investigator = protocol.investigator;
                    project.Location = protocol.location;

                    try {
                        await apiCall('updateProject', {
                            id: projectId,
                            ProtocolJSON: project.ProtocolJSON,
                            Investigator: project.Investigator,
                            Location: project.Location
                        });
                        showToast('Protocol saved successfully', 'success');
                        closeModal();
                    } catch (e) {
                        showToast('Error saving protocol: ' + e.message, 'error');
                    }
                }
            };

            window.generateRegulatoryProjectReport = async function (projectId) {
                const project = state.projects.find(p => p.ID === projectId);
                if (!project) return;

                showToast('Generating report...', 'info');
                try {
                    const { jsPDF } = window.jspdf;
                    const doc = new jsPDF();

                    doc.setFontSize(18);
                    doc.text(`Regulatory Report: ${project.Name}`, 14, 22);

                    doc.setFontSize(12);
                    doc.text(`Generated: ${new Date().toLocaleDateString()}`, 14, 32);

                    const protocol = safeJsonParse(project.ProtocolJSON) || {};
                    let y = 45;

                    doc.setFontSize(14);
                    doc.text('Protocol Details', 14, y);
                    y += 10;
                    doc.setFontSize(10);

                    Object.entries(protocol).forEach(([key, val]) => {
                        doc.text(`${key}: ${val}`, 14, y);
                        y += 7;
                    });

                    y += 10;
                    doc.setFontSize(14);
                    doc.text('Trial Summaries', 14, y);
                    y += 10;

                    const trials = state.trials.filter(t => t.ProjectID === projectId);
                    doc.setFontSize(10);

                    trials.forEach(trial => {
                        if (y > 270) { doc.addPage(); y = 20; }
                        doc.text(`- ${trial.FormulationName}: ${trial.Result || 'N/A'} (Result)`, 14, y);
                        y += 7;
                    });

                    doc.save(`${project.Name}_Regulatory_Report.pdf`);
                    showToast('Report downloaded.', 'success');
                } catch (e) {
                    console.error('Report Gen Error:', e);
                    showToast('Error generating report', 'error');
                }
            };

            function setVal(id, val) {
                const el = document.getElementById(id);
                if (el) el.value = val;
            }

            function getVal(id) {
                const el = document.getElementById(id);
                return el ? el.value : '';
            }

            // Handle Checkbox Changes (Delegation)
            document.addEventListener('change', (e) => {
                if (e.target.dataset.action === 'select-trial') {
                    const id = e.target.dataset.id;
                    if (e.target.checked) {
                        if (!state.selectedTrials.includes(id)) state.selectedTrials.push(id);
                    } else {
                        state.selectedTrials = state.selectedTrials.filter(tid => tid !== id);
                    }
                    if (window.updateOrganiseBar) window.updateOrganiseBar();
                }
            });

            bindEventListeners();
            bindSettingsEvents();
            initializeApp();

            // =============================================
            // SCIENTIFIC ANALYSIS ENGINE (RCBD)
            // =============================================
            class AnalysisEngine {
                constructor(projectId, state) {
                    this.projectId = projectId;
                    this.state = state; // Global state reference
                    this.trials = state.trials.filter(t => t.ProjectID === projectId);
                    this.blocks = state.blocks.filter(b => b.ProjectID === projectId);

                    // Identify treatments (Formulations)
                    this.treatments = [...new Set(this.trials.map(t => t.FormulationName))];

                    // Identify UTC (Untreated Control)
                    // Logic: Look for "Control" or "Untreated" in name, or an explicit flag if we had one.
                    this.utcName = this.treatments.find(t =>
                        t.toLowerCase().includes('control') ||
                        t.toLowerCase().includes('untreated') ||
                        t.toLowerCase().includes('check')
                    );
                }

                getReplications(treatmentName) {
                    return this.trials.filter(t => t.FormulationName === treatmentName);
                }

                // Get aggregated data for a specific metric (e.g., 'yield', 'phyto', 'cover')
                // For 'cover', we need to specify which weed species or 'total'
                getData(metric, species = null, daa = null) {
                    console.log(`[AnalysisEngine.getData] Metric: ${metric}, Species: ${species}, DAA: ${daa}`);
                    const data = {};

                    this.treatments.forEach(trt => {
                        const reps = this.getReplications(trt);
                        data[trt] = reps.map((r, idx) => {
                            if (metric === 'yield') {
                                console.log(`  [${trt}] Rep ${idx}: Yield = ${r.Yield || 0}`);
                                return parseFloat(r.Yield || 0);
                            }

                            // Parse JSON data for other metrics
                            const eff = safeJsonParse(r.EfficacyDataJSON, []);
                            console.log(`  [${trt}] Rep ${idx}: EfficacyData observations = ${eff.length}`);
                            if (eff.length > 0) {
                                console.log(`    Observations:`, eff.map(e => `DAA ${e.daa}`).join(', '));
                            }

                            if (eff.length === 0) return 0;

                            // Find observation closest to DAA if provided, else max DAA (final)
                            let obs;
                            if (daa !== null) {
                                obs = eff.find(e => e.daa === daa) || eff[eff.length - 1];
                            } else {
                                obs = eff.sort((a, b) => b.daa - a.daa)[0]; // Last observation
                            }

                            console.log(`    Selected observation: DAA ${obs?.daa}, Phyto: ${obs?.phyto}`);

                            if (!obs) return 0;

                            if (metric === 'phyto') return parseFloat(obs.phyto || 0);

                            if (metric === 'cover') {
                                if (species) {
                                    const d = (obs.weedDetails || []).find(w => w.species === species);
                                    return d ? parseFloat(d.cover) : 0;
                                }
                                // Total cover
                                return (obs.weedDetails || []).reduce((sum, w) => sum + parseFloat(w.cover), 0);
                            }
                            return 0;
                        });
                    });

                    console.log('[AnalysisEngine.getData] Final data:', data);
                    return data;
                }

                // Main Analysis Method
                analyze(metric, species = null, daa = null) {
                    const dataMap = this.getData(metric, species, daa);
                    const treatments = Object.keys(dataMap);

                    // Flatten data for ANOVA: [[val, val], [val, val]]
                    const anovaData = treatments.map(t => dataMap[t]);

                    // 1. Calculate Means
                    const means = {};
                    treatments.forEach(t => {
                        means[t] = jStat.mean(dataMap[t]);
                    });

                    // 2. ANOVA (One-Way for RCBD simplification if block effect is ignored for now, 
                    // or we implement full RCBD ANOVA. For simplicity/MVP, we'll use One-Way but label it clearly)
                    // Note: jStat.anovaftest returns F-value. 
                    // To get full table we need to do manual SS calculations or use jStat extensively.

                    let anovaResults = this.calculateANOVA(anovaData);

                    // 3. Efficacy (Abbott's)
                    const efficacy = {};
                    if (this.utcName && means[this.utcName] > 0) {
                        treatments.forEach(t => {
                            // Abbott: (Control - Treated) / Control * 100
                            // Note: Only valid for "Coverage" or "Count". For "Yield", it's different.
                            if (metric === 'cover') {
                                efficacy[t] = ((means[this.utcName] - means[t]) / means[this.utcName]) * 100;
                            } else {
                                efficacy[t] = 0; // Not applicable
                            }
                        });
                    }

                    // 4. Fisher's LSD & Grouping
                    const lsdResults = this.getLetterGrouping(means, anovaResults.mse, anovaResults.dfError, anovaData[0].length);

                    const formattedGrouping = treatments.map(t => ({
                        name: t,
                        mean: means[t],
                        grouping: lsdResults.letters[t] || '-'
                    })).sort((a, b) => b.mean - a.mean);

                    return {
                        means,
                        efficacy,
                        anova: anovaResults,
                        lsdResults: { ...lsdResults, groupings: formattedGrouping },
                        grouping: formattedGrouping,
                        raw: dataMap
                    };
                }

                calculateANOVA(groups) {
                    // groups is array of arrays: [[r1, r2], [r1, r2]]
                    const flat = groups.flat();
                    const n = flat.length;
                    const k = groups.length; // Number of treatments
                    const reps = groups[0].length; // Assuming balanced design

                    const grandMean = jStat.mean(flat);

                    // SS Total
                    const ssTotal = flat.reduce((acc, val) => acc + Math.pow(val - grandMean, 2), 0);

                    // SS Treatments (Between)
                    let ssTreat = 0;
                    groups.forEach(g => {
                        ssTreat += reps * Math.pow(jStat.mean(g) - grandMean, 2);
                    });

                    // SS Error (Within)
                    const ssError = ssTotal - ssTreat;

                    // DF
                    const dfTreat = k - 1;
                    const dfTotal = n - 1;
                    const dfError = dfTotal - dfTreat;

                    // MS
                    const msTreat = ssTreat / dfTreat;
                    const msError = ssError / dfError; // This is MSE

                    // F-value
                    const fVal = msTreat / msError;

                    // P-value
                    const pVal = 1 - jStat.centralF.cdf(fVal, dfTreat, dfError);

                    return {
                        ssTreat, ssError, ssTotal,
                        dfTreat, dfError, dfTotal,
                        msTreat, msError: msError,
                        fVal, pVal
                    };
                }

                getLetterGrouping(meansObj, mse, dfError, reps) {
                    // Calculate LSD
                    // t-value for alpha=0.05 (two-tailed)
                    const alpha = 0.05;
                    // jStat.studentt.inv(p, df) returns x such that CDF(x) = p.
                    // For two-tailed 0.05, we want the value at 0.975
                    const tVal = jStat.studentt.inv(1 - (alpha / 2), dfError);

                    const lsd = tVal * Math.sqrt((2 * mse) / reps);

                    // Sort means descending
                    const sortedTreatments = Object.keys(meansObj).sort((a, b) => meansObj[b] - meansObj[a]);

                    const letters = {};
                    const alphabet = 'abcdefghijklmnopqrstuvwxyz';

                    // Greedy approach for Letter Grouping (Basic Approximation)
                    // 1. Assign 'a' to first.
                    // 2. Compare subsequent means to the 'current group' pivot.

                    let currentGroupIndex = 0;
                    let currentGroupPivot = sortedTreatments[0];

                    // Note: This logic is tricky. A standard CLD algorithm is recursive or uses line sweeping.
                    // Simplified: Overlapping Group Logic.

                    // Let's create cliques of non-significant treatments
                    const cliques = [];

                    for (let i = 0; i < sortedTreatments.length; i++) {
                        const t1 = sortedTreatments[i];
                        const clique = [t1];
                        for (let j = i + 1; j < sortedTreatments.length; j++) {
                            const t2 = sortedTreatments[j];
                            if (Math.abs(meansObj[t1] - meansObj[t2]) < lsd) {
                                clique.push(t2);
                            } else {
                                break; // sorted, so can stop
                            }
                        }
                        cliques.push(clique);
                    }

                    // Filter cliques: if A is subset of B, remove A.
                    // E.g. {A,B}, {B,C}, {C}. {C} is subset of {B,C}? No.
                    // {A,B}, {B}, {C}. {B} is subset of {A,B}.

                    const finalCliques = cliques.filter((c1, i) => {
                        // Check if c1 is subset of any other clique c2
                        return !cliques.some((c2, j) => {
                            if (i === j) return false;
                            return c1.every(val => c2.includes(val)) && c2.length > c1.length;
                        });
                    });

                    // Assign letters
                    finalCliques.forEach((clique, idx) => {
                        const letter = alphabet[idx];
                        clique.forEach(t => {
                            letters[t] = (letters[t] || '') + letter;
                        });
                    });

                    // Sort letters for each treatment (e.g. 'ba' -> 'ab')
                    Object.keys(letters).forEach(t => {
                        letters[t] = letters[t].split('').sort().join('');
                    });

                    return { letters, lsd, mse };
                }
            }

            // =============================================
            // MULTI-PROVIDER AI PHOTO ANALYSIS SYSTEM
            // =============================================

            class MultiProviderAI {

                constructor() {
                    this.providers = [
                        {
                            id: 'groq',
                            name: 'Groq LLaMA 4 Scout',
                            endpoint: 'https://api.groq.com/openai/v1/chat/completions',
                            model: 'meta-llama/llama-4-scout-17b-16e-instruct',
                            dailyLimit: 1000,
                            speed: 1.5
                        },
                        {
                            id: 'gemini-flash',
                            name: 'Gemini 1.5 Flash',
                            endpoint: 'https://generativelanguage.googleapis.com/v1/models/gemini-1.5-flash:generateContent',
                            dailyLimit: 15000,
                            speed: 1
                        },
                        {
                            id: 'gemini',
                            name: 'Gemini 2.5 Pro',
                            endpoint: 'https://generativelanguage.googleapis.com/v1/models/gemini-2.5-pro:generateContent',
                            dailyLimit: 10,
                            speed: 3
                        },
                        {
                            id: 'pixtral',
                            name: 'Pixtral (Mistral)',
                            endpoint: 'https://api.mistral.ai/v1/chat/completions',
                            model: 'pixtral-12b-2409',
                            dailyLimit: 10000,
                            speed: 2
                        },
                        {
                            id: 'qwen',
                            name: 'Alibaba Qwen2.5-VL',
                            endpoint: 'https://dashscope.aliyuncs.com/compatible-mode/v1/chat/completions',
                            model: 'qwen-vl-max',
                            dailyLimit: 5000,
                            speed: 2.5
                        },
                        {
                            id: 'florence',
                            name: 'HuggingFace Florence',
                            endpoint: 'https://api-inference.huggingface.co/models/microsoft/Florence-2-large',
                            dailyLimit: 300,
                            speed: 4
                        }
                    ];

                    this.loadUsageStats();
                }

                loadUsageStats() {
                    const stored = localStorage.getItem('ai_provider_usage');
                    if (!stored) {
                        this.usage = {};
                        return;
                    }

                    const data = JSON.parse(stored);
                    const today = new Date().toISOString().split('T')[0];

                    if (data.date !== today) {
                        this.usage = {};
                    } else {
                        this.usage = data.usage || {};
                    }
                }

                saveUsageStats() {
                    const today = new Date().toISOString().split('T')[0];
                    localStorage.setItem('ai_provider_usage', JSON.stringify({
                        date: today,
                        usage: this.usage
                    }));
                }

                getAPIKey(providerId) {
                    // Gemini Flash uses the same keys as Gemini Pro
                    const baseId = (providerId === 'gemini-flash') ? 'GEMINI' : providerId.toUpperCase();

                    // Try multiple API keys: AI_KEY_GEMINI_1, AI_KEY_GEMINI_2, etc.
                    const keys = [];

                    // First try base key without number
                    const baseKey = localStorage.getItem(`AI_KEY_${baseId}`);
                    if (baseKey) keys.push(baseKey);

                    // Then try numbered keys (1-5)
                    for (let i = 1; i <= 5; i++) {
                        const key = localStorage.getItem(`AI_KEY_${baseId}_${i}`);
                        if (key) keys.push(key);
                    }

                    return keys; // Return array of keys
                }

                hasQuota(provider, keyIndex = 0) {
                    const usageKey = `${provider.id}_${keyIndex}`;
                    const used = this.usage[usageKey] || 0;
                    return used < provider.dailyLimit;
                }

                async generateText(prompt) {
                    // Try each provider in order until one succeeds
                    for (const provider of this.providers) {
                        const apiKeys = this.getAPIKey(provider.id);

                        if (!apiKeys || apiKeys.length === 0) {
                            console.log(`[AI] Skipping ${provider.name} - no API key`);
                            continue;
                        }

                        // Try each API key for this provider
                        for (let keyIndex = 0; keyIndex < apiKeys.length; keyIndex++) {
                            const apiKey = apiKeys[keyIndex];
                            const keyLabel = apiKeys.length > 1 ? ` (Key ${keyIndex + 1}/${apiKeys.length})` : '';

                            if (!this.hasQuota(provider, keyIndex)) {
                                console.log(`[AI] Skipping ${provider.name}${keyLabel} - quota exceeded`);
                                continue;
                            }

                            try {
                                console.log(`[AI] Trying ${provider.name}${keyLabel} for text generation...`);

                                // Build request based on provider type
                                let url = provider.endpoint;
                                let headers = { 'Content-Type': 'application/json' };
                                let body = {};

                                // Gemini uses query param auth
                                if (provider.id.includes('gemini')) {
                                    url = `${provider.endpoint}?key=${apiKey}`;
                                    body = {
                                        contents: [{ parts: [{ text: prompt }] }]
                                    };
                                }
                                // Groq, Mistral, Qwen, Florence use Authorization header
                                else {
                                    headers['Authorization'] = `Bearer ${apiKey}`;
                                    body = {
                                        model: provider.model || 'default',
                                        messages: [{ role: 'user', content: prompt }]
                                    };
                                }

                                const response = await fetch(url, {
                                    method: 'POST',
                                    headers: headers,
                                    body: JSON.stringify(body)
                                });

                                if (!response.ok) {
                                    const err = await response.text();
                                    throw new Error(`API Error: ${response.status}`);
                                }

                                const data = await response.json();

                                // Extract text from response (format varies by provider)
                                let text;
                                if (data.candidates && data.candidates.length > 0) {
                                    // Gemini format
                                    text = data.candidates[0].content.parts[0].text;
                                } else if (data.choices && data.choices.length > 0) {
                                    // OpenAI/Groq/Mistral format
                                    text = data.choices[0].message.content;
                                } else {
                                    throw new Error('No content generated');
                                }

                                // Success! Track usage and return
                                const usageKey = `${provider.id}_${keyIndex}`;
                                this.usage[usageKey] = (this.usage[usageKey] || 0) + 1;
                                this.saveUsageStats();
                                console.log(`[AI] ✅ Success with ${provider.name}${keyLabel}`);
                                return text;

                            } catch (e) {
                                console.warn(`[AI] ${provider.name}${keyLabel} failed:`, e.message);
                                // Continue to next key or provider
                            }
                        }
                    }

                    // All providers and keys failed
                    throw new Error('All AI providers failed or have no quota. Please check your API keys.');
                }

                async analyzePhoto(photoUrl, context) {
                    for (const provider of this.providers) {
                        const apiKey = this.getAPIKey(provider.id);
                        if (!apiKey) continue;

                        if (!this.hasQuota(provider)) {
                            console.log(`${provider.name}: Quota exceeded`);
                            continue;
                        }

                        try {
                            showToast(`Analyzing with ${provider.name}...`, 'info');
                            const result = await this.callProvider(provider, photoUrl, context, apiKey);

                            this.usage[provider.id] = (this.usage[provider.id] || 0) + 1;
                            this.saveUsageStats();

                            console.log(`✅ Success: ${provider.name}`);
                            return {
                                success: true,
                                provider: provider.name,
                                data: result
                            };

                        } catch (error) {
                            console.warn(`❌ ${provider.name} failed:`, error.message);
                            continue;
                        }
                    }

                    return {
                        success: false,
                        error: 'All AI providers failed or quota exceeded.'
                    };
                }

                async callProvider(provider, photoUrl, context, apiKey) {
                    if (provider.id === 'groq') {
                        return await this.callGroq(provider, photoUrl, context, apiKey);
                    } else if (provider.id === 'gemini') {
                        return await this.callGemini(provider, photoUrl, context, apiKey);
                    } else if (provider.id === 'pixtral') {
                        return await this.callPixtral(provider, photoUrl, context, apiKey);
                    } else if (provider.id === 'qwen') {
                        return await this.callQwen(provider, photoUrl, context, apiKey);
                    } else if (provider.id === 'florence') {
                        return await this.callFlorence(provider, photoUrl, context, apiKey);
                    }
                    throw new Error('Unknown provider');
                }

                async callGroq(provider, photoUrl, context, apiKey) {
                    const imageBase64 = await this.fetchAsBase64(photoUrl);

                    const response = await fetch(provider.endpoint, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            model: provider.model,
                            messages: [{
                                role: 'user',
                                content: [
                                    { type: 'text', text: this.buildPrompt(context) },
                                    { type: 'image_url', image_url: { url: `data:image/jpeg;base64,${imageBase64}` } }
                                ]
                            }],
                            temperature: 0.2,
                            max_tokens: 500
                        })
                    });

                    if (!response.ok) throw new Error(`${response.status}: ${response.statusText}`);

                    const data = await response.json();
                    return this.parseJSON(data.choices[0].message.content);
                }

                async callGemini(provider, photoUrl, context, apiKey) {
                    const imageBase64 = await this.fetchAsBase64(photoUrl);

                    const response = await fetch(
                        `${provider.endpoint}?key=${apiKey}`,
                        {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                contents: [{
                                    parts: [
                                        { text: this.buildPrompt(context) },
                                        { inline_data: { mime_type: 'image/jpeg', data: imageBase64 } }
                                    ]
                                }]
                            })
                        }
                    );

                    if (!response.ok) throw new Error(`${response.status}: ${response.statusText}`);

                    const data = await response.json();
                    return this.parseJSON(data.candidates[0].content.parts[0].text);
                }

                async callPixtral(provider, photoUrl, context, apiKey) {
                    const imageBase64 = await this.fetchAsBase64(photoUrl);
                    const response = await fetch(provider.endpoint, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            model: provider.model,
                            messages: [{
                                role: 'user',
                                content: [
                                    { type: 'text', text: this.buildPrompt(context) },
                                    { type: 'image_url', image_url: { url: `data:image/jpeg;base64,${imageBase64}` } }
                                ]
                            }]
                        })
                    });
                    if (!response.ok) throw new Error(`${response.status}: ${response.statusText}`);
                    const data = await response.json();
                    return this.parseJSON(data.choices[0].message.content);
                }

                async callQwen(provider, photoUrl, context, apiKey) {
                    const imageBase64 = await this.fetchAsBase64(photoUrl);
                    const response = await fetch(provider.endpoint, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            model: provider.model,
                            input: {
                                messages: [{
                                    role: 'user',
                                    content: [
                                        { text: this.buildPrompt(context) },
                                        { image: `data:image/jpeg;base64,${imageBase64}` }
                                    ]
                                }]
                            }
                        })
                    });
                    if (!response.ok) throw new Error(`${response.status}: ${response.statusText}`);
                    const data = await response.json();
                    // Alibaba structure check
                    return this.parseJSON(data.output.choices[0].message.content);
                }

                async callFlorence(provider, photoUrl, context, apiKey) {
                    const imageBase64 = await this.fetchAsBase64(photoUrl);
                    // Florence accepts different input formats sometimes, but HF Inference API standard is usually:
                    const response = await fetch(provider.endpoint, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            inputs: {
                                image: imageBase64,
                                question: this.buildPrompt(context)
                            }
                        })
                    });
                    if (!response.ok) throw new Error(`${response.status}: ${response.statusText}`);
                    const data = await response.json();
                    // HF Florence output might need checking, usually generated_text
                    let text = data.generated_text || data[0]?.generated_text || JSON.stringify(data);
                    // Florence 2 output is often parsed task result. We are asking for direct JSON prompt response.
                    return this.parseJSON(text);
                }

                buildPrompt(context) {
                    return `Analyze this herbicide trial plot photo and extract weed data in JSON format only.

PLOT INFO:
- Treatment: ${context.treatment}
- Days After Application: ${context.daa}
- Rep: ${context.rep}

TASK:
1. Identify weed species (common names)
2. Estimate % ground cover per species (0-100)
3. Estimate crop phytotoxicity % (0-100)
4. Rate confidence (LOW/MEDIUM/HIGH)

RESPOND WITH JSON ONLY (no markdown, no explanation):
{
  "weeds": [
    {"species": "Crabgrass", "cover": 25},
    {"species": "Pigweed", "cover": 10}
  ],
  "phytotoxicity": 5,
  "confidence": "HIGH",
  "notes": "Clear photo"
}`;
                }

                async fetchAsBase64(url) {
                    // Check if it's a Google Drive URL
                    if (url.includes('drive.google.com')) {
                        // Use backend proxy to bypass CORS
                        try {
                            console.log('📸 Fetching image via backend:', url);
                            const result = await apiCall('getImageBase64', { imageUrl: url }, false);
                            console.log('📥 Backend response:', result);

                            if (result && result.base64) {
                                console.log('✅ Got base64 data, length:', result.base64.length);
                                return result.base64;
                            }

                            console.error('❌ Backend returned no base64:', result);
                            throw new Error('Backend failed to fetch image: ' + (result.message || 'No base64 data'));
                        } catch (error) {
                            console.error('Backend image fetch failed:', error);
                            throw new Error('Could not fetch image from Google Drive: ' + error.message);
                        }
                    }

                    // For non-Drive URLs, try direct fetch
                    try {
                        const response = await fetch(url);
                        if (!response.ok) throw new Error(`HTTP ${response.status}`);
                        const blob = await response.blob();
                        return new Promise((resolve) => {
                            const reader = new FileReader();
                            reader.onloadend = () => {
                                const base64 = reader.result.split(',')[1];
                                resolve(base64);
                            };
                            reader.readAsDataURL(blob);
                        });
                    } catch (error) {
                        console.error('Direct fetch failed:', error);
                        throw new Error('Could not fetch image');
                    }
                }

                parseJSON(text) {
                    const jsonMatch = text.match(/```json\n([\s\S]*?)\n```/) ||
                        text.match(/```\n([\s\S]*?)\n```/) ||
                        text.match(/\{[\s\S]*\}/);

                    if (jsonMatch) {
                        return JSON.parse(jsonMatch[1] || jsonMatch[0]);
                    }

                    return JSON.parse(text);
                }
            }

            // Initialize AI
            const aiAnalyzer = new MultiProviderAI();

            // AI Settings Functions
            window.saveAIKey = async function (provider) {
                const input = document.getElementById(`ai-key-${provider}`);
                const statusEl = document.getElementById(`${provider}-status`);

                if (!input.value.trim()) {
                    statusEl.textContent = '❌ Please enter an API key';
                    statusEl.className = 'ml-2 text-sm text-red-500';
                    return;
                }

                localStorage.setItem(`AI_KEY_${provider.toUpperCase()}`, input.value.trim());
                statusEl.textContent = '✅ Saved!';
                statusEl.className = 'ml-2 text-sm text-green-500';

                setTimeout(() => {
                    statusEl.textContent = '';
                }, 3000);
            };

            window.loadAIKeys = function () {
                const groqKey = localStorage.getItem('AI_KEY_GROQ');
                const geminiKey = localStorage.getItem('AI_KEY_GEMINI');

                const groqInput = document.getElementById('ai-key-groq');
                const geminiInput = document.getElementById('ai-key-gemini');

                if (groqInput && groqKey) groqInput.value = groqKey;
                if (geminiInput && geminiKey) geminiInput.value = geminiKey;
            };

            // AI Analysis Modal Functions
            window.openAIAnalysisModal = function () {
                document.getElementById('ai-analysis-modal').classList.remove('hidden');
            };

            window.closeAIAnalysisModal = function () {
                document.getElementById('ai-analysis-modal').classList.add('hidden');
            };

            window.startAIAnalysis = async function () {
                // Try to get project ID from state or from trials
                let projectId = state.activeProjectId;

                if (!projectId) {
                    // Fallback: find project from trials
                    const trialsWithProject = state.trials.filter(t => t.ProjectID);
                    if (trialsWithProject.length > 0) {
                        projectId = trialsWithProject[0].ProjectID;
                    }
                }

                const project = state.projects.find(p => p.ID === projectId);
                if (!project) {
                    showToast('No project found. Please make sure you have trials with photos.', 'error');
                    closeAIAnalysisModal();
                    return;
                }

                const trials = state.trials.filter(t => t.ProjectID === projectId);
                const photosToAnalyze = [];

                console.log(`📊 Found ${trials.length} trials for project ${projectId}`);

                trials.forEach(trial => {
                    // Use PhotoURLs (main trial photos) instead of WeedPhotosJSON (close-up weed ID only)
                    const mainPhotos = safeJsonParse(trial.PhotoURLs) || [];
                    const weedIdPhotos = safeJsonParse(trial.WeedPhotosJSON) || [];

                    console.log(`Trial ${trial.FormulationName}: ${mainPhotos.length} main photos, ${weedIdPhotos.length} weed ID photos`);

                    // Prioritize main trial photos (PhotoURLs) for efficacy analysis
                    const photosToUse = mainPhotos.length > 0 ? mainPhotos : weedIdPhotos;
                    const trialDate = new Date(trial.Date);

                    photosToUse.forEach(photo => {
                        if (photo.url) {
                            // ALWAYS calculate DAA from photo date (don't trust stored daa values)
                            let calculatedDAA = 0;
                            if (photo.date) {
                                const photoDate = new Date(photo.date);
                                calculatedDAA = Math.round((photoDate.getTime() - trialDate.getTime()) / (1000 * 60 * 60 * 24));
                                calculatedDAA = calculatedDAA >= 0 ? calculatedDAA : 0;
                                console.log(`  📅 Photo date: ${photo.date}, Trial date: ${trial.Date}, Calculated DAA: ${calculatedDAA}`);
                            } else {
                                console.warn(`  ⚠️ Photo missing date, defaulting to DAA 0`);
                            }

                            photosToAnalyze.push({
                                trialId: trial.ID,
                                photoUrl: photo.url,
                                treatment: trial.FormulationName,
                                rep: trial.Replication || 1,
                                daa: calculatedDAA  // Use calculated value, ignore photo.daa
                            });
                        }
                    });
                });

                console.log(`🖼️ Total photos to analyze: ${photosToAnalyze.length}`);

                if (photosToAnalyze.length === 0) {
                    showToast('No photos found to analyze', 'warning');
                    closeAIAnalysisModal();
                    return;
                }

                // Close modal and run in background
                closeAIAnalysisModal();
                showAIStatusWidget();

                // Run analysis in background (non-blocking)
                runBackgroundAnalysis(photosToAnalyze);
            };

            // Background analysis function
            async function runBackgroundAnalysis(photosToAnalyze) {
                const statusWidget = document.getElementById('ai-status-widget');
                const statusText = document.getElementById('ai-status-text');
                const statusProgress = document.getElementById('ai-status-progress-bar');

                for (let i = 0; i < photosToAnalyze.length; i++) {
                    const photo = photosToAnalyze[i];
                    const progress = Math.round(((i + 1) / photosToAnalyze.length) * 100);

                    // Update status widget
                    statusProgress.style.width = `${progress}%`;
                    statusText.textContent = `Analyzing ${i + 1}/${photosToAnalyze.length}`;

                    const result = await aiAnalyzer.analyzePhoto(photo.photoUrl, {
                        treatment: photo.treatment,
                        rep: photo.rep,
                        daa: photo.daa
                    });

                    if (result.success && result.data) {
                        await createObservationFromAI(photo.trialId, photo.daa, result.data);
                    }

                    // Brief delay between photos
                    if (i < photosToAnalyze.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, 4000));
                    }
                }

                // Analysis complete
                statusText.textContent = `✅ Complete! ${photosToAnalyze.length} photos analyzed`;
                statusProgress.style.width = '100%';
                showToast(`AI Analysis complete! ${photosToAnalyze.length} photos analyzed.`, 'success');

                // Hide status widget after 5 seconds
                setTimeout(() => {
                    if (statusWidget) statusWidget.classList.add('hidden');
                }, 5000);

                // Silent update: No full page reload needed
                console.log('✅ Analysis complete. UI will update on next navigation.');
            }

            async function loadDataFromBackend() {
                try {
                    const result = await apiCall('getAllData', {}, false);
                    if (result) {
                        state.trials = result.trials || [];
                        state.formulations = result.formulations || [];
                        state.ingredients = result.ingredients || [];
                        state.organisations = result.organisations || [];
                        state.projects = result.projects || [];
                        state.blocks = result.blocks || [];

                        // Fire update event
                        document.dispatchEvent(new Event('dataUpdated'));
                        console.log('Data reloaded from backend');
                    }
                } catch (e) {
                    console.error('Failed to load data:', e);
                }
            }

            // Show AI status widget (top-right corner)
            function showAIStatusWidget() {
                let widget = document.getElementById('ai-status-widget');
                if (!widget) {
                    // Create widget if doesn't exist
                    widget = document.createElement('div');
                    widget.id = 'ai-status-widget';
                    widget.className = 'fixed top-4 right-4 bg-white shadow-lg rounded-lg p-4 z-50';
                    widget.style.cssText = 'position:fixed;top:1rem;right:1rem;background:white;box-shadow:0 4px 6px rgba(0,0,0,0.1);border-radius:0.5rem;padding:1rem;z-index:1000;min-width:250px;';
                    widget.innerHTML = `
                        <div class="flex items-center gap-2 mb-2">
                            <div class="w-3 h-3 bg-purple-500 rounded-full animate-pulse"></div>
                            <span class="font-semibold text-gray-800">AI Analysis</span>
                            <button onclick="document.getElementById('ai-status-widget').classList.add('hidden')" 
                                    class="ml-auto text-gray-400 hover:text-gray-600"  style="margin-left:auto;">✕</button>
                        </div>
                        <div id="ai-status-text" class="text-sm text-gray-600 mb-2">Starting...</div>
                        <div class="w-full bg-gray-200 rounded-full h-2">
                            <div id="ai-status-progress-bar" class="bg-purple-500 h-2 rounded-full transition-all duration-300" style="width:0%"></div>
                        </div>
                    `;
                    document.body.appendChild(widget);
                }
                widget.classList.remove('hidden');
            }


            async function createObservationFromAI(trialId, daa, aiData) {
                console.log('🔍 Creating observation for trial:', trialId);
                console.log('📊 AI Data received:', aiData);

                const trial = state.trials.find(t => t.ID === trialId);
                if (!trial) {
                    console.error('❌ Trial not found:', trialId);
                    return;
                }

                const efficacyData = safeJsonParse(trial.EfficacyDataJSON) || [];
                console.log(`📝 Existing efficacy data: ${efficacyData.length} observations`);

                const newObservation = {
                    date: new Date().toISOString().split('T')[0],
                    daa: daa,
                    phyto: aiData.phytotoxicity || 0,
                    weedDetails: aiData.weeds || [],
                    notes: aiData.notes || `AI-analyzed on ${new Date().toLocaleDateString()}`,
                    status: aiData.status || 'Analyzed',
                    source: 'AI'
                };

                efficacyData.push(newObservation);
                console.log('➕ Added new observation:', newObservation);

                // Calculate Result field for RCBD chart compatibility
                // For weeds with 0% cover (all dead), use high phytotoxicity value
                let resultValue = 0;
                if (aiData.weeds && aiData.weeds.length > 0) {
                    // Average cover % from all detected weeds
                    resultValue = aiData.weeds.reduce((sum, w) => sum + (w.cover || 0), 0) / aiData.weeds.length;
                } else {
                    // Always return a value to make the bar visible
                    // 100 - Phyto (e.g., 90% Phyto -> 10 Result)
                    resultValue = 100 - (aiData.phytotoxicity || 0);
                }

                console.log(`📈 Calculated Result value: ${resultValue.toFixed(2)}`);

                try {
                    const updatePayload = {
                        ID: trialId,
                        EfficacyDataJSON: JSON.stringify(efficacyData),
                        Result: resultValue.toFixed(2), // Keep as string for UI compatibility (fixes .toLowerCase error)
                        WeedSpecies: aiData.weeds && aiData.weeds.length > 0
                            ? aiData.weeds.map(w => w.species).join(', ')
                            : 'No weeds detected'
                    };

                    const result = await apiCall('updateTrial', updatePayload);
                    console.log('✅ Saved to backend:', result);

                    trial.EfficacyDataJSON = JSON.stringify(efficacyData);
                    trial.Result = resultValue.toFixed(2); // Keep as string locally too
                    trial.WeedSpecies = updatePayload.WeedSpecies;
                    console.log('✅ Updated local state');
                } catch (error) {
                    console.error('❌ Failed to save:', error);
                }
            }

            // =============================================
            // AUTO-INJECT AI UI TEMPLATES
            // =============================================

            // Store original render functions
            const originalRenderFunctions = {};

            // Inject AI Settings into Settings Page
            function injectAISettings() {
                setTimeout(() => {
                    const mainContent = document.getElementById('main-content');
                    if (!mainContent || document.getElementById('ai-settings-injected')) return;

                    const template = document.getElementById('ai-settings-template');
                    if (template) {
                        const clone = template.content.cloneNode(true);
                        const wrapper = document.createElement('div');
                        wrapper.id = 'ai-settings-injected';
                        wrapper.appendChild(clone);
                        mainContent.appendChild(wrapper);
                        loadAIKeys();
                    }
                }, 300);
            }

            // Inject AI Analyze Button into Project Dashboard
            function injectAnalyzeButton() {
                setTimeout(() => {
                    const mainContent = document.getElementById('main-content');
                    if (!mainContent || document.getElementById('ai-analyze-btn-injected')) return;

                    const template = document.getElementById('ai-analyze-button-template');
                    if (template) {
                        const clone = template.content.cloneNode(true);
                        const wrapper = document.createElement('div');
                        wrapper.id = 'ai-analyze-btn-injected';
                        wrapper.appendChild(clone);

                        // Insert at the top of content
                        mainContent.insertBefore(wrapper, mainContent.firstChild);
                    }
                }, 300);
            }


            // Hook into page navigation
            document.addEventListener('click', function (e) {
                const link = e.target.closest('[data-page]');
                if (!link) return;

                const page = link.dataset.page;

                // Clean up previous injections when changing pages
                const existingInjection = document.getElementById('ai-analyze-btn-injected');
                if (existingInjection && page !== 'trials' && page !== 'projects') {
                    existingInjection.remove();
                }

                setTimeout(() => {
                    if (page === 'settings') {
                        injectAISettings();
                    } else if (page === 'trials' || page === 'projects' || state.activeProjectId) {
                        injectAnalyzeButton();
                    }
                }, 400);
            });

            // Watch for tab clicks (Project Plots tab)
            document.addEventListener('click', function (e) {
                const tab = e.target.closest('[data-tab]');
                if (tab) {
                    setTimeout(() => {
                        injectAnalyzeButton();
                    }, 500);
                }
            });

            // Periodic check to inject button if trials are visible
            setInterval(() => {
                const mainContent = document.getElementById('main-content');
                if (mainContent && mainContent.innerText.includes('NEW TRIALS CHECK')) {
                    injectAnalyzeButton();
                }
            }, 2000);

            // Also inject on page load
            setTimeout(() => {
                injectAnalyzeButton();
            }, 1000);


        });
    </script>

    <!-- AI ANALYSIS MODAL -->
    <div id="ai-analysis-modal"
        class="hidden fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center">
        <div class="bg-white rounded-lg p-6 max-w-2xl w-full mx-4 shadow-2xl">
            <h2 class="text-2xl font-bold mb-4 text-gray-800">🤖 AI Photo Analysis</h2>

            <div id="ai-analysis-status" class="mb-4">
                <p class="text-gray-700">Ready to analyze all trial photos with FREE AI providers</p>
                <p class="text-sm text-gray-500 mt-2">Note: 4-second delay between photos (rate limit compliance)</p>
            </div>

            <div id="ai-progress" class="hidden mb-4">
                <div class="w-full bg-gray-200 rounded-full h-4 overflow-hidden">
                    <div id="ai-progress-bar"
                        class="bg-gradient-to-r from-blue-500 to-purple-500 h-4 rounded-full transition-all duration-300"
                        style="width: 0%"></div>
                </div>
                <p id="ai-progress-text" class="text-sm text-gray-600 mt-2 font-semibold"></p>
            </div>

            <div class="flex gap-4 justify-end">
                <button onclick="closeAIAnalysisModal()"
                    class="px-6 py-2 bg-gray-300 hover:bg-gray-400 rounded-md font-semibold transition-colors">
                    Cancel
                </button>
                <button onclick="startAIAnalysis()" id="start-ai-btn"
                    class="px-6 py-2 bg-gradient-to-r from-blue-500 to-purple-500 hover:from-blue-600 hover:to-purple-600 text-white rounded-md font-semibold shadow-lg transition-all">
                    Start AI Analysis (FREE)
                </button>
            </div>
        </div>
    </div>

    <!-- AI SETTINGS CONTAINER (Will be appended to settings page) -->
    <template id="ai-settings-template">
        <div class="bg-white rounded-lg shadow-md p-6 mb-6 mt-6">
            <h3 class="text-xl font-bold mb-4">🤖 AI Provider API Keys (FREE)</h3>
            <p class="text-sm text-gray-600 mb-4">Add API keys for automatic photo analysis. All providers are 100%
                FREE!</p>

            <div class="space-y-4">
                <!-- Groq -->
                <div class="border rounded-lg p-4 bg-gradient-to-r from-purple-50 to-blue-50">
                    <label class="font-semibold flex items-center justify-between">
                        ⚡ Groq LLaMA 4 Scout (FASTEST - 1-2 seconds!)
                        <a href="https://console.groq.com/keys" target="_blank"
                            class="text-blue-600 text-sm underline hover:text-blue-800">
                            Get Free Key →
                        </a>
                    </label>
                    <input type="password" id="ai-key-groq"
                        class="w-full mt-2 px-4 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-purple-500"
                        placeholder="gsk_..." />
                    <button onclick="saveAIKey('groq')"
                        class="mt-2 px-4 py-2 bg-purple-600 hover:bg-purple-700 text-white rounded-md font-semibold transition-colors">
                        💾 Save & Test
                    </button>
                    <span id="groq-status" class="ml-2 text-sm"></span>
                </div>

                <!-- Gemini -->
                <div class="border rounded-lg p-4 bg-gradient-to-r from-blue-50 to-green-50">
                    <label class="font-semibold flex items-center justify-between">
                        🎯 Gemini 2.5 Pro (Most Accurate)
                        <a href="https://aistudio.google.com/apikey" target="_blank"
                            class="text-blue-600 text-sm underline hover:text-blue-800">
                            Get Free Key →
                        </a>
                    </label>
                    <input type="password" id="ai-key-gemini"
                        class="w-full mt-2 px-4 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500"
                        placeholder="AIza..." />
                    <button onclick="saveAIKey('gemini')"
                        class="mt-2 px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-md font-semibold transition-colors">
                        💾 Save & Test
                    </button>
                    <span id="gemini-status" class="ml-2 text-sm"></span>
                </div>

                <!-- Pixtral (Mistral) -->
                <div class="border rounded-lg p-4 bg-gradient-to-r from-yellow-50 to-orange-50">
                    <label class="font-semibold flex items-center justify-between">
                        🌊 Pixtral (Mistral) (High Capacity - 10k/day!)
                        <a href="https://console.mistral.ai/" target="_blank"
                            class="text-blue-600 text-sm underline hover:text-blue-800">
                            Get Free Key →
                        </a>
                    </label>
                    <input type="password" id="ai-key-pixtral"
                        class="w-full mt-2 px-4 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-yellow-500"
                        placeholder="Key..." />
                    <button onclick="saveAIKey('pixtral')"
                        class="mt-2 px-4 py-2 bg-yellow-600 hover:bg-yellow-700 text-white rounded-md font-semibold transition-colors">
                        💾 Save & Test
                    </button>
                    <span id="pixtral-status" class="ml-2 text-sm"></span>
                </div>

                <!-- Alibaba Qwen -->
                <div class="border rounded-lg p-4 bg-gradient-to-r from-red-50 to-pink-50">
                    <label class="font-semibold flex items-center justify-between">
                        🐉 Alibaba Qwen 2.5 (High Speed)
                        <a href="https://bailian.console.aliyun.com/" target="_blank"
                            class="text-blue-600 text-sm underline hover:text-blue-800">
                            Get Free Key →
                        </a>
                    </label>
                    <input type="password" id="ai-key-qwen"
                        class="w-full mt-2 px-4 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-red-500"
                        placeholder="sk-..." />
                    <button onclick="saveAIKey('qwen')"
                        class="mt-2 px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded-md font-semibold transition-colors">
                        💾 Save & Test
                    </button>
                    <span id="qwen-status" class="ml-2 text-sm"></span>
                </div>

                <!-- Florence -->
                <div class="border rounded-lg p-4 bg-gradient-to-r from-gray-50 to-gray-200">
                    <label class="font-semibold flex items-center justify-between">
                        🤗 HuggingFace Florence (Backup)
                        <a href="https://huggingface.co/settings/tokens" target="_blank"
                            class="text-blue-600 text-sm underline hover:text-blue-800">
                            Get Free Token →
                        </a>
                    </label>
                    <input type="password" id="ai-key-florence"
                        class="w-full mt-2 px-4 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-gray-500"
                        placeholder="hf_..." />
                    <button onclick="saveAIKey('florence')"
                        class="mt-2 px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white rounded-md font-semibold transition-colors">
                        💾 Save & Test
                    </button>
                    <span id="florence-status" class="ml-2 text-sm"></span>
                </div>

                <div class="bg-yellow-50 border-l-4 border-yellow-400 p-4 mt-4">
                    <p class="text-sm text-yellow-800">
                        💡 <strong>Tip:</strong> Add at least one API key to enable AI photo analysis. Both are free!
                    </p>
                </div>
            </div>
        </div>
    </template>

    <!-- AI ANALYZE BUTTON TEMPLATE (Will be added to project dashboard) -->
    <template id="ai-analyze-button-template">
        <button onclick="openAIAnalysisModal()"
            class="px-6 py-3 bg-gradient-to-r from-purple-500 via-pink-500 to-red-500 hover:from-purple-600 hover:via-pink-600 hover:to-red-600 text-white rounded-lg font-bold shadow-xl hover:shadow-2xl transition-all transform hover:scale-105 flex items-center gap-2 mb-4">
            <span class="text-2xl">🤖</span>
            <span>Analyze All Photos with AI (FREE)</span>
        </button>
    </template>

    <script>
        // Global Key Management Functions (Override)
        window.loadAIKeys = function () {
            const providers = ['groq', 'gemini', 'pixtral', 'qwen', 'florence'];
            providers.forEach(id => {
                const key = localStorage.getItem(`AI_KEY_${id.toUpperCase()}`);
                const input = document.getElementById(`ai-key-${id}`);
                const status = document.getElementById(`${id}-status`);
                if (input && key) {
                    input.value = key;
                    if (status) {
                        status.textContent = '✅ Saved';
                        status.className = 'ml-2 text-sm text-green-600 font-semibold';
                    }
                }
            });
        };

        window.saveAIKey = function (providerId) {
            const input = document.getElementById(`ai-key-${providerId}`);
            const status = document.getElementById(`${providerId}-status`);
            if (!input) return;

            const key = input.value.trim();
            if (!key) {
                if (typeof showToast === 'function') showToast('Please enter an API key', 'error');
                return;
            }

            localStorage.setItem(`AI_KEY_${providerId.toUpperCase()}`, key);
            if (status) {
                status.textContent = '✅ Saved';
                status.className = 'ml-2 text-sm text-green-600 font-semibold';
            }
            if (typeof showToast === 'function') {
                showToast(`${providerId.charAt(0).toUpperCase() + providerId.slice(1)} key saved!`, 'success');
            }
        };
    </script>
</body>

</html>
